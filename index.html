<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#0a0a0a">
  <link rel="icon" type="image/png" href="https://storage.googleapis.com/intelechia-content/im/BRRST%20(3).png">
  <link rel="apple-touch-icon" href="https://storage.googleapis.com/intelechia-content/im/BRRST%20(3).png">
  <title>BRSST</title>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/@phosphor-icons/web"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    :root {
      /* Dark mode palette - cozy, not harsh */
      --bg: #0a0a0a; --bg2: #111111; --bg3: #1a1a1a; --bg4: #1f1f1f;
      /* Soft borders using opacity for depth */
      --border: rgba(255,255,255,0.06); --border2: rgba(255,255,255,0.1);
      /* Text hierarchy */
      --text: #ffffff; --text2: #a1a1a1; --text3: #666;
      /* Accent colors */
      --orange: #FF6B35; --orange2: #FF8E72;
      --blue: #3b82f6; --blue2: #60a5fa;
      /* Legacy compatibility */
      --green: var(--orange); --green2: var(--orange2);

      /* Mobile-specific spacing scale */
      --mobile-space-xs: 8px;
      --mobile-space-sm: 12px;
      --mobile-space-md: 16px;
      --mobile-space-lg: 20px;
      --mobile-space-xl: 24px;
      --mobile-space-2xl: 32px;

      /* Mobile touch targets */
      --mobile-touch-min: 44px;
      --mobile-touch-comfortable: 48px;
      --mobile-touch-large: 56px;

      /* Mobile typography scale */
      --mobile-text-xs: 12px;
      --mobile-text-sm: 13px;
      --mobile-text-base: 15px;
      --mobile-text-md: 16px;
      --mobile-text-lg: 17px;
      --mobile-text-xl: 18px;
      --mobile-text-2xl: 20px;
      --mobile-text-3xl: 24px;
      --mobile-text-4xl: 28px;

      /* Safe area insets (iOS notch/home indicator) */
      --sat: env(safe-area-inset-top);
      --sar: env(safe-area-inset-right);
      --sab: env(safe-area-inset-bottom);
      --sal: env(safe-area-inset-left);

      /* Mobile-specific z-index layers */
      --z-mobile-header: 100;
      --z-mobile-nav: 96;
      --z-mobile-player: 95;
      --z-mobile-drawer: 150;
      --z-mobile-modal: 200;
      --z-mobile-toast: 300;
    }
    html, body { height: 100%; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; background: var(--bg); color: var(--text); overflow: hidden; }
    ::-webkit-scrollbar { width: 8px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.15); border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.25); }
    
    .app { display: flex; flex-direction: column; height: 100vh; }
    
    /* Header - Soft dark with subtle border */
    .header { background: var(--bg3); border-bottom: 1px solid var(--border2); padding: 20px 24px 10px 24px; display: flex; align-items: center; gap: 16px; }
    .logo { display: flex; align-items: center; }
    .logo img { height: 32px; width: auto; }
    .logo-rss { color: var(--orange); }
    .main-toggle { display: flex; background: var(--bg4); border-radius: 24px; padding: 3px; border: 1px solid var(--border2); }
    .toggle-btn { padding: 8px 18px; background: transparent; border: none; border-radius: 20px; color: var(--text2); font-size: 13px; font-weight: 600; cursor: pointer; font-family: inherit; display: flex; align-items: center; gap: 6px; transition: all 0.2s ease-out; }
    .toggle-btn.active { background: var(--blue); color: #fff; box-shadow: 0 2px 8px rgba(59,130,246,0.3); }
    .toggle-btn:not(.active):hover { background: rgba(255,255,255,0.05); color: var(--text); }
    .spacer { flex: 1; }
    .search-box { max-width: 280px; flex: 1; position: relative; }
    .search-box input { width: 100%; padding: 8px 16px 8px 38px; background: var(--bg4); border: 1px solid var(--border2); border-radius: 20px; color: var(--text); font-size: 13px; font-family: inherit; transition: all 0.2s; }
    .search-box input:focus { outline: none; border-color: var(--blue); background: var(--bg); }
    .search-box input::placeholder { color: var(--text3); }
    .search-box svg { position: absolute; left: 14px; top: 50%; transform: translateY(-50%); color: var(--text3); }
    .search-box .search-clear { position: absolute; right: 8px; top: 50%; transform: translateY(-50%); background: var(--bg3); border: none; color: var(--text3); width: 20px; height: 20px; border-radius: 50%; cursor: pointer; display: none; align-items: center; justify-content: center; font-size: 12px; transition: all 0.15s; }
    .search-box .search-clear:hover { background: var(--bg4); color: var(--text); }
    .search-box.has-query .search-clear { display: flex; }
    .search-box.has-query input { padding-right: 36px; }
    .search-scope { position: absolute; top: 100%; left: 0; right: 0; margin-top: 4px; background: var(--bg2); border: 1px solid var(--border2); border-radius: 12px; box-shadow: 0 8px 24px rgba(0,0,0,0.3); z-index: 1000; max-height: 300px; overflow-y: auto; display: none; }
    .search-scope.active { display: block; }
    .search-scope-header { padding: 12px 16px; border-bottom: 1px solid var(--border2); font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text3); }
    .search-scope-item { display: flex; align-items: center; gap: 10px; padding: 10px 16px; cursor: pointer; transition: background 0.15s; }
    .search-scope-item:hover { background: var(--bg4); }
    .search-scope-item.active { background: var(--bg4); color: var(--blue); }
    .search-scope-item .scope-icon { width: 24px; height: 24px; border-radius: 6px; background: var(--bg3); display: flex; align-items: center; justify-content: center; font-size: 12px; overflow: hidden; }
    .search-scope-item .scope-icon img { width: 100%; height: 100%; object-fit: cover; }
    .search-scope-item .scope-name { flex: 1; font-size: 13px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .search-scope-badge { background: var(--bg3); padding: 3px 8px; border-radius: 10px; font-size: 10px; font-weight: 600; color: var(--text2); margin-left: 4px; }
    .search-scope-badge.active { background: var(--blue); color: #fff; }
    .search-results-info { padding: 8px 16px; background: var(--bg3); border-radius: 8px; margin-bottom: 12px; font-size: 12px; color: var(--text2); display: flex; align-items: center; gap: 8px; }
    .search-results-info strong { color: var(--text); }
    .search-results-info .search-scope-tag { background: var(--blue); color: #fff; padding: 2px 8px; border-radius: 10px; font-size: 10px; font-weight: 600; }
    .search-highlight { background: rgba(59,130,246,0.3); color: var(--text); border-radius: 2px; padding: 0 2px; }
    .icon-btn { background: none; border: none; color: var(--text2); cursor: pointer; padding: 8px 12px; border-radius: 8px; transition: all 0.15s ease-out; display: flex; align-items: center; justify-content: center; }
    .icon-btn:hover { background: rgba(255,255,255,0.05); color: var(--text); }
    
    /* Main */
    .main { flex: 1; overflow: hidden; }
    
    /* === NEWS VIEW === */
    .news-view { display: none; height: 100%; }
    .news-view.active { display: flex; }

    .news-sidebar { width: 260px; background: var(--bg2); border-right: 1px solid var(--border2); display: flex; flex-direction: column; }
    .sidebar-header { padding: 12px 20px; border-bottom: 1px solid var(--border2); display: flex; align-items: center; justify-content: space-between; }
    .sidebar-header h2 { font-size: 12px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text2); }
    .add-btn { background: var(--blue); border: none; color: #fff; width: 28px; height: 28px; border-radius: 50%; cursor: pointer; font-size: 18px; transition: all 0.15s; box-shadow: 0 2px 6px rgba(59,130,246,0.3); display: inline-flex; align-items: center; justify-content: center; }
    .add-btn:hover { background: var(--blue2); transform: scale(1.05); }
    .add-btn.discover-btn { margin-right: 8px; font-size: 14px; }
    .sidebar-header .add-btn + .add-btn { margin-left: 0; }
    .sidebar-content { flex: 1; overflow-y: auto; padding: 12px; }

    .source-item { display: flex; align-items: center; gap: 12px; padding: 12px; border-radius: 12px; cursor: pointer; margin-bottom: 4px; transition: all 0.15s ease-out; }
    .source-item:hover { background: rgba(255,255,255,0.04); }
    .source-item:hover .source-name { color: var(--blue); }
    .source-item.active { background: var(--bg4); border: 1px solid var(--border2); }
    .source-icon { width: 36px; height: 36px; border-radius: 10px; background: var(--bg3); display: flex; align-items: center; justify-content: center; font-size: 18px; overflow: hidden; flex-shrink: 0; box-shadow: 0 2px 8px rgba(0,0,0,0.2); }
    .source-icon img { width: 100%; height: 100%; object-fit: cover; }
    .source-name { flex: 1; font-size: 14px; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; transition: color 0.15s; }
    .source-badge { background: var(--orange); color: #fff; font-size: 10px; font-weight: 700; padding: 3px 8px; border-radius: 12px; flex-shrink: 0; box-shadow: 0 2px 6px rgba(255,107,53,0.3); }
    .source-arrow { color: var(--text3); opacity: 0; transition: opacity 0.15s; }
    .source-item:hover .source-arrow { opacity: 1; }

    /* New content indicator styles */
    .source-item { position: relative; }
    .source-info { flex: 1; min-width: 0; }
    .source-info .source-name { flex: none; }
    .source-subtitle { font-size: 11px; color: var(--blue); font-weight: 500; margin-top: 2px; }
    .new-indicator { position: absolute; left: 4px; top: 50%; transform: translateY(-50%); width: 6px; height: 6px; background: var(--blue); border-radius: 50%; box-shadow: 0 0 8px var(--blue); }
    .source-item.has-new { padding-left: 16px; }
    .source-item.has-new .source-name { color: var(--text); }

    /* Show card new content indicator */
    .show-card { position: relative; }
    .show-card.has-new .new-indicator { position: absolute; top: 8px; right: 8px; width: 10px; height: 10px; z-index: 1; }
    .show-card .show-new-indicator { color: var(--blue); font-weight: 500; }

    .news-content { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
    .news-list-view { display: flex; flex-direction: column; gap: 12px; }
    .news-header { padding: 12px 24px; border-bottom: 1px solid var(--border2); display: flex; align-items: center; gap: 16px; flex-wrap: wrap; }
    .news-title { font-size: 20px; font-weight: 600; letter-spacing: -0.02em; }
    .category-chips { display: flex; gap: 8px; overflow-x: auto; flex: 1; min-width: 200px; }

    /* Mobile news header - hidden on desktop */
    .mobile-news-header { display: none; }
    .chip { padding: 8px 16px; background: var(--bg4); border: 1px solid var(--border2); border-radius: 20px; color: var(--text2); font-size: 13px; font-weight: 500; cursor: pointer; white-space: nowrap; font-family: inherit; transition: all 0.2s ease-out; }
    .chip:hover { background: rgba(255,255,255,0.08); color: var(--text); border-color: var(--border2); }
    .chip.active { background: var(--blue); border-color: var(--blue); color: #fff; box-shadow: 0 2px 8px rgba(59,130,246,0.3); }

    /* Tag Filter Styles */
    .tag-filter-section { padding: 12px 24px; border-bottom: 1px solid var(--border2); background: var(--bg2); }
    .tag-filter-header { display: flex; align-items: center; gap: 8px; margin-bottom: 10px; }
    .tag-filter-title { font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text3); }
    .tag-chips { display: flex; gap: 8px; overflow-x: auto; padding-bottom: 4px; -webkit-overflow-scrolling: touch; scrollbar-width: none; }
    .tag-chips::-webkit-scrollbar { display: none; }
    .tag-chip { padding: 6px 12px; background: var(--bg4); border: 1px solid var(--border2); border-radius: 16px; color: var(--text2); font-size: 12px; font-weight: 500; cursor: pointer; white-space: nowrap; font-family: inherit; transition: all 0.2s ease-out; display: flex; align-items: center; gap: 5px; }
    .tag-chip:hover { background: rgba(255,255,255,0.08); color: var(--text); border-color: var(--border2); }
    .tag-chip.active { background: var(--blue); border-color: var(--blue); color: #fff; box-shadow: 0 2px 8px rgba(59,130,246,0.3); }
    .tag-chip .tag-icon { font-size: 12px; }
    .tag-chip .tag-count { background: rgba(0,0,0,0.2); padding: 2px 6px; border-radius: 10px; font-size: 10px; margin-left: 2px; }
    .tag-chip.active .tag-count { background: rgba(255,255,255,0.2); }

    /* Item Tags Display */
    .item-tags { display: flex; gap: 4px; margin-top: 6px; flex-wrap: wrap; }
    .item-tag { font-size: 10px; padding: 3px 8px; background: var(--bg4); border-radius: 8px; color: var(--text3); display: flex; align-items: center; gap: 4px; }
    .item-tag-icon { font-size: 10px; }

    .news-list { flex: 1; overflow-y: auto; padding: 16px 24px 120px; }
    .article { display: flex; gap: 16px; padding: 20px; background: var(--bg3); border-radius: 16px; margin-bottom: 12px; cursor: pointer; border: 1px solid var(--border2); transition: all 0.2s ease-out; }
    .article:hover { background: rgba(255,255,255,0.04); border-color: rgba(255,255,255,0.15); box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
    .article.unread { position: relative; }
    .article.unread::after { content: ''; position: absolute; top: 50%; right: 16px; transform: translateY(-50%); width: 8px; height: 8px; background: var(--orange); border-radius: 50%; }
    .article-icon { width: 48px; height: 48px; border-radius: 12px; background: var(--bg4); display: flex; align-items: center; justify-content: center; font-size: 22px; overflow: hidden; flex-shrink: 0; box-shadow: 0 2px 8px rgba(0,0,0,0.15); }
    .article-icon img { width: 100%; height: 100%; object-fit: cover; }
    .article-body { flex: 1; min-width: 0; }
    .article-meta { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; font-size: 13px; }
    .article-source { color: var(--blue); font-weight: 500; cursor: pointer; }
    .article-source:hover { color: var(--blue2); }
    .article-time { color: var(--text3); }
    .article-new { color: var(--orange); font-weight: 600; font-size: 10px; text-transform: uppercase; letter-spacing: 0.5px; }
    .article-title { font-size: 16px; font-weight: 600; line-height: 1.4; margin-bottom: 6px; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
    .article:not(.unread) .article-title { font-weight: 400; color: var(--text2); }
    .article-summary { font-size: 14px; color: var(--text2); line-height: 1.5; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
    .article-image { width: 100px; height: 70px; border-radius: 10px; object-fit: cover; flex-shrink: 0; }
    
    /* === PODCAST VIEW === */
    .podcast-view { display: none; height: 100%; }
    .podcast-view.active { display: flex; }

    /* Podcast Inbox Layout (similar to news) */
    .podcast-sidebar { width: 260px; background: var(--bg2); border-right: 1px solid var(--border2); display: flex; flex-direction: column; }
    .podcast-inbox-content { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
    .podcast-inbox-header { padding: 12px 24px; border-bottom: 1px solid var(--border2); display: flex; align-items: center; gap: 16px; }
    .podcast-inbox-header .inbox-title { font-size: 20px; font-weight: 600; letter-spacing: -0.02em; }
    .podcast-inbox-list { flex: 1; overflow-y: auto; padding: 16px 24px 120px; }

    /* Podcast Episode Item (inbox style) */
    .podcast-episode-item { display: flex; gap: 16px; padding: 20px; background: var(--bg3); border-radius: 16px; margin-bottom: 12px; cursor: pointer; border: 1px solid var(--border2); transition: all 0.2s ease-out; }
    .podcast-episode-item:hover { background: rgba(255,255,255,0.04); border-color: rgba(255,255,255,0.15); box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
    .podcast-episode-item.in-progress { position: relative; }
    .podcast-episode-item.in-progress::after { content: ''; position: absolute; top: 50%; right: 16px; transform: translateY(-50%); width: 8px; height: 8px; background: var(--blue); border-radius: 50%; }
    .podcast-episode-icon { width: 64px; height: 64px; border-radius: 12px; background: var(--bg4); display: flex; align-items: center; justify-content: center; font-size: 28px; overflow: hidden; flex-shrink: 0; box-shadow: 0 2px 8px rgba(0,0,0,0.15); }
    .podcast-episode-icon img { width: 100%; height: 100%; object-fit: cover; }
    .podcast-episode-body { flex: 1; min-width: 0; display: flex; flex-direction: column; justify-content: center; }
    .podcast-episode-meta { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; font-size: 13px; }
    .podcast-episode-show { color: var(--blue); font-weight: 500; cursor: pointer; }
    .podcast-episode-show:hover { color: var(--blue2); }
    .podcast-episode-time { color: var(--text3); }
    .podcast-episode-new { color: var(--orange); font-weight: 600; font-size: 10px; text-transform: uppercase; letter-spacing: 0.5px; }
    .podcast-episode-title { font-size: 16px; font-weight: 600; line-height: 1.4; margin-bottom: 6px; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
    .podcast-episode-item:not(.in-progress) .podcast-episode-title { font-weight: 400; color: var(--text2); }
    .podcast-episode-desc { font-size: 14px; color: var(--text2); line-height: 1.5; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; margin-bottom: 8px; }
    .podcast-episode-footer { display: flex; align-items: center; gap: 12px; }
    .podcast-episode-duration { font-size: 12px; color: var(--text3); display: flex; align-items: center; gap: 4px; }
    .podcast-episode-progress { flex: 1; max-width: 120px; height: 4px; background: var(--bg4); border-radius: 2px; overflow: hidden; }
    .podcast-episode-progress-fill { height: 100%; background: linear-gradient(90deg, var(--blue), var(--blue2)); border-radius: 2px; }
    .podcast-episode-play { width: 36px; height: 36px; border-radius: 50%; background: var(--blue); border: none; color: #fff; cursor: pointer; display: flex; align-items: center; justify-content: center; flex-shrink: 0; transition: all 0.15s; box-shadow: 0 2px 8px rgba(59,130,246,0.3); }
    .podcast-episode-play:hover { background: var(--blue2); transform: scale(1.05); }
    .podcast-episode-image { width: 100px; height: 70px; border-radius: 10px; object-fit: cover; flex-shrink: 0; }

    /* === SPOTIFY-STYLE PODCAST EPISODES === */
    .podcast-inbox-list {
      flex: 1;
      overflow-y: auto;
      padding: 0;
      background: var(--bg);
    }

    .spotify-ep {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      cursor: pointer;
      transition: background 0.15s;
      border-bottom: 1px solid var(--border);
      position: relative;
    }
    .spotify-ep:hover { background: rgba(255,255,255,0.05); }
    .spotify-ep:active { background: rgba(255,255,255,0.08); }
    .spotify-ep.now-playing { background: rgba(59,130,246,0.1); }
    .spotify-ep.played { opacity: 0.6; }
    .spotify-ep.played:hover { opacity: 0.8; }

    .spotify-ep-art {
      width: 56px;
      height: 56px;
      border-radius: 8px;
      background: var(--bg3);
      overflow: hidden;
      flex-shrink: 0;
      position: relative;
    }
    .spotify-ep-art .img-fallback {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      color: var(--text3);
    }
    .spotify-ep-art img {
      position: relative;
      z-index: 1;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    .spotify-ep-art img.eager-img {
      opacity: 0;
      transition: opacity 0.15s ease-out;
    }
    .spotify-ep-art img.eager-img.loaded {
      opacity: 1;
    }
    .spotify-ep-play-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.15s;
      border: none;
      cursor: pointer;
      color: #fff;
      font-size: 22px;
    }
    .spotify-ep:hover .spotify-ep-play-overlay,
    .spotify-ep.now-playing .spotify-ep-play-overlay { opacity: 1; }
    .spotify-ep.now-playing .spotify-ep-play-overlay {
      background: rgba(59,130,246,0.8);
      opacity: 1;
    }

    .spotify-ep-info {
      flex: 1;
      min-width: 0;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .spotify-ep-title {
      font-size: 15px;
      font-weight: 500;
      color: var(--text);
      line-height: 1.3;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    .spotify-ep.now-playing .spotify-ep-title { color: var(--blue); }
    .spotify-ep.played .spotify-ep-title { color: var(--text2); font-weight: 400; }

    .spotify-ep-meta {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
      color: var(--text3);
    }
    .spotify-ep-show { color: var(--text2); }
    .spotify-ep-dot { opacity: 0.5; }
    .spotify-ep-date { opacity: 0.8; }

    .spotify-ep-progress {
      width: 100%;
      height: 3px;
      background: var(--bg4);
      border-radius: 2px;
      overflow: hidden;
      margin-top: 4px;
    }
    .spotify-ep-progress-fill {
      height: 100%;
      background: var(--blue);
      border-radius: 2px;
    }

    .spotify-ep-duration {
      font-size: 12px;
      color: var(--text3);
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .spotify-ep-duration i { font-size: 14px; color: var(--blue); }

    /* === SKELETON LOADING === */
    @keyframes shimmer {
      0% { background-position: -200px 0; }
      100% { background-position: calc(200px + 100%) 0; }
    }

    .skeleton {
      background: linear-gradient(90deg, var(--bg3) 0%, var(--bg4) 50%, var(--bg3) 100%);
      background-size: 200px 100%;
      animation: shimmer 1.5s infinite;
      border-radius: 4px;
    }

    .skeleton-ep {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      border-bottom: 1px solid var(--border);
    }
    .skeleton-ep-art { width: 56px; height: 56px; border-radius: 8px; }
    .skeleton-ep-info { flex: 1; display: flex; flex-direction: column; gap: 8px; }
    .skeleton-ep-title { height: 16px; width: 70%; }
    .skeleton-ep-meta { height: 12px; width: 50%; }
    .skeleton-ep-duration { height: 12px; width: 60px; }

    /* === LOAD MORE BUTTON === */
    .load-more-container {
      padding: 16px;
      display: flex;
      justify-content: center;
    }
    .load-more-btn {
      background: var(--bg3);
      border: 1px solid var(--border2);
      color: var(--text);
      padding: 12px 32px;
      border-radius: 24px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      font-family: inherit;
    }
    .load-more-btn:hover { background: var(--bg4); border-color: var(--blue); }
    .load-more-btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .load-more-btn.loading { position: relative; color: transparent; }
    .load-more-btn.loading::after {
      content: '';
      position: absolute;
      width: 16px; height: 16px;
      top: 50%; left: 50%;
      margin: -8px 0 0 -8px;
      border: 2px solid var(--text3);
      border-top-color: var(--blue);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Lazy image fade-in - placeholder visible initially */
    .lazy-img {
      transition: opacity 0.3s ease;
    }
    .lazy-img.loaded { opacity: 1; }

    /* Search highlight in compact view */
    .spotify-ep mark.search-highlight {
      background: rgba(59, 130, 246, 0.3);
      color: var(--text);
      padding: 0 2px;
      border-radius: 2px;
    }

    /* Mobile-optimized podcast inbox */
    .podcast-inbox-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      background: var(--bg);
    }

    /* Mobile shows header - hidden on desktop */
    .mobile-shows-header {
      display: none;
    }

    /* === SPOTIFY-STYLE MINI PLAYER === */
    .player {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(180deg, var(--bg3) 0%, var(--bg2) 100%);
      border-top: 1px solid var(--border2);
      display: none;
      flex-direction: column;
      z-index: 100;
      transition: transform 0.3s ease, opacity 0.3s ease;
    }
    .player.active { display: flex; }
    .player.hidden { transform: translateY(100%); opacity: 0; pointer-events: none; }
    .player.mini { padding: 8px 12px; }

    .player-main {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px 8px;
    }

    .player-left {
      display: flex;
      align-items: center;
      gap: 12px;
      flex: 1;
      min-width: 0;
      cursor: pointer;
    }

    .player-art {
      width: 48px;
      height: 48px;
      border-radius: 6px;
      object-fit: cover;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      flex-shrink: 0;
    }

    .player-info {
      flex: 1;
      min-width: 0;
    }

    .player-title {
      font-size: 14px;
      font-weight: 600;
      color: var(--text);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      margin-bottom: 2px;
    }

    .player-show {
      font-size: 12px;
      color: var(--text3);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .player-center {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .player-skip {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: transparent;
      border: none;
      color: var(--text2);
      cursor: pointer;
      font-size: 12px;
      font-weight: 700;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
    }
    .player-skip:hover { color: var(--text); background: rgba(255,255,255,0.05); }

    .player-play {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: #fff;
      border: none;
      color: #000;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.1s;
      flex-shrink: 0;
    }
    .player-play:hover { transform: scale(1.05); }
    .player-play:active { transform: scale(0.95); }

    .player-right {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .player-btn {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: transparent;
      border: none;
      color: var(--text3);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      position: relative;
    }
    .player-btn:hover { color: var(--text); }
    .player-btn.active { color: var(--blue); }

    .player-progress {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 0 16px 12px;
    }

    .player-time {
      font-size: 11px;
      color: var(--text3);
      font-variant-numeric: tabular-nums;
      min-width: 36px;
    }
    .player-time.right { text-align: right; }

    .player-bar {
      flex: 1;
      height: 4px;
      background: rgba(255,255,255,0.1);
      border-radius: 2px;
      cursor: pointer;
      position: relative;
      overflow: hidden;
    }
    .player-bar:hover { height: 6px; margin: -1px 0; }

    .player-fill {
      height: 100%;
      background: var(--blue);
      border-radius: 2px;
      position: relative;
    }
    .player-bar:hover .player-fill { background: #1ed760; }

    /* Player hide toggle */
    .player-hide-btn {
      position: absolute;
      top: -20px;
      left: 50%;
      transform: translateX(-50%);
      width: 40px;
      height: 20px;
      background: var(--bg3);
      border: 1px solid var(--border2);
      border-bottom: none;
      border-radius: 8px 8px 0 0;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text3);
      font-size: 12px;
      z-index: 1;
    }
    .player-hide-btn:hover { color: var(--text); }

    /* === SPOTIFY-STYLE EXPANDED PLAYER === */
    .expanded {
      position: fixed;
      inset: 0;
      background: var(--bg);
      z-index: 200;
      display: none;
      flex-direction: column;
      overflow: hidden;
    }
    .expanded.active { display: flex; }

    .expanded-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 20px;
      padding-top: max(16px, env(safe-area-inset-top));
    }

    .expanded-close {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: transparent;
      border: none;
      color: var(--text);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .expanded-label {
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--text3);
    }

    .expanded-body {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
      padding-bottom: max(40px, env(safe-area-inset-bottom));
      gap: 24px;
    }

    .swipe-container {
      position: relative;
      width: min(320px, 80vw);
      aspect-ratio: 1;
    }

    .expanded-art {
      width: 100%;
      height: 100%;
      border-radius: 12px;
      object-fit: cover;
      box-shadow: 0 20px 60px rgba(0,0,0,0.4);
    }

    .swipe-indicator {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.7);
      border-radius: 12px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.15s;
    }
    .swipe-indicator.active { opacity: 1; }

    .expanded-info {
      text-align: center;
      max-width: 100%;
      padding: 0 20px;
    }

    .expanded-title {
      font-size: 20px;
      font-weight: 700;
      color: var(--text);
      line-height: 1.3;
      margin-bottom: 8px;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    .expanded-show {
      font-size: 14px;
      color: var(--text2);
    }

    .expanded-progress {
      width: 100%;
      max-width: 400px;
    }

    .expanded-bar {
      width: 100%;
      height: 4px;
      background: rgba(255,255,255,0.2);
      border-radius: 2px;
      cursor: pointer;
      overflow: hidden;
      margin-bottom: 8px;
    }
    .expanded-bar:active { height: 6px; margin-bottom: 6px; }

    .expanded-fill {
      height: 100%;
      background: #fff;
      border-radius: 2px;
    }

    .expanded-times {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: var(--text3);
      font-variant-numeric: tabular-nums;
    }

    .expanded-controls {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 24px;
    }

    .expanded-skip {
      width: 52px;
      height: 52px;
      border-radius: 50%;
      background: transparent;
      border: none;
      color: var(--text);
      cursor: pointer;
      font-size: 14px;
      font-weight: 700;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
    }
    .expanded-skip:hover { transform: scale(1.1); }
    .expanded-skip:active { transform: scale(0.95); }

    .expanded-play {
      width: 72px;
      height: 72px;
      border-radius: 50%;
      background: #fff;
      border: none;
      color: #000;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.1s;
    }
    .expanded-play:hover { transform: scale(1.05); }
    .expanded-play:active { transform: scale(0.95); }

    .expanded-extra {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 32px;
      margin-top: 16px;
    }

    .expanded-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      background: none;
      border: none;
      color: var(--text3);
      cursor: pointer;
      padding: 8px;
      transition: color 0.15s;
    }
    .expanded-btn:hover { color: var(--text); }
    .expanded-btn.active { color: var(--blue); }
    .expanded-btn i { font-size: 22px; }
    .expanded-btn span { font-size: 10px; font-weight: 600; text-transform: uppercase; }

    /* === ALL VIEW === */
    .all-view { display: none; height: 100%; flex-direction: column; }
    .all-view.active { display: flex; }
    .all-content { flex: 1; overflow-y: auto; padding: 24px 32px; padding-bottom: 140px; }
    .all-section { margin-bottom: 36px; }
    .all-section-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px; }
    .all-section-title { font-size: 20px; font-weight: 600; display: flex; align-items: center; gap: 10px; letter-spacing: -0.02em; }
    .all-feed-list { display: flex; flex-direction: column; gap: 12px; }
    .all-item { display: flex; gap: 16px; padding: 20px; background: var(--bg3); border-radius: 16px; cursor: pointer; border: 1px solid var(--border2); transition: all 0.2s ease-out; }
    .all-item:hover { background: rgba(255,255,255,0.04); border-color: rgba(255,255,255,0.15); box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
    .all-item-icon { width: 52px; height: 52px; border-radius: 12px; object-fit: cover; flex-shrink: 0; display: flex; align-items: center; justify-content: center; font-size: 26px; background: var(--bg4); box-shadow: 0 2px 8px rgba(0,0,0,0.2); }
    .all-item-icon img { width: 100%; height: 100%; object-fit: cover; border-radius: 12px; }
    .all-item-body { flex: 1; min-width: 0; display: flex; flex-direction: column; justify-content: center; }
    .all-item-meta { font-size: 13px; color: var(--blue); font-weight: 500; margin-bottom: 4px; display: flex; align-items: center; gap: 8px; }
    .all-item-type { background: var(--bg4); color: var(--text2); padding: 3px 8px; border-radius: 6px; font-size: 10px; text-transform: uppercase; font-weight: 600; letter-spacing: 0.5px; }
    .all-item-title { font-size: 15px; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .all-item-summary { font-size: 13px; color: var(--text3); margin-top: 6px; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; line-height: 1.5; }
    .all-item-time { font-size: 12px; color: var(--text3); }
    .all-item-image { width: 100px; height: 70px; border-radius: 12px; object-fit: cover; flex-shrink: 0; box-shadow: 0 2px 8px rgba(0,0,0,0.2); }

    /* All Content View Modes */
    .all-cards { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 20px; }
    .all-card { background: var(--bg3); border-radius: 16px; overflow: hidden; cursor: pointer; border: 1px solid var(--border2); transition: all 0.2s ease-out; display: flex; flex-direction: column; }
    .all-card:hover { background: rgba(255,255,255,0.04); border-color: rgba(255,255,255,0.15); transform: translateY(-2px); box-shadow: 0 8px 24px rgba(0,0,0,0.2); }
    .all-card-image { width: 100%; height: 180px; object-fit: cover; background: var(--bg4); display: flex; align-items: center; justify-content: center; font-size: 52px; }
    .all-card-image img { width: 100%; height: 100%; object-fit: cover; }
    .all-card-body { padding: 18px; flex: 1; display: flex; flex-direction: column; }
    .all-card-meta { display: flex; align-items: center; gap: 8px; margin-bottom: 10px; font-size: 13px; }
    .all-card-type { background: var(--bg4); color: var(--text2); padding: 3px 8px; border-radius: 6px; font-size: 10px; text-transform: uppercase; font-weight: 600; }
    .all-card-source { color: var(--blue); font-weight: 500; }
    .all-card-time { color: var(--text3); }
    .all-card-title { font-size: 16px; font-weight: 600; line-height: 1.4; margin-bottom: 10px; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
    .all-card-summary { font-size: 14px; color: var(--text2); line-height: 1.5; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden; flex: 1; }

    .all-masonry { column-count: 3; column-gap: 20px; }
    .all-masonry-item { break-inside: avoid; margin-bottom: 20px; background: var(--bg3); border-radius: 16px; overflow: hidden; cursor: pointer; border: 1px solid var(--border2); transition: all 0.2s ease-out; }
    .all-masonry-item:hover { background: rgba(255,255,255,0.04); border-color: rgba(255,255,255,0.15); box-shadow: 0 4px 16px rgba(0,0,0,0.2); }
    .all-masonry-image { width: 100%; object-fit: cover; }
    .all-masonry-body { padding: 18px; }
    .all-masonry-meta { display: flex; align-items: center; gap: 8px; margin-bottom: 10px; font-size: 13px; }
    .all-masonry-type { background: var(--bg4); color: var(--text2); padding: 3px 8px; border-radius: 6px; font-size: 10px; text-transform: uppercase; font-weight: 600; }
    .all-masonry-source { color: var(--blue); font-weight: 500; }
    .all-masonry-time { color: var(--text3); }
    .all-masonry-title { font-size: 16px; font-weight: 600; line-height: 1.4; margin-bottom: 10px; }
    .all-masonry-summary { font-size: 14px; color: var(--text2); line-height: 1.5; }

    .all-table { width: 100%; border-collapse: collapse; }
    .all-table th { text-align: left; padding: 14px 16px; font-size: 12px; font-weight: 600; color: var(--text3); text-transform: uppercase; letter-spacing: 0.5px; border-bottom: 1px solid var(--border2); }
    .all-table td { padding: 14px 16px; border-bottom: 1px solid var(--border); vertical-align: middle; }
    .all-table tr { cursor: pointer; transition: all 0.15s; }
    .all-table tbody tr:hover { background: rgba(255,255,255,0.03); }
    .all-table .table-title { font-weight: 500; max-width: 400px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .all-table .table-type { font-size: 10px; text-transform: uppercase; padding: 3px 8px; border-radius: 6px; background: var(--bg4); color: var(--text2); font-weight: 600; }
    .all-table .table-source { color: var(--blue); font-weight: 500; font-size: 13px; }
    .all-table .table-time { color: var(--text3); font-size: 13px; white-space: nowrap; }

    @media (max-width: 1024px) {
      .all-masonry { column-count: 2; }
    }
    @media (max-width: 640px) {
      .all-masonry { column-count: 1; }
      .all-cards { grid-template-columns: 1fr; }
    }

    /* === FOR LATER VIEW === */
    .for-later-view { display: none; height: 100%; flex-direction: column; }
    .for-later-view.active { display: flex; }
    .for-later-content { flex: 1; overflow-y: auto; padding: 24px 32px; padding-bottom: 140px; }
    .for-later-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 24px; padding-bottom: 16px; border-bottom: 1px solid var(--border2); }
    .for-later-title { font-size: 24px; font-weight: 600; display: flex; align-items: center; gap: 12px; letter-spacing: -0.02em; }
    .for-later-title i { font-size: 28px; color: var(--blue); }
    .for-later-list { display: flex; flex-direction: column; gap: 12px; }
    .for-later-item { display: flex; gap: 16px; padding: 20px; background: var(--bg3); border-radius: 16px; border: 1px solid var(--border2); transition: all 0.2s ease-out; position: relative; }
    .for-later-item:hover { background: rgba(255,255,255,0.04); border-color: rgba(255,255,255,0.15); box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
    .for-later-item.completed { opacity: 0.6; }
    .for-later-item.completed .for-later-item-title { text-decoration: line-through; color: var(--text3); }
    .for-later-checkbox { width: 24px; height: 24px; border: 2px solid var(--border2); border-radius: 6px; cursor: pointer; flex-shrink: 0; display: flex; align-items: center; justify-content: center; transition: all 0.15s; background: var(--bg4); }
    .for-later-checkbox:hover { border-color: var(--blue); background: rgba(59,130,246,0.1); }
    .for-later-checkbox.checked { background: var(--blue); border-color: var(--blue); }
    .for-later-checkbox.checked::after { content: 'âœ“'; color: #fff; font-size: 14px; font-weight: 700; }
    .for-later-item-icon { width: 48px; height: 48px; border-radius: 12px; background: var(--bg4); display: flex; align-items: center; justify-content: center; font-size: 22px; overflow: hidden; flex-shrink: 0; box-shadow: 0 2px 8px rgba(0,0,0,0.15); }
    .for-later-item-icon img { width: 100%; height: 100%; object-fit: cover; }
    .for-later-item-body { flex: 1; min-width: 0; display: flex; flex-direction: column; justify-content: center; cursor: pointer; }
    .for-later-item-meta { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; font-size: 13px; }
    .for-later-item-type { background: var(--bg4); color: var(--text2); padding: 3px 8px; border-radius: 6px; font-size: 10px; text-transform: uppercase; font-weight: 600; letter-spacing: 0.5px; }
    .for-later-item-source { color: var(--blue); font-weight: 500; }
    .for-later-item-time { color: var(--text3); }
    .for-later-item-title { font-size: 16px; font-weight: 600; line-height: 1.4; margin-bottom: 6px; }
    .for-later-item-desc { font-size: 14px; color: var(--text2); line-height: 1.5; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
    .for-later-item-remove { position: absolute; top: 16px; right: 16px; width: 28px; height: 28px; border-radius: 50%; background: rgba(255,255,255,0.05); border: none; color: var(--text3); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.15s; opacity: 0; }
    .for-later-item:hover .for-later-item-remove { opacity: 1; }
    .for-later-item-remove:hover { background: rgba(255,107,53,0.2); color: var(--orange); }
    .for-later-empty { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 80px 32px; text-align: center; color: var(--text3); }
    .for-later-empty-icon { font-size: 64px; margin-bottom: 20px; color: var(--blue); opacity: 0.6; }
    .for-later-empty-title { font-size: 20px; font-weight: 600; color: var(--text); margin-bottom: 12px; }
    .for-later-empty-desc { font-size: 14px; color: var(--text2); line-height: 1.6; max-width: 280px; }
    .for-later-empty-hint { margin-top: 24px; padding: 16px 20px; background: var(--bg3); border-radius: 12px; border: 1px solid var(--border2); display: flex; align-items: center; gap: 12px; }
    .for-later-empty-hint-icon { font-size: 20px; color: var(--blue); }
    .for-later-empty-hint-text { font-size: 13px; color: var(--text2); text-align: left; }
    .for-later-browse-btn { margin-top: 24px; background: var(--blue); border: none; color: #fff; padding: 12px 24px; border-radius: 24px; font-size: 14px; font-weight: 500; cursor: pointer; font-family: inherit; transition: all 0.15s; box-shadow: 0 4px 12px rgba(59,130,246,0.3); }
    .for-later-browse-btn:hover { background: var(--blue2); transform: scale(1.02); }
    .for-later-browse-btn:active { transform: scale(0.98); }
    .add-to-later-btn { position: absolute; top: 12px; right: 12px; width: 32px; height: 32px; border-radius: 50%; background: rgba(59,130,246,0.2); border: none; color: var(--blue); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.15s; opacity: 0; font-size: 16px; z-index: 1; }
    .article:hover .add-to-later-btn, .spotify-ep:hover .add-to-later-btn, .feed-post:hover .add-to-later-btn { opacity: 1; }
    .add-to-later-btn:hover { background: var(--blue); color: #fff; transform: scale(1.1); }
    .add-to-later-btn.added { background: var(--blue); color: #fff; opacity: 1; }


    /* Social Media Feed Styles */
    .feed-nav { display: flex; background: var(--bg2); border-bottom: 1px solid var(--border2); padding: 0 24px; gap: 4px; }
    .feed-nav-btn { padding: 10px 20px; background: none; border: none; border-bottom: 3px solid transparent; color: var(--text2); font-size: 13px; font-weight: 600; cursor: pointer; font-family: inherit; transition: all 0.2s; display: flex; align-items: center; gap: 8px; }
    .feed-nav-btn:hover { color: var(--text); background: rgba(255,255,255,0.03); }
    .feed-nav-btn.active { color: var(--text); border-bottom-color: var(--blue); }
    .feed-nav-btn .feed-nav-icon { font-size: 16px; }
    .feed-nav-btn .feed-nav-count { font-size: 11px; background: var(--bg4); padding: 2px 8px; border-radius: 10px; color: var(--text3); }
    .feed-nav-btn.active .feed-nav-count { background: rgba(59,130,246,0.2); color: var(--blue); }

    /* Hide mobile view toggle on desktop */
    .mobile-view-toggle { display: none; }

    .feed-container { flex: 1; overflow-y: auto; display: flex; justify-content: center; background: var(--bg); }
    .feed-scroll { max-width: 600px; width: 100%; padding: 0; padding-bottom: 140px; }

    /* Social Media Post Card */
    .feed-post { background: var(--bg2); border-bottom: 1px solid var(--border); cursor: pointer; transition: background 0.15s; }
    .feed-post:hover { background: var(--bg3); }
    .feed-post-inner { padding: 16px 20px; position: relative; }
    .feed-post-header { display: flex; align-items: flex-start; gap: 12px; margin-bottom: 10px; }
    .feed-post-avatar { width: 48px; height: 48px; border-radius: 50%; background: var(--bg4); display: flex; align-items: center; justify-content: center; font-size: 22px; overflow: hidden; flex-shrink: 0; }
    .feed-post-avatar img { width: 100%; height: 100%; object-fit: cover; }
    .feed-post-meta { flex: 1; min-width: 0; }
    .feed-post-source { font-weight: 600; font-size: 15px; color: var(--text); display: flex; align-items: center; gap: 6px; }
    .feed-post-source-name { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .feed-post-type-badge { font-size: 10px; padding: 2px 8px; border-radius: 4px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; }
    .feed-post-type-badge.podcast { background: rgba(139, 92, 246, 0.2); color: #a78bfa; }
    .feed-post-type-badge.news { background: rgba(59, 130, 246, 0.2); color: #60a5fa; }
    .feed-post-handle { font-size: 13px; color: var(--text3); display: flex; align-items: center; gap: 4px; margin-top: 2px; }
    .feed-post-handle span { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .feed-post-dot { color: var(--text3); }
    .feed-post-time { white-space: nowrap; }
    .feed-post-body { padding-left: 60px; }
    .feed-post-title { font-size: 16px; font-weight: 600; line-height: 1.4; margin-bottom: 8px; color: var(--text); display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden; }
    .feed-post-summary { font-size: 15px; color: var(--text2); line-height: 1.5; margin-bottom: 12px; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden; }
    .feed-post-media { border-radius: 16px; overflow: hidden; border: 1px solid var(--border); margin-bottom: 12px; }
    .feed-post-media img { width: 100%; max-height: 300px; object-fit: cover; display: block; }
    .feed-post-actions { display: flex; align-items: center; gap: 24px; padding-top: 8px; }
    .feed-post-action { display: flex; align-items: center; gap: 6px; color: var(--text3); font-size: 13px; transition: color 0.15s; padding: 6px 0; }
    .feed-post-action:hover { color: var(--blue); }
    .feed-post-action svg { width: 18px; height: 18px; }
    .feed-post-tags { display: flex; gap: 6px; flex-wrap: wrap; margin-top: 8px; }
    .feed-post-tag { font-size: 13px; color: var(--blue); }
    .feed-post-tag:hover { text-decoration: underline; }

    /* Podcast-specific post elements */
    .feed-post-duration { display: flex; align-items: center; gap: 6px; font-size: 13px; color: var(--text3); margin-top: 8px; }
    .feed-post-duration svg { width: 16px; height: 16px; }
    .feed-post-play { display: inline-flex; align-items: center; gap: 8px; padding: 10px 20px; background: var(--blue); border-radius: 24px; color: #fff; font-size: 14px; font-weight: 600; margin-top: 12px; transition: all 0.15s; }
    .feed-post-play:hover { background: var(--blue2); transform: scale(1.02); }
    .feed-post-play svg { width: 16px; height: 16px; }

    /* Unread indicator */
    .feed-post.unread .feed-post-source::after { content: ''; width: 8px; height: 8px; background: var(--orange); border-radius: 50%; flex-shrink: 0; }

    /* Empty feed state */
    .feed-empty { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 80px 32px; text-align: center; color: var(--text3); }
    .feed-empty-icon { font-size: 56px; margin-bottom: 16px; }
    .feed-empty-title { font-size: 18px; font-weight: 600; color: var(--text); margin-bottom: 8px; }
    .feed-empty-desc { font-size: 14px; color: var(--text3); }

    @media (max-width: 768px) {
      .feed-nav { padding: 0 12px; overflow-x: auto; }
      .feed-nav-btn { padding: 12px 16px; font-size: 13px; }
      .feed-nav-btn span:not(.feed-nav-icon):not(.feed-nav-count) { display: none; }
      .feed-scroll { padding: 0; }
      .feed-post-inner { padding: 14px 16px; }
      .feed-post-avatar { width: 40px; height: 40px; font-size: 18px; }
      .feed-post-body { padding-left: 52px; }
      .feed-post-title { font-size: 15px; }
      .feed-post-summary { font-size: 14px; }
    }

    .podcast-nav { display: flex; background: var(--bg2); border-bottom: 1px solid var(--border2); padding: 0 24px; }
    .nav-btn { padding: 12px 20px; background: none; border: none; border-bottom: 2px solid transparent; color: var(--text2); font-size: 13px; font-weight: 500; cursor: pointer; font-family: inherit; transition: all 0.15s; }
    .nav-btn:hover { color: var(--text); }
    .nav-btn.active { color: var(--blue); border-bottom-color: var(--blue); }

    .podcast-content { flex: 1; overflow-y: auto; padding: 24px 32px; padding-bottom: 140px; }

    .section { margin-bottom: 36px; }
    .section-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px; }
    .section-title { font-size: 20px; font-weight: 600; letter-spacing: -0.02em; }

    .shows-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 160px)); gap: 24px; }
    .show-card { cursor: pointer; transition: all 0.2s ease-out; max-width: 160px; }
    .show-card:hover { transform: translateY(-4px); }
    .show-art { width: 100%; aspect-ratio: 1; border-radius: 16px; object-fit: cover; margin-bottom: 12px; box-shadow: 0 8px 20px rgba(0,0,0,0.35); }
    .show-name { font-size: 14px; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; line-height: 1.4; }
    .show-author { font-size: 12px; color: var(--text3); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

    .episode-list { display: flex; flex-direction: column; gap: 12px; }
    .episode { display: flex; gap: 16px; padding: 16px; background: var(--bg3); border-radius: 16px; cursor: pointer; border: 1px solid var(--border2); transition: all 0.2s ease-out; }
    .episode:hover { background: rgba(255,255,255,0.04); border-color: rgba(255,255,255,0.15); box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
    .episode-art-wrap { width: 64px; height: 64px; border-radius: 12px; flex-shrink: 0; box-shadow: 0 2px 8px rgba(0,0,0,0.2); position: relative; background: var(--bg3); overflow: hidden; }
    .episode-art-wrap .img-fallback { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; font-size: 24px; color: var(--text3); }
    .episode-art { width: 100%; height: 100%; object-fit: cover; position: relative; z-index: 1; }
    .episode-art.eager-img { opacity: 0; transition: opacity 0.15s ease-out; }
    .episode-art.eager-img.loaded { opacity: 1; }
    .episode-body { flex: 1; min-width: 0; display: flex; flex-direction: column; justify-content: center; }
    .episode-show { font-size: 13px; color: var(--blue); font-weight: 500; margin-bottom: 4px; cursor: pointer; }
    .episode-show:hover { color: var(--blue2); }
    .episode-title { font-size: 15px; font-weight: 600; margin-bottom: 8px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .episode-footer { display: flex; align-items: center; gap: 12px; }
    .ep-play { width: 32px; height: 32px; border-radius: 50%; background: var(--blue); border: none; color: #fff; cursor: pointer; display: flex; align-items: center; justify-content: center; flex-shrink: 0; transition: all 0.15s; box-shadow: 0 2px 8px rgba(59,130,246,0.3); }
    .ep-play:hover { background: var(--blue2); transform: scale(1.05); }
    .ep-progress { flex: 1; display: flex; align-items: center; gap: 10px; }
    .ep-bar { flex: 1; height: 4px; background: var(--bg4); border-radius: 2px; overflow: hidden; }
    .ep-fill { height: 100%; background: linear-gradient(90deg, var(--blue), var(--blue2)); border-radius: 2px; }
    .ep-time { font-size: 12px; color: var(--text3); white-space: nowrap; font-family: -apple-system, system-ui, monospace; }
    .ep-dl { background: none; border: none; color: var(--text3); cursor: pointer; padding: 6px; min-width: 28px; display: flex; align-items: center; justify-content: center; border-radius: 50%; transition: all 0.15s; }
    .ep-dl:hover { color: var(--text); background: rgba(255,255,255,0.05); }
    .ep-dl.active { color: var(--blue); }
    .ep-dl.downloading { color: var(--blue); cursor: wait; animation: pulse 1.5s ease-in-out infinite; }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    
    /* Show Page, Source Page & Episode Page */
    .show-page, .source-page, .episode-page { display: none; overflow-y: auto; height: 100%; }
    .show-page.active, .source-page.active, .episode-page.active { display: block; flex: 1; }
    .show-hero, .source-hero { padding: 32px; background: linear-gradient(180deg, rgba(59,130,246,0.15) 0%, var(--bg) 100%); display: flex; gap: 28px; align-items: flex-end; }
    .show-hero-art, .source-hero-art { width: 200px; height: 200px; border-radius: 16px; object-fit: cover; box-shadow: 0 12px 32px rgba(0,0,0,0.5); }
    .show-hero-info, .source-hero-info { flex: 1; }
    .show-hero-type, .source-hero-type { font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 1px; color: var(--blue); margin-bottom: 8px; }
    .show-hero-title, .source-hero-title { font-size: 36px; font-weight: 700; line-height: 1.1; margin-bottom: 12px; letter-spacing: -0.02em; }
    .show-hero-author, .source-hero-author { font-size: 15px; color: var(--text2); }
    .show-actions, .source-actions { padding: 20px 32px; display: flex; gap: 16px; align-items: center; }
    .show-play { width: 52px; height: 52px; border-radius: 50%; background: var(--blue); border: none; color: #fff; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s; box-shadow: 0 4px 16px rgba(59,130,246,0.4); flex-shrink: 0; }
    .show-play:hover { transform: scale(1.05); background: var(--blue2); }
    .show-episodes, .source-articles { padding: 0 32px 140px; }
    .show-episodes-title, .source-articles-title { font-size: 20px; font-weight: 600; margin-bottom: 20px; letter-spacing: -0.02em; }

    /* Episode Page */
    .episode-hero { padding: 32px; background: linear-gradient(180deg, rgba(59,130,246,0.15) 0%, var(--bg) 100%); display: flex; gap: 32px; align-items: flex-start; }
    .episode-hero-art { width: 200px; height: 200px; border-radius: 16px; object-fit: cover; box-shadow: 0 12px 32px rgba(0,0,0,0.5); flex-shrink: 0; }
    .episode-hero-info { flex: 1; padding-top: 8px; }
    .episode-hero-show { font-size: 13px; font-weight: 500; color: var(--blue); margin-bottom: 8px; cursor: pointer; display: inline-flex; align-items: center; gap: 6px; text-transform: uppercase; letter-spacing: 0.05em; opacity: 0.9; }
    .episode-hero-show:hover { text-decoration: underline; }
    .episode-hero-title { font-size: 28px; font-weight: 700; line-height: 1.3; margin-bottom: 16px; letter-spacing: -0.02em; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden; }
    .episode-hero-meta { display: flex; flex-wrap: wrap; gap: 16px; font-size: 14px; color: var(--text2); }
    .episode-hero-meta span { display: flex; align-items: center; gap: 6px; }
    .episode-hero-meta svg { width: 16px; height: 16px; opacity: 0.7; }
    .episode-actions { padding: 20px 32px; display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    .episode-play-btn { background: var(--blue); border: none; color: #fff; padding: 14px 28px; border-radius: 50px; font-size: 15px; font-weight: 600; cursor: pointer; display: flex; align-items: center; gap: 10px; transition: all 0.2s; box-shadow: 0 4px 16px rgba(59,130,246,0.4); }
    .episode-play-btn:hover { transform: scale(1.02); background: var(--blue2); }
    .episode-play-btn svg { width: 20px; height: 20px; }
    .episode-action-btn { background: rgba(255,255,255,0.05); border: 1px solid var(--border2); color: var(--text2); padding: 12px 20px; border-radius: 12px; font-size: 14px; font-weight: 500; cursor: pointer; display: flex; align-items: center; gap: 8px; transition: all 0.15s; font-family: inherit; }
    .episode-action-btn:hover { background: rgba(255,255,255,0.08); color: var(--text); border-color: rgba(255,255,255,0.15); }
    .episode-action-btn svg { width: 18px; height: 18px; }
    .episode-action-btn.active { background: rgba(59,130,246,0.15); border-color: var(--blue); color: var(--blue); }
    .episode-progress-section { padding: 0 32px 20px; }
    .episode-progress-bar { height: 6px; background: var(--bg4); border-radius: 3px; overflow: hidden; margin-bottom: 8px; }
    .episode-progress-fill { height: 100%; background: var(--blue); border-radius: 3px; transition: width 0.3s; }
    .episode-progress-text { font-size: 13px; color: var(--text2); display: flex; justify-content: space-between; }
    .episode-description { padding: 0 32px 32px; }
    .episode-description-title { font-size: 18px; font-weight: 600; margin-bottom: 16px; }
    .episode-description-content { font-size: 15px; line-height: 1.7; color: var(--text2); }
    .episode-description-content a { color: var(--blue); text-decoration: none; }
    .episode-description-content a:hover { text-decoration: underline; }
    .episode-description-content p { margin: 0 0 1em; }
    .episode-description-content p:last-child { margin-bottom: 0; }
    .episode-description-content ul, .episode-description-content ol { margin: 0 0 1em; padding-left: 1.5em; }
    .episode-description-content li { margin-bottom: 0.5em; }
    .episode-description-content h1, .episode-description-content h2, .episode-description-content h3, .episode-description-content h4 { color: var(--text); margin: 1.5em 0 0.5em; font-weight: 600; }
    .episode-description-content h1 { font-size: 1.4em; }
    .episode-description-content h2 { font-size: 1.25em; }
    .episode-description-content h3 { font-size: 1.1em; }
    .episode-description-content h4 { font-size: 1em; }
    .episode-description-content blockquote { margin: 1em 0; padding-left: 1em; border-left: 3px solid var(--border2); color: var(--text2); font-style: italic; }
    .episode-description-content strong, .episode-description-content b { font-weight: 600; color: var(--text); }
    .episode-description-content em, .episode-description-content i { font-style: italic; }
    .episode-description-content code { background: var(--bg3); padding: 0.2em 0.4em; border-radius: 4px; font-family: monospace; font-size: 0.9em; }
    .episode-description-content pre { background: var(--bg3); padding: 1em; border-radius: 8px; overflow-x: auto; margin: 1em 0; }
    .episode-description-content hr { border: none; border-top: 1px solid var(--border2); margin: 1.5em 0; }
    .episode-description-content img { max-width: 100%; height: auto; border-radius: 8px; margin: 1em 0; }
    .episode-bookmarks { padding: 0 32px 140px; }
    .episode-bookmarks-title { font-size: 18px; font-weight: 600; margin-bottom: 16px; display: flex; align-items: center; gap: 8px; }
    .episode-bookmarks-list { display: flex; flex-direction: column; gap: 12px; }
    .episode-bookmark-item { background: var(--bg3); border: 1px solid var(--border2); border-radius: 12px; padding: 16px; display: flex; align-items: center; gap: 16px; cursor: pointer; transition: all 0.15s; }
    .episode-bookmark-item:hover { background: rgba(255,255,255,0.04); border-color: rgba(255,255,255,0.15); }
    .episode-bookmark-time { font-size: 14px; font-weight: 600; color: var(--blue); white-space: nowrap; }
    .episode-bookmark-note { flex: 1; font-size: 14px; color: var(--text2); }
    .episode-tags { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 16px; }
    .episode-tag { background: rgba(255,255,255,0.05); border: 1px solid var(--border2); color: var(--text2); padding: 6px 12px; border-radius: 20px; font-size: 12px; font-weight: 500; }

    /* Back Button */
    .back-btn { background: rgba(255,255,255,0.05); border: 1px solid var(--border2); color: var(--text2); cursor: pointer; padding: 10px 16px; border-radius: 12px; display: flex; align-items: center; gap: 8px; font-size: 14px; font-weight: 500; font-family: inherit; transition: all 0.15s; }
    .back-btn:hover { background: rgba(255,255,255,0.08); color: var(--text); border-color: rgba(255,255,255,0.15); }

    /* View Options */
    .view-options { display: flex; gap: 6px; margin-left: auto; }
    .view-btn { background: var(--bg4); border: 1px solid var(--border2); color: var(--text2); cursor: pointer; padding: 10px 14px; border-radius: 10px; font-size: 12px; font-weight: 500; font-family: inherit; transition: all 0.15s; display: flex; align-items: center; gap: 6px; }
    .view-btn:hover { background: rgba(255,255,255,0.08); color: var(--text); }
    .view-btn.active { background: var(--blue); border-color: var(--blue); color: #fff; box-shadow: 0 2px 8px rgba(59,130,246,0.3); }

    /* Remove Feed Button */
    .remove-feed-btn { background: transparent; border: 1px solid var(--border2); color: var(--text2); cursor: pointer; padding: 10px 14px; border-radius: 10px; font-size: 12px; font-weight: 500; font-family: inherit; transition: all 0.15s; display: flex; align-items: center; gap: 6px; margin-left: auto; }
    .remove-feed-btn:hover { background: rgba(239,68,68,0.1); border-color: #ef4444; color: #ef4444; }
    .remove-feed-btn svg { width: 16px; height: 16px; }

    /* Edit Feed Button */
    .edit-feed-btn { background: transparent; border: 1px solid var(--border2); color: var(--text2); cursor: pointer; padding: 10px 14px; border-radius: 10px; font-size: 12px; font-weight: 500; font-family: inherit; transition: all 0.15s; display: flex; align-items: center; gap: 6px; }
    .edit-feed-btn:hover { background: rgba(59,130,246,0.1); border-color: #3b82f6; color: #3b82f6; }
    .edit-feed-btn svg { width: 16px; height: 16px; }

    /* Cards View */
    .articles-cards { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 20px; }
    .article-card { background: var(--bg3); border-radius: 16px; overflow: hidden; cursor: pointer; border: 1px solid var(--border2); transition: all 0.2s ease-out; display: flex; flex-direction: column; }
    .article-card:hover { background: rgba(255,255,255,0.04); border-color: rgba(255,255,255,0.15); transform: translateY(-2px); box-shadow: 0 8px 24px rgba(0,0,0,0.2); }
    .article-card.unread { position: relative; }
    .article-card.unread::after { content: ''; position: absolute; top: 12px; right: 12px; width: 8px; height: 8px; background: var(--orange); border-radius: 50%; }
    .article-card-image { width: 100%; height: 180px; object-fit: cover; background: var(--bg4); }
    .article-card-body { padding: 18px; flex: 1; display: flex; flex-direction: column; }
    .article-card-meta { display: flex; align-items: center; gap: 8px; margin-bottom: 10px; font-size: 13px; }
    .article-card-source { color: var(--blue); font-weight: 500; }
    .article-card-time { color: var(--text3); }
    .article-card-title { font-size: 16px; font-weight: 600; line-height: 1.4; margin-bottom: 10px; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
    .article-card:not(.unread) .article-card-title { font-weight: 400; color: var(--text2); }
    .article-card-summary { font-size: 14px; color: var(--text2); line-height: 1.5; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden; flex: 1; }

    /* Masonry View */
    .articles-masonry { column-count: 3; column-gap: 20px; }
    .article-masonry { break-inside: avoid; margin-bottom: 20px; background: var(--bg3); border-radius: 16px; overflow: hidden; cursor: pointer; border: 1px solid var(--border2); transition: all 0.2s ease-out; }
    .article-masonry:hover { background: rgba(255,255,255,0.04); border-color: rgba(255,255,255,0.15); box-shadow: 0 4px 16px rgba(0,0,0,0.2); }
    .article-masonry.unread { position: relative; }
    .article-masonry.unread::after { content: ''; position: absolute; top: 12px; right: 12px; width: 8px; height: 8px; background: var(--orange); border-radius: 50%; }
    .article-masonry-image { width: 100%; object-fit: cover; }
    .article-masonry-body { padding: 18px; }
    .article-masonry-meta { display: flex; align-items: center; gap: 8px; margin-bottom: 10px; font-size: 13px; }
    .article-masonry-source { color: var(--blue); font-weight: 500; }
    .article-masonry-time { color: var(--text3); }
    .article-masonry-title { font-size: 16px; font-weight: 600; line-height: 1.4; margin-bottom: 10px; }
    .article-masonry:not(.unread) .article-masonry-title { font-weight: 400; color: var(--text2); }
    .article-masonry-summary { font-size: 14px; color: var(--text2); line-height: 1.5; }

    /* Table View */
    .articles-table { width: 100%; border-collapse: collapse; }
    .articles-table th { text-align: left; padding: 14px 16px; font-size: 12px; font-weight: 600; color: var(--text3); text-transform: uppercase; letter-spacing: 0.5px; border-bottom: 1px solid var(--border2); }
    .articles-table td { padding: 14px 16px; border-bottom: 1px solid var(--border); vertical-align: middle; }
    .articles-table tr { cursor: pointer; transition: all 0.15s; }
    .articles-table tbody tr:hover { background: rgba(255,255,255,0.03); }
    .articles-table .table-title { font-weight: 500; max-width: 400px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .articles-table .table-source { color: var(--blue); font-weight: 500; font-size: 13px; }
    .articles-table .table-time { color: var(--text3); font-size: 13px; white-space: nowrap; }
    .articles-table .table-new { color: var(--orange); font-size: 10px; font-weight: 600; text-transform: uppercase; }
    .articles-table tr.unread .table-title { color: var(--text); font-weight: 600; }
    .articles-table tr:not(.unread) .table-title { color: var(--text2); font-weight: 400; }

    /* Episode Views */
    .episodes-cards { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 20px; }
    .episode-card { background: var(--bg3); border-radius: 16px; overflow: hidden; cursor: pointer; border: 1px solid var(--border2); transition: all 0.2s ease-out; }
    .episode-card:hover { background: rgba(255,255,255,0.04); border-color: rgba(255,255,255,0.15); transform: translateY(-2px); box-shadow: 0 8px 24px rgba(0,0,0,0.2); }
    .episode-card-art-wrap { width: 100%; aspect-ratio: 1; position: relative; background: var(--bg3); overflow: hidden; }
    .episode-card-art-wrap .img-fallback { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; font-size: 48px; color: var(--text3); }
    .episode-card-art { width: 100%; height: 100%; object-fit: cover; position: relative; z-index: 1; }
    .episode-card-art.eager-img { opacity: 0; transition: opacity 0.15s ease-out; }
    .episode-card-art.eager-img.loaded { opacity: 1; }
    .episode-card-body { padding: 18px; }
    .episode-card-title { font-size: 15px; font-weight: 600; margin-bottom: 8px; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
    .episode-card-meta { display: flex; align-items: center; gap: 10px; font-size: 13px; color: var(--text3); }

    .episodes-masonry { column-count: 3; column-gap: 20px; }
    .episode-masonry { break-inside: avoid; margin-bottom: 20px; background: var(--bg3); border-radius: 16px; overflow: hidden; cursor: pointer; border: 1px solid var(--border2); transition: all 0.2s ease-out; }
    .episode-masonry:hover { background: rgba(255,255,255,0.04); border-color: rgba(255,255,255,0.15); box-shadow: 0 4px 16px rgba(0,0,0,0.2); }
    .episode-masonry-art-wrap { width: 100%; position: relative; background: var(--bg3); min-height: 150px; }
    .episode-masonry-art-wrap .img-fallback { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; font-size: 48px; color: var(--text3); }
    .episode-masonry-art { width: 100%; object-fit: cover; position: relative; z-index: 1; }
    .episode-masonry-art.eager-img { opacity: 0; transition: opacity 0.15s ease-out; }
    .episode-masonry-art.eager-img.loaded { opacity: 1; }
    .episode-masonry-body { padding: 18px; }
    .episode-masonry-title { font-size: 15px; font-weight: 600; margin-bottom: 8px; }
    .episode-masonry-desc { font-size: 13px; color: var(--text2); line-height: 1.5; margin-bottom: 10px; }
    .episode-masonry-meta { font-size: 12px; color: var(--text3); }

    .episodes-table { width: 100%; border-collapse: collapse; }
    .episodes-table th { text-align: left; padding: 14px 16px; font-size: 12px; font-weight: 600; color: var(--text3); text-transform: uppercase; letter-spacing: 0.5px; border-bottom: 1px solid var(--border2); }
    .episodes-table td { padding: 14px 16px; border-bottom: 1px solid var(--border); vertical-align: middle; }
    .episodes-table tr { cursor: pointer; transition: all 0.15s; }
    .episodes-table tbody tr:hover { background: rgba(255,255,255,0.03); }
    .episodes-table .table-title { font-weight: 500; }
    .episodes-table .table-duration { color: var(--text3); font-size: 13px; font-family: -apple-system, system-ui, monospace; }
    .episodes-table .table-date { color: var(--text3); font-size: 13px; }
    .episodes-table .table-play { width: 36px; }
    .episodes-table .table-play-btn { width: 32px; height: 32px; border-radius: 50%; background: var(--blue); border: none; color: #fff; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.15s; box-shadow: 0 2px 6px rgba(59,130,246,0.3); }
    .episodes-table .table-play-btn:hover { background: var(--blue2); transform: scale(1.05); }

    @media (max-width: 1024px) {
      .articles-masonry, .episodes-masonry { column-count: 2; }
    }
    @media (max-width: 640px) {
      .articles-masonry, .episodes-masonry { column-count: 1; }
      .articles-cards, .episodes-cards { grid-template-columns: 1fr; }
    }

    /* === PLAYER - Mini player like the design === */
    .player { position: fixed; bottom: 0; left: 0; right: 0; background: var(--bg3); border-top: 1px solid var(--border2); display: none; flex-direction: column; padding: 16px 24px; z-index: 100; border-radius: 16px 16px 0 0; box-shadow: 0 -8px 32px rgba(0,0,0,0.4); }
    .player.active { display: flex; }
    .player-main { display: flex; align-items: center; gap: 16px; }
    .player-left { display: flex; align-items: center; gap: 16px; flex: 1; min-width: 0; }
    .player-art { width: 56px; height: 56px; border-radius: 12px; object-fit: cover; cursor: pointer; box-shadow: 0 4px 12px rgba(0,0,0,0.3); flex-shrink: 0; }
    .player-info { min-width: 0; flex: 1; }
    .player-title { font-size: 14px; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-bottom: 2px; }
    .player-show { font-size: 12px; color: var(--text2); cursor: pointer; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .player-show:hover { color: var(--blue); }
    .player-center { display: flex; align-items: center; gap: 12px; flex-shrink: 0; }
    .player-controls { display: flex; align-items: center; gap: 12px; }
    .player-skip { background: none; border: none; color: var(--text2); cursor: pointer; font-size: 12px; font-weight: 600; padding: 8px; font-family: inherit; border-radius: 50%; transition: all 0.15s; }
    .player-skip:hover { color: var(--text); background: rgba(255,255,255,0.05); }
    .player-play { width: 48px; height: 48px; border-radius: 50%; background: var(--blue); border: none; color: #fff; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.15s; box-shadow: 0 4px 12px rgba(59,130,246,0.4); flex-shrink: 0; }
    .player-play:hover { background: var(--blue2); transform: scale(1.05); }
    .player-progress { width: 100%; display: flex; align-items: center; gap: 10px; margin-top: 12px; }
    .player-time { font-size: 12px; color: var(--text3); font-family: -apple-system, system-ui, monospace; min-width: 44px; }
    .player-time.right { text-align: right; }
    .player-bar { flex: 1; height: 6px; background: var(--bg4); border-radius: 3px; cursor: pointer; position: relative; overflow: hidden; }
    .player-bar:hover { height: 8px; }
    .player-fill { height: 100%; background: linear-gradient(90deg, var(--blue), var(--blue2)); border-radius: 3px; position: relative; z-index: 1; }
    .scrub-tooltip { position: absolute; bottom: 24px; background: var(--bg4); border: 1px solid var(--border2); border-radius: 8px; padding: 6px 10px; font-family: -apple-system, system-ui, monospace; font-size: 12px; font-weight: 600; white-space: nowrap; pointer-events: none; transform: translateX(-50%); display: none; z-index: 10; }
    .player-bar:hover .scrub-tooltip { display: block; }
    .player-right { display: flex; align-items: center; gap: 8px; flex-shrink: 0; }
    .speed-btn { font-size: 12px; font-weight: 600; padding: 8px 12px; background: var(--bg4); border: 1px solid var(--border2); border-radius: 8px; color: var(--text2); cursor: pointer; font-family: inherit; transition: all 0.15s; }
    .speed-btn:hover { color: var(--text); background: rgba(255,255,255,0.08); }
    .player-track-btn { background: none; border: none; color: var(--text2); cursor: pointer; padding: 8px; border-radius: 50%; transition: all 0.15s; display: flex; align-items: center; justify-content: center; }
    .player-track-btn:hover { color: var(--text); background: rgba(255,255,255,0.05); }
    .player-track-btn:disabled { opacity: 0.3; cursor: not-allowed; }
    .volume-control { display: flex; align-items: center; gap: 4px; }
    .volume-slider { width: 80px; height: 4px; -webkit-appearance: none; appearance: none; background: var(--bg4); border-radius: 2px; outline: none; cursor: pointer; transition: all 0.15s; }
    .volume-slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 12px; height: 12px; border-radius: 50%; background: var(--text); cursor: pointer; transition: all 0.15s; }
    .volume-slider::-moz-range-thumb { width: 12px; height: 12px; border-radius: 50%; background: var(--text); cursor: pointer; border: none; transition: all 0.15s; }
    .volume-slider:hover { height: 5px; }
    .volume-slider:hover::-webkit-slider-thumb { background: var(--blue); }
    .volume-slider:hover::-moz-range-thumb { background: var(--blue); }

    /* Expanded */
    .expanded { position: fixed; inset: 0; background: var(--bg); z-index: 200; display: none; flex-direction: column; }
    .expanded.active { display: flex; }
    .expanded-header { padding: 20px 24px; display: flex; justify-content: space-between; align-items: center; }
    .expanded-label { font-size: 12px; text-transform: uppercase; letter-spacing: 1px; color: var(--text3); font-weight: 600; }
    .expanded-body { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 32px; }
    .expanded-art { width: 280px; height: 280px; border-radius: 16px; object-fit: cover; box-shadow: 0 20px 60px rgba(0,0,0,0.5); margin-bottom: 32px; }
    .expanded-info { text-align: center; margin-bottom: 32px; max-width: 400px; }
    .expanded-title { font-size: 22px; font-weight: 700; margin-bottom: 8px; letter-spacing: -0.02em; }
    .expanded-show { font-size: 15px; color: var(--text2); }
    .expanded-progress { width: 100%; max-width: 400px; margin-bottom: 32px; }
    .expanded-bar { width: 100%; height: 6px; background: var(--bg4); border-radius: 3px; cursor: pointer; margin-bottom: 10px; overflow: hidden; }
    .expanded-fill { height: 100%; background: linear-gradient(90deg, var(--blue), var(--blue2)); border-radius: 3px; }
    .expanded-times { display: flex; justify-content: space-between; font-size: 13px; color: var(--text3); font-family: -apple-system, system-ui, monospace; }
    .expanded-controls { display: flex; align-items: center; gap: 24px; }
    .expanded-track-btn { width: 44px; height: 44px; border-radius: 50%; background: rgba(255,255,255,0.05); border: none; color: var(--text); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.15s; }
    .expanded-track-btn:hover { background: rgba(255,255,255,0.1); color: var(--blue); }
    .expanded-track-btn:disabled { opacity: 0.3; cursor: not-allowed; }
    .expanded-skip { width: 48px; height: 48px; border-radius: 50%; background: rgba(255,255,255,0.05); border: none; color: var(--text); cursor: pointer; font-size: 14px; font-weight: 600; font-family: inherit; transition: all 0.15s; }
    .expanded-skip:hover { background: rgba(255,255,255,0.1); }
    .expanded-play { width: 64px; height: 64px; border-radius: 50%; background: var(--blue); border: none; color: #fff; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.15s; box-shadow: 0 6px 20px rgba(59,130,246,0.4); }
    .expanded-play:hover { background: var(--blue2); transform: scale(1.05); }

    /* Swipe Seeking */
    .swipe-container { position: relative; touch-action: pan-y; user-select: none; -webkit-user-select: none; }
    .swipe-indicator { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.8); border-radius: 16px; opacity: 0; pointer-events: none; transition: opacity 0.15s; }
    .swipe-indicator.active { opacity: 1; }
    .swipe-indicator-content { display: flex; flex-direction: column; align-items: center; gap: 10px; }
    .swipe-indicator-icon { font-size: 36px; color: var(--text); }
    .swipe-indicator-text { font-size: 32px; font-weight: 700; color: var(--text); }
    .swipe-indicator-label { font-size: 12px; color: var(--text2); text-transform: uppercase; letter-spacing: 1px; font-weight: 600; }
    .swipe-indicator.rewind .swipe-indicator-icon { color: var(--blue); }
    .swipe-indicator.forward .swipe-indicator-icon { color: var(--blue); }

    /* Modal */
    .modal { position: fixed; inset: 0; background: rgba(0,0,0,0.8); display: none; align-items: center; justify-content: center; z-index: 300; backdrop-filter: blur(4px); }
    .modal.active { display: flex; }
    .modal-box { background: var(--bg3); border-radius: 20px; width: 90%; max-width: 420px; border: 1px solid var(--border2); box-shadow: 0 20px 60px rgba(0,0,0,0.5); }
    .modal-header { padding: 20px 24px; border-bottom: 1px solid var(--border2); display: flex; align-items: center; justify-content: space-between; }
    .modal-header h2 { font-size: 20px; font-weight: 600; letter-spacing: -0.02em; }
    .modal-close { background: rgba(255,255,255,0.05); border: none; color: var(--text2); cursor: pointer; padding: 8px; border-radius: 50%; transition: all 0.15s; }
    .modal-close:hover { background: rgba(255,255,255,0.1); color: var(--text); }
    .modal-body { padding: 24px; }
    .form-group { margin-bottom: 20px; }
    .form-label { display: block; font-size: 13px; font-weight: 600; color: var(--text2); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px; }
    .form-input { width: 100%; padding: 14px 16px; background: var(--bg4); border: 1px solid var(--border2); border-radius: 12px; color: var(--text); font-size: 15px; font-family: inherit; transition: all 0.15s; }
    .form-input:focus { outline: none; border-color: var(--blue); background: var(--bg); }
    .type-sel { display: flex; gap: 12px; }
    .type-btn { flex: 1; padding: 16px; background: var(--bg4); border: 2px solid var(--border2); border-radius: 14px; color: var(--text); cursor: pointer; display: flex; flex-direction: column; align-items: center; gap: 6px; font-family: inherit; transition: all 0.15s; }
    .type-btn:hover { border-color: rgba(255,255,255,0.2); }
    .type-btn.active { border-color: var(--blue); background: rgba(59,130,246,0.1); }
    .type-btn .icon { font-size: 26px; }
    .type-btn .label { font-size: 14px; font-weight: 500; }
    .submit-btn { width: 100%; padding: 16px; background: var(--blue); border: none; border-radius: 14px; color: #fff; font-size: 16px; font-weight: 600; cursor: pointer; font-family: inherit; transition: all 0.15s; box-shadow: 0 4px 12px rgba(59,130,246,0.3); }
    .submit-btn:hover { background: var(--blue2); }
    .submit-btn:disabled { background: var(--bg4); color: var(--text3); cursor: not-allowed; box-shadow: none; }
    .fetch-btn { padding: 14px 18px; background: var(--bg4); border: 1px solid var(--border2); border-radius: 12px; color: var(--text); font-size: 14px; font-weight: 500; cursor: pointer; font-family: inherit; white-space: nowrap; transition: all 0.15s; }
    .fetch-btn:hover:not(:disabled) { background: var(--blue); color: #fff; border-color: var(--blue); }
    .fetch-btn:disabled { background: var(--bg3); color: var(--text3); cursor: not-allowed; }
    .fetch-btn.loading { background: var(--bg3); color: var(--text2); }
    .fetch-status { font-size: 12px; margin-top: 8px; min-height: 16px; }
    .fetch-status.success { color: var(--blue); }
    .fetch-status.error { color: #ef4444; }
    .fetch-status.loading { color: var(--text2); }

    .toast { position: fixed; bottom: 120px; left: 50%; transform: translateX(-50%); background: var(--bg3); color: var(--text); padding: 14px 28px; border-radius: 14px; font-size: 14px; font-weight: 500; z-index: 400; opacity: 0; transition: opacity 0.3s; pointer-events: none; border: 1px solid var(--border2); box-shadow: 0 8px 24px rgba(0,0,0,0.4); }
    .toast.show { opacity: 1; }

    /* Article Details Modal */
    .article-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.85); display: none; align-items: center; justify-content: center; z-index: 350; backdrop-filter: blur(8px); padding: 20px; }
    .article-modal.active { display: flex; }
    .article-modal-box { background: var(--bg2); border-radius: 20px; width: 100%; max-width: 600px; max-height: 90vh; overflow: hidden; border: 1px solid var(--border2); box-shadow: 0 24px 80px rgba(0,0,0,0.6); display: flex; flex-direction: column; }
    .article-modal-header { padding: 16px 20px; display: flex; justify-content: flex-end; position: absolute; top: 0; right: 0; z-index: 10; }
    .article-modal-close { background: rgba(0,0,0,0.5); border: none; color: var(--text); cursor: pointer; padding: 10px; border-radius: 50%; transition: all 0.15s; backdrop-filter: blur(4px); }
    .article-modal-close:hover { background: rgba(0,0,0,0.7); transform: scale(1.05); }
    .article-modal-body { overflow-y: auto; display: flex; flex-direction: column; }
    .article-modal-image { width: 100%; aspect-ratio: 16/9; object-fit: cover; cursor: pointer; transition: opacity 0.15s; }
    .article-modal-image:hover { opacity: 0.9; }
    .article-modal-content { padding: 24px; }
    .article-modal-meta { display: flex; align-items: center; gap: 8px; margin-bottom: 12px; flex-wrap: wrap; }
    .article-modal-source { display: flex; align-items: center; gap: 8px; font-size: 14px; color: var(--text2); font-weight: 500; }
    .article-modal-source img { width: 20px; height: 20px; border-radius: 4px; object-fit: cover; }
    .article-modal-time { font-size: 13px; color: var(--text3); }
    .article-modal-title { font-size: 24px; font-weight: 700; line-height: 1.3; margin-bottom: 16px; color: var(--text); letter-spacing: -0.02em; }
    .article-modal-summary { font-size: 16px; line-height: 1.7; color: var(--text2); margin-bottom: 24px; }
    .article-modal-link { display: inline-flex; align-items: center; gap: 8px; padding: 14px 24px; background: var(--blue); color: #fff; text-decoration: none; border-radius: 12px; font-size: 15px; font-weight: 600; transition: all 0.15s; }
    .article-modal-link:hover { background: var(--blue2); transform: translateY(-1px); }
    .article-modal-link i { font-size: 18px; }
    @media (max-width: 768px) {
      .article-modal { padding: 0; }
      .article-modal-box { max-width: 100%; max-height: 100%; border-radius: 0; height: 100%; }
      .article-modal-title { font-size: 20px; }
      .article-modal-summary { font-size: 15px; }
    }

    /* Mobile Hamburger & Drawer */
    .hamburger { display: none; background: none; border: none; color: var(--text); cursor: pointer; padding: 8px 12px; border-radius: 8px; transition: all 0.15s; }
    .hamburger:hover { background: rgba(255,255,255,0.05); }
    @media (max-width: 768px) { .hamburger { display: flex; } }

    /* Bottom Tab Bar */
    .mobile-tab-bar {
      display: flex;
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: var(--bg2);
      border-top: 1px solid var(--border2);
      padding: 8px 0;
      padding-bottom: max(8px, env(safe-area-inset-bottom));
      z-index: 98;
      justify-content: space-around;
      align-items: center;
    }
    /* Adjust content padding when tab bar is visible */
    .news-list, .podcast-inbox-list, .for-later-content, .feed-scroll,
    .episode-page, .show-page, .source-page {
      padding-bottom: 180px !important;
    }
    .mobile-tab {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 4px;
      padding: 8px 12px;
      background: none;
      border: none;
      color: var(--text3);
      cursor: pointer;
      font-family: inherit;
      font-size: 10px;
      font-weight: 500;
      transition: all 0.15s;
      border-radius: 8px;
      min-width: 56px;
    }
    .mobile-tab i {
      font-size: 22px;
      transition: transform 0.15s;
    }
    .mobile-tab:hover {
      color: var(--text2);
    }
    .mobile-tab:active {
      transform: scale(0.95);
    }
    .mobile-tab.active {
      color: var(--blue);
    }
    .mobile-tab.active i {
      transform: scale(1.1);
    }
    /* Hide tab bar when player is expanded */
    body.player-expanded .mobile-tab-bar {
      display: none !important;
    }

    .drawer-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 150; opacity: 0; pointer-events: none; transition: opacity 0.3s; backdrop-filter: blur(4px); }
    .drawer-overlay.active { opacity: 1; pointer-events: auto; }
    .drawer { position: fixed; top: 0; left: 0; bottom: 0; width: 300px; background: var(--bg2); z-index: 160; transform: translateX(-100%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); display: flex; flex-direction: column; border-right: 1px solid var(--border2); }
    .drawer.active { transform: translateX(0); }
    .drawer-header { padding: 20px; border-bottom: 1px solid var(--border2); display: flex; align-items: center; justify-content: space-between; }
    .drawer-header .logo { font-size: 22px; }
    .drawer-close { background: rgba(255,255,255,0.05); border: none; color: var(--text2); cursor: pointer; padding: 10px; border-radius: 50%; transition: all 0.15s; }
    .drawer-close:hover { background: rgba(255,255,255,0.1); color: var(--text); }
    .drawer-content { flex: 1; overflow-y: auto; padding: 16px; }
    .drawer-section { margin-bottom: 20px; }
    .drawer-section-title { font-size: 11px; font-weight: 600; text-transform: uppercase; color: var(--text3); padding: 10px 14px; letter-spacing: 0.5px; }
    .drawer-item { display: flex; align-items: center; gap: 14px; padding: 14px; border-radius: 12px; cursor: pointer; transition: all 0.15s; }
    .drawer-item:hover { background: rgba(255,255,255,0.04); }
    .drawer-item.active { background: var(--bg4); border: 1px solid var(--border2); }
    .drawer-item-icon { width: 36px; height: 36px; border-radius: 10px; background: var(--bg3); display: flex; align-items: center; justify-content: center; font-size: 18px; box-shadow: 0 2px 6px rgba(0,0,0,0.2); }
    .drawer-item-icon img { width: 100%; height: 100%; object-fit: cover; border-radius: 10px; }
    .drawer-item-name { flex: 1; font-size: 14px; font-weight: 500; }
    .drawer-item-badge { background: var(--orange); color: #fff; font-size: 10px; font-weight: 700; padding: 3px 8px; border-radius: 12px; box-shadow: 0 2px 6px rgba(255,107,53,0.3); }

    /* Sleep Timer */
    .sleep-timer-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.8); display: none; align-items: center; justify-content: center; z-index: 350; backdrop-filter: blur(4px); }
    .sleep-timer-modal.active { display: flex; }
    .sleep-timer-box { background: var(--bg3); border-radius: 20px; width: 90%; max-width: 380px; padding: 24px; border: 1px solid var(--border2); box-shadow: 0 20px 60px rgba(0,0,0,0.5); }
    .sleep-timer-title { font-size: 20px; font-weight: 600; margin-bottom: 20px; display: flex; align-items: center; gap: 10px; letter-spacing: -0.02em; }
    .sleep-timer-presets { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 20px; }
    .sleep-preset { padding: 14px; background: var(--bg4); border: 2px solid var(--border2); border-radius: 12px; color: var(--text); cursor: pointer; font-size: 14px; font-weight: 500; font-family: inherit; transition: all 0.15s; text-align: center; }
    .sleep-preset:hover { background: rgba(255,255,255,0.08); border-color: rgba(255,255,255,0.2); }
    .sleep-preset.active { border-color: var(--blue); background: rgba(59,130,246,0.15); }
    .sleep-custom { display: flex; gap: 10px; margin-bottom: 20px; }
    .sleep-custom input { flex: 1; padding: 14px 16px; background: var(--bg4); border: 1px solid var(--border2); border-radius: 12px; color: var(--text); font-size: 15px; font-family: inherit; transition: all 0.15s; }
    .sleep-custom input:focus { outline: none; border-color: var(--blue); background: var(--bg); }
    .sleep-custom button { padding: 14px 20px; background: var(--blue); border: none; border-radius: 12px; color: #fff; font-weight: 600; cursor: pointer; font-family: inherit; transition: all 0.15s; box-shadow: 0 2px 8px rgba(59,130,246,0.3); }
    .sleep-custom button:hover { background: var(--blue2); }
    .sleep-timer-active { background: rgba(59,130,246,0.1); border: 1px solid var(--blue); border-radius: 14px; padding: 16px; display: flex; align-items: center; justify-content: space-between; }
    .sleep-timer-countdown { font-size: 28px; font-weight: 700; font-family: -apple-system, system-ui, monospace; color: var(--blue); }
    .sleep-timer-cancel { background: rgba(255,255,255,0.05); border: 1px solid var(--border2); border-radius: 10px; padding: 10px 16px; color: var(--text); cursor: pointer; font-size: 14px; font-family: inherit; transition: all 0.15s; }
    .sleep-timer-cancel:hover { background: rgba(255,255,255,0.1); }
    .sleep-badge { position: absolute; top: -4px; right: -4px; background: var(--blue); color: #fff; font-size: 9px; font-weight: 700; padding: 3px 6px; border-radius: 10px; min-width: 18px; text-align: center; }

    /* Podcast Search Modal */
    .podcast-search-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.8); display: none; align-items: center; justify-content: center; z-index: 350; backdrop-filter: blur(4px); }
    .podcast-search-modal.active { display: flex; }
    .podcast-search-box { background: var(--bg3); border-radius: 20px; width: 90%; max-width: 500px; max-height: 85vh; border: 1px solid var(--border2); box-shadow: 0 20px 60px rgba(0,0,0,0.5); display: flex; flex-direction: column; }
    .podcast-search-header { padding: 20px 24px; border-bottom: 1px solid var(--border2); display: flex; align-items: center; justify-content: space-between; flex-shrink: 0; }
    .podcast-search-header h2 { font-size: 20px; font-weight: 600; letter-spacing: -0.02em; display: flex; align-items: center; gap: 10px; }
    .podcast-search-close { background: rgba(255,255,255,0.05); border: none; color: var(--text2); cursor: pointer; padding: 8px; border-radius: 50%; transition: all 0.15s; }
    .podcast-search-close:hover { background: rgba(255,255,255,0.1); color: var(--text); }
    .podcast-search-body { padding: 24px; overflow-y: auto; flex: 1; }
    .podcast-search-input-wrap { display: flex; gap: 8px; margin-bottom: 20px; }
    .podcast-search-input { flex: 1; padding: 14px 16px; background: var(--bg4); border: 1px solid var(--border2); border-radius: 12px; color: var(--text); font-size: 15px; font-family: inherit; transition: all 0.15s; }
    .podcast-search-input:focus { outline: none; border-color: var(--blue); background: var(--bg); }
    .podcast-search-btn { padding: 14px 20px; background: var(--blue); border: none; border-radius: 12px; color: #fff; font-weight: 600; cursor: pointer; font-family: inherit; transition: all 0.15s; display: flex; align-items: center; gap: 8px; }
    .podcast-search-btn:hover { background: var(--blue2); }
    .podcast-search-btn:disabled { background: var(--bg4); color: var(--text3); cursor: not-allowed; }
    .podcast-search-results { display: flex; flex-direction: column; gap: 12px; }
    .podcast-search-empty { text-align: center; padding: 40px 20px; color: var(--text2); }
    .podcast-search-empty i { font-size: 48px; opacity: 0.3; margin-bottom: 12px; display: block; }
    .podcast-search-loading { text-align: center; padding: 40px 20px; color: var(--text2); }
    .podcast-search-loading i { font-size: 32px; animation: spin 1s linear infinite; display: block; margin-bottom: 12px; }
    @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    .podcast-result-item { display: flex; gap: 14px; padding: 14px; background: var(--bg4); border-radius: 14px; border: 1px solid var(--border2); transition: all 0.15s; }
    .podcast-result-item:hover { border-color: rgba(255,255,255,0.15); }
    .podcast-result-art { width: 72px; height: 72px; border-radius: 12px; background: var(--bg3); flex-shrink: 0; overflow: hidden; }
    .podcast-result-art img { width: 100%; height: 100%; object-fit: cover; }
    .podcast-result-info { flex: 1; min-width: 0; display: flex; flex-direction: column; justify-content: center; }
    .podcast-result-title { font-size: 15px; font-weight: 600; color: var(--text); margin-bottom: 4px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .podcast-result-author { font-size: 13px; color: var(--text2); margin-bottom: 6px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .podcast-result-meta { font-size: 12px; color: var(--text3); display: flex; gap: 12px; flex-wrap: wrap; }
    .podcast-result-actions { display: flex; align-items: center; flex-shrink: 0; }
    .podcast-add-btn { padding: 10px 16px; background: var(--blue); border: none; border-radius: 10px; color: #fff; font-size: 13px; font-weight: 600; cursor: pointer; font-family: inherit; transition: all 0.15s; display: flex; align-items: center; gap: 6px; }
    .podcast-add-btn:hover { background: var(--blue2); }
    .podcast-add-btn:disabled { background: var(--bg3); color: var(--text3); cursor: not-allowed; }
    .podcast-add-btn.added { background: rgba(34,197,94,0.2); color: #22c55e; }
    .podcast-search-status { font-size: 12px; color: var(--text2); margin-bottom: 12px; }
    .podcast-search-powered { font-size: 11px; color: var(--text3); text-align: center; margin-top: 16px; display: flex; align-items: center; justify-content: center; gap: 6px; }
    .podcast-search-powered a { color: var(--blue); text-decoration: none; }
    .podcast-search-powered a:hover { text-decoration: underline; }

    /* Settings Modal */
    .settings-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.8); display: none; align-items: center; justify-content: center; z-index: 350; backdrop-filter: blur(4px); }
    .settings-modal.active { display: flex; }
    .settings-box { background: var(--bg3); border-radius: 20px; width: 90%; max-width: 420px; border: 1px solid var(--border2); box-shadow: 0 20px 60px rgba(0,0,0,0.5); }
    .settings-header { padding: 20px 24px; border-bottom: 1px solid var(--border2); display: flex; align-items: center; justify-content: space-between; }
    .settings-header h2 { font-size: 20px; font-weight: 600; letter-spacing: -0.02em; display: flex; align-items: center; gap: 10px; }
    .settings-close { background: rgba(255,255,255,0.05); border: none; color: var(--text2); cursor: pointer; padding: 8px; border-radius: 50%; transition: all 0.15s; }
    .settings-close:hover { background: rgba(255,255,255,0.1); color: var(--text); }
    .settings-body { padding: 24px; }
    .settings-section { margin-bottom: 24px; }
    .settings-section:last-child { margin-bottom: 0; }
    .settings-section-title { font-size: 12px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text2); margin-bottom: 12px; }
    .settings-item { display: flex; align-items: center; justify-content: space-between; padding: 14px 16px; background: var(--bg4); border-radius: 12px; margin-bottom: 8px; }
    .settings-item:last-child { margin-bottom: 0; }
    .settings-item-label { font-size: 14px; font-weight: 500; }
    .settings-item-desc { font-size: 12px; color: var(--text2); margin-top: 2px; }
    .toggle-switch { position: relative; width: 48px; height: 28px; cursor: pointer; }
    .toggle-switch input { opacity: 0; width: 0; height: 0; }
    .toggle-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--bg); border: 1px solid var(--border2); border-radius: 14px; transition: 0.3s; }
    .toggle-slider:before { position: absolute; content: ""; height: 22px; width: 22px; left: 2px; bottom: 2px; background-color: var(--text2); border-radius: 50%; transition: 0.3s; }
    .toggle-switch input:checked + .toggle-slider { background-color: var(--blue); border-color: var(--blue); }
    .toggle-switch input:checked + .toggle-slider:before { transform: translateX(20px); background-color: #fff; }

    /* Snapshot List */
    .snapshot-list { max-height: 400px; overflow-y: auto; }
    .snapshot-item { display: flex; align-items: center; gap: 12px; padding: 14px; background: var(--bg4); border-radius: 12px; margin-bottom: 8px; border: 1px solid var(--border); transition: all 0.15s; }
    .snapshot-item:hover { background: rgba(255,255,255,0.04); border-color: var(--border2); }
    .snapshot-icon { width: 40px; height: 40px; background: rgba(59,130,246,0.1); border-radius: 10px; display: flex; align-items: center; justify-content: center; color: var(--blue); font-size: 18px; flex-shrink: 0; }
    .snapshot-info { flex: 1; min-width: 0; }
    .snapshot-date { font-size: 14px; font-weight: 500; margin-bottom: 2px; }
    .snapshot-reason { font-size: 12px; color: var(--text2); text-transform: capitalize; }
    .snapshot-stats { font-size: 11px; color: var(--text3); margin-top: 2px; }
    .snapshot-actions-row { display: flex; gap: 6px; flex-shrink: 0; }
    .snapshot-btn { padding: 8px 12px; border-radius: 8px; font-size: 12px; font-weight: 500; cursor: pointer; border: 1px solid var(--border2); background: var(--bg3); color: var(--text); transition: all 0.15s; font-family: inherit; }
    .snapshot-btn:hover { background: rgba(255,255,255,0.08); }
    .snapshot-btn.restore { background: var(--blue); border-color: var(--blue); color: #fff; }
    .snapshot-btn.restore:hover { background: var(--blue2); }
    .snapshot-btn.delete { color: var(--text2); }
    .snapshot-btn.delete:hover { background: rgba(239,68,68,0.1); border-color: rgba(239,68,68,0.3); color: #ef4444; }

    /* Speed Control Panel */
    .speed-panel { position: absolute; bottom: 100%; right: 0; background: var(--bg3); border: 1px solid var(--border2); border-radius: 16px; padding: 20px; width: 300px; display: none; z-index: 110; box-shadow: 0 -8px 32px rgba(0,0,0,0.4); }
    .speed-panel.active { display: block; }
    .speed-panel-title { font-size: 15px; font-weight: 600; margin-bottom: 16px; }
    .speed-slider-container { margin-bottom: 20px; }
    .speed-value { font-size: 32px; font-weight: 700; text-align: center; margin-bottom: 12px; color: var(--blue); }
    .speed-slider { width: 100%; height: 6px; -webkit-appearance: none; background: var(--bg4); border-radius: 3px; outline: none; }
    .speed-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; background: var(--blue); border-radius: 50%; cursor: pointer; box-shadow: 0 2px 8px rgba(59,130,246,0.4); }
    .speed-slider::-moz-range-thumb { width: 20px; height: 20px; background: var(--blue); border-radius: 50%; cursor: pointer; border: none; box-shadow: 0 2px 8px rgba(59,130,246,0.4); }
    .speed-presets { display: flex; gap: 8px; flex-wrap: wrap; }
    .speed-preset-btn { padding: 10px 14px; background: var(--bg4); border: 1px solid var(--border2); border-radius: 10px; color: var(--text2); cursor: pointer; font-size: 13px; font-weight: 500; font-family: inherit; transition: all 0.15s; }
    .speed-preset-btn:hover { background: rgba(255,255,255,0.08); color: var(--text); }
    .speed-preset-btn.active { background: var(--blue); border-color: var(--blue); color: #fff; box-shadow: 0 2px 6px rgba(59,130,246,0.3); }

    /* Bookmarks */
    .bookmarks-panel { position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); background: var(--bg3); border: 1px solid var(--border2); border-radius: 16px; padding: 20px; width: 340px; max-height: 320px; display: none; z-index: 110; box-shadow: 0 -8px 32px rgba(0,0,0,0.4); overflow-y: auto; }
    .bookmarks-panel.active { display: block; }
    .bookmarks-title { font-size: 15px; font-weight: 600; margin-bottom: 16px; display: flex; align-items: center; justify-content: space-between; }
    .bookmark-add-btn { background: var(--blue); border: none; color: #fff; width: 28px; height: 28px; border-radius: 50%; cursor: pointer; font-size: 16px; transition: all 0.15s; box-shadow: 0 2px 6px rgba(59,130,246,0.3); }
    .bookmark-add-btn:hover { background: var(--blue2); transform: scale(1.05); }
    .bookmark-item { display: flex; align-items: center; gap: 12px; padding: 12px; background: var(--bg4); border-radius: 12px; margin-bottom: 8px; cursor: pointer; transition: all 0.15s; border: 1px solid var(--border); }
    .bookmark-item:hover { background: rgba(255,255,255,0.06); border-color: var(--border2); }
    .bookmark-time { font-family: -apple-system, system-ui, monospace; font-size: 13px; font-weight: 600; color: var(--blue); min-width: 54px; }
    .bookmark-note { flex: 1; font-size: 13px; color: var(--text2); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .bookmark-delete { background: none; border: none; color: var(--text3); cursor: pointer; padding: 6px; opacity: 0; transition: all 0.15s; border-radius: 50%; }
    .bookmark-item:hover .bookmark-delete { opacity: 1; }
    .bookmark-delete:hover { color: #ef4444; background: rgba(239,68,68,0.1); }
    .bookmark-marker { position: absolute; top: -4px; width: 10px; height: 10px; background: var(--orange); border-radius: 50%; transform: translateX(-50%); cursor: pointer; z-index: 5; box-shadow: 0 2px 6px rgba(255,107,53,0.4); }
    .bookmark-marker:hover { transform: translateX(-50%) scale(1.3); }
    .bookmarks-empty { text-align: center; color: var(--text3); padding: 24px; font-size: 14px; }

    /* Queue Panel */
    .queue-panel { position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); background: var(--bg3); border: 1px solid var(--border2); border-radius: 16px; padding: 20px; width: 380px; max-height: 400px; display: none; z-index: 110; box-shadow: 0 -8px 32px rgba(0,0,0,0.4); overflow-y: auto; }
    .queue-panel.active { display: block; }
    .queue-title { font-size: 15px; font-weight: 600; margin-bottom: 16px; display: flex; align-items: center; justify-content: space-between; }
    .queue-clear-btn { background: none; border: 1px solid var(--border2); color: var(--text2); padding: 6px 12px; border-radius: 8px; cursor: pointer; font-size: 12px; font-weight: 500; font-family: inherit; transition: all 0.15s; }
    .queue-clear-btn:hover { background: rgba(239,68,68,0.1); border-color: rgba(239,68,68,0.3); color: #ef4444; }
    .queue-item { display: flex; align-items: center; gap: 12px; padding: 12px; background: var(--bg4); border-radius: 12px; margin-bottom: 8px; cursor: pointer; transition: all 0.15s; border: 1px solid var(--border); position: relative; }
    .queue-item:hover { background: rgba(255,255,255,0.06); border-color: var(--border2); }
    .queue-item-art { width: 44px; height: 44px; border-radius: 8px; overflow: hidden; flex-shrink: 0; background: var(--bg3); }
    .queue-item-art img { width: 100%; height: 100%; object-fit: cover; }
    .queue-item-info { flex: 1; min-width: 0; }
    .queue-item-title { font-size: 14px; font-weight: 500; color: var(--text); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-bottom: 2px; }
    .queue-item-show { font-size: 12px; color: var(--text3); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .queue-item-remove { background: none; border: none; color: var(--text3); cursor: pointer; padding: 6px; opacity: 0; transition: all 0.15s; border-radius: 50%; }
    .queue-item:hover .queue-item-remove { opacity: 1; }
    .queue-item-remove:hover { color: #ef4444; background: rgba(239,68,68,0.1); }
    .queue-item-drag { cursor: grab; color: var(--text3); padding: 4px; }
    .queue-item-drag:active { cursor: grabbing; }
    .queue-empty { text-align: center; color: var(--text3); padding: 32px 24px; font-size: 14px; }
    .queue-empty i { font-size: 40px; margin-bottom: 12px; opacity: 0.5; display: block; }
    .queue-badge { position: absolute; top: -4px; right: -4px; background: var(--blue); color: #fff; font-size: 10px; font-weight: 700; padding: 2px 6px; border-radius: 10px; min-width: 16px; text-align: center; }

    /* Scrubbing Preview */
    .scrub-preview { position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); background: var(--bg3); border: 1px solid var(--border2); border-radius: 10px; padding: 8px 14px; font-family: -apple-system, system-ui, monospace; font-size: 14px; font-weight: 600; display: none; white-space: nowrap; pointer-events: none; }
    .scrub-preview.active { display: block; }

    /* Adaptive Background */
    .expanded.adaptive-bg { background: linear-gradient(180deg, var(--adaptive-color, var(--bg)) 0%, var(--bg) 60%); }

    /* Player enhancements */
    .player-right { display: flex; align-items: center; gap: 8px; flex-shrink: 0; position: relative; }
    .player-btn { background: rgba(255,255,255,0.05); border: none; color: var(--text2); cursor: pointer; padding: 10px; border-radius: 50%; transition: all 0.15s; position: relative; }
    .player-btn:hover { background: rgba(255,255,255,0.1); color: var(--text); }
    .player-btn.active { color: var(--blue); background: rgba(59,130,246,0.1); }

    .empty { display: flex; flex-direction: column; align-items: center; padding: 60px 32px; text-align: center; color: var(--text3); }
    .empty-icon { font-size: 56px; margin-bottom: 16px; }
    .empty-title { font-size: 18px; font-weight: 600; color: var(--text); letter-spacing: -0.02em; }

    @media (max-width: 768px) {
      .header { gap: 12px; }
      .header .logo { display: none; }
      .toggle-btn span:last-child { display: none; }
      .toggle-btn { padding: 8px 12px; }
      .icon-btn { padding: 8px; }
      .search-box { display: none; }
      .news-sidebar { display: none !important; }
      .podcast-sidebar { display: none !important; }
      .show-hero, .source-hero { flex-direction: column; align-items: center; text-align: center; padding: 24px; }
      .show-hero > .back-btn, .source-hero > .back-btn, .episode-hero > .back-btn { align-self: flex-start; margin-bottom: 16px; }
      .show-hero-art, .source-hero-art { width: 160px; height: 160px; }
      .show-hero-title, .source-hero-title { font-size: 26px; }
      .episode-hero { flex-direction: column; align-items: center; text-align: center; padding: 24px 20px; gap: 20px; }
      .episode-hero-art { width: 160px; height: 160px; }
      .episode-hero-info { padding-top: 0; }
      .episode-hero-title { font-size: 20px; -webkit-line-clamp: 4; }
      .episode-hero-meta { justify-content: center; }
      .episode-actions { justify-content: center; flex-wrap: wrap; padding: 16px 20px; }
      .episode-play-btn { width: 100%; justify-content: center; }
      .episode-action-btn { flex: 1; min-width: 100px; justify-content: center; }
      .episode-description { padding: 0 20px 24px; }
      .episode-bookmarks { padding: 0 20px 120px; }
      .episode-progress-section { padding: 0 20px 16px; }
      .episode-tags { justify-content: center; }
      .player { padding: 12px 16px; }
      .player-art { width: 48px; height: 48px; }
      .player-play { width: 44px; height: 44px; }
    }

    /* ============================================
       MOBILE OPTIMIZATION
       ============================================ */

    /* Breakpoint Strategy:
       - 640px and below: Phone portrait/landscape
       - 641px to 1024px: Tablet
       - 1025px+: Desktop (existing styles)
    */

    @media (max-width: 1024px) {
      /* Tablet adjustments - moderate changes */
      html {
        font-size: 15px;
      }

      .header {
        padding: 20px 20px 14px 20px;
      }

      .main-toggle {
        gap: 8px;
      }

      .toggle-btn {
        padding: 10px 16px;
        font-size: 14px;
      }
    }

    @media (max-width: 768px) {
      /* Show mobile headers when sidebar is hidden */
      .mobile-shows-header {
        display: block;
        padding: var(--mobile-space-md);
        background: var(--bg);
        border-bottom: 1px solid var(--border);
      }

      .mobile-news-header {
        display: block;
        padding: var(--mobile-space-md);
        background: var(--bg);
        border-bottom: 1px solid var(--border);
      }

      .mobile-shows-title {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: var(--mobile-space-md);
      }

      .mobile-shows-title h3 {
        font-size: var(--mobile-text-lg);
        font-weight: 600;
        color: var(--text);
      }

      .mobile-shows-title .add-show-btn {
        background: var(--blue);
        border: none;
        color: #fff;
        width: 32px;
        height: 32px;
        border-radius: 50%;
        cursor: pointer;
        font-size: 20px;
        transition: all 0.15s;
        box-shadow: 0 2px 8px rgba(59,130,246,0.3);
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }

      .mobile-shows-title .add-show-btn:hover {
        background: var(--blue2);
        transform: scale(1.05);
      }

      .mobile-shows-actions {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .mobile-shows-title .discover-show-btn {
        background: var(--bg3);
        border: 1px solid var(--border2);
        color: var(--text);
        height: 32px;
        padding: 0 14px;
        border-radius: 16px;
        cursor: pointer;
        font-size: var(--mobile-text-sm);
        font-weight: 500;
        font-family: inherit;
        transition: all 0.15s;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
      }

      .mobile-shows-title .discover-show-btn:hover {
        background: var(--bg4);
        border-color: var(--blue);
        color: var(--blue);
      }

      .mobile-shows-title .discover-show-btn:active {
        transform: scale(0.96);
      }

      .mobile-shows-title .discover-show-btn i {
        font-size: 14px;
      }

      .mobile-news-title {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: var(--mobile-space-md);
      }

      .mobile-news-title h3 {
        font-size: var(--mobile-text-lg);
        font-weight: 600;
        color: var(--text);
      }

      .mobile-news-title .add-news-btn {
        background: var(--blue);
        border: none;
        color: #fff;
        width: 32px;
        height: 32px;
        border-radius: 50%;
        cursor: pointer;
        font-size: 20px;
        transition: all 0.15s;
        box-shadow: 0 2px 8px rgba(59,130,246,0.3);
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }

      .mobile-news-title .add-news-btn:hover {
        background: var(--blue2);
        transform: scale(1.05);
      }

      /* Hide desktop inbox header */
      .podcast-inbox-header {
        display: none;
      }
    }

    @media (max-width: 640px) {
      /* ==================
         PHASE 1: FOUNDATION
         ================== */

      /* Reset box model for consistent sizing */
      * {
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
      }

      /* Constrain app to mobile-like width and center on large screens */
      .app {
        max-width: 480px;
        margin: 0 auto;
        position: relative;
        box-shadow: 0 0 60px rgba(0, 0, 0, 0.5);
      }

      /* Background for desktop to show app is mobile-only */
      html {
        background: #000;
        /* Base font size affects all rem units */
        font-size: 16px;
        /* Prevent zoom on input focus in iOS Safari */
        -webkit-text-size-adjust: 100%;
      }

      body {
        /* Ensure body doesn't overflow horizontally */
        overflow-x: hidden;
        /* Smoother scrolling on iOS */
        -webkit-overflow-scrolling: touch;
      }

      /* ==================
         PHASE 2: TYPOGRAPHY
         ================== */

      /* Headers */
      .logo {
        font-size: 20px;
      }

      .news-title,
      .section-title,
      .all-section-title {
        font-size: var(--mobile-text-3xl);
        letter-spacing: -0.03em;
        line-height: 1.2;
      }

      .section-header h2,
      .sidebar-header h2 {
        font-size: var(--mobile-text-xs);
      }

      /* Article/Episode Titles */
      .article-title {
        font-size: var(--mobile-text-xl);
        line-height: 1.4;
        -webkit-line-clamp: 3;
      }

      .episode-title {
        font-size: var(--mobile-text-lg);
        line-height: 1.4;
      }

      .article-card-title,
      .episode-card-title,
      .all-card-title {
        font-size: var(--mobile-text-lg);
        line-height: 1.4;
      }

      /* Body Text */
      .article-summary,
      .episode-desc,
      .article-card-summary {
        font-size: var(--mobile-text-base);
        line-height: 1.6;
        -webkit-line-clamp: 3;
      }

      /* Meta Text */
      .article-meta,
      .episode-card-meta,
      .all-item-meta {
        font-size: var(--mobile-text-sm);
      }

      .article-source,
      .episode-show {
        font-size: var(--mobile-text-sm);
      }

      .article-time {
        font-size: var(--mobile-text-xs);
      }

      /* ==================
         PHASE 3: TOUCH TARGETS
         ================== */

      /* All interactive elements must meet 44x44px minimum */

      .toggle-btn {
        min-height: var(--mobile-touch-min);
        padding: 12px 20px;
        font-size: var(--mobile-text-base);
        gap: 6px;
      }

      .chip,
      .tag-chip {
        min-height: var(--mobile-touch-min);
        padding: 12px 20px;
        font-size: var(--mobile-text-base);
      }

      .tag-chip {
        padding: 10px 16px;
      }

      .icon-btn {
        min-width: var(--mobile-touch-min);
        min-height: var(--mobile-touch-min);
        padding: 12px;
      }

      .add-btn {
        width: var(--mobile-touch-min);
        height: var(--mobile-touch-min);
        font-size: 24px;
        box-shadow: 0 4px 12px rgba(59,130,246,0.4);
      }

      .back-btn {
        min-height: var(--mobile-touch-min);
        padding: 12px 20px;
        font-size: var(--mobile-text-base);
      }

      /* Source/Show items in sidebar/drawer */
      .source-item,
      .drawer-item {
        min-height: var(--mobile-touch-comfortable);
        padding: 12px 16px;
      }

      .source-icon,
      .drawer-item-icon {
        width: 40px;
        height: 40px;
        font-size: 20px;
      }

      .source-name,
      .drawer-item-name {
        font-size: var(--mobile-text-base);
      }

      /* ==================
         PHASE 4: SPACING & LAYOUT
         ================== */

      /* Header - Minimal mobile header */
      .header {
        padding: var(--mobile-space-sm) var(--mobile-space-md);
        padding-top: max(var(--mobile-space-lg), var(--sat));
        gap: var(--mobile-space-sm);
        position: sticky;
        top: 0;
        z-index: var(--z-mobile-header);
        backdrop-filter: blur(12px);
        background: rgba(26, 26, 26, 0.95);
        min-height: auto;
      }

      /* Hide most header elements on mobile - just keep hamburger */
      .header .logo,
      .header .spacer,
      .header #refreshBtn,
      .header #settingsBtn,
      .header #addBtn,
      .header .search-box {
        display: none !important;
      }

      /* Hamburger button is the main nav */
      .header .hamburger {
        margin-right: auto;
        display: flex !important;
      }

      .main {
        /* Add top padding to account for sticky header */
        padding-top: 0;
      }

      /* Toggle moved to bottom navigation */
      .main-toggle {
        position: fixed;
        bottom: 0;
        left: 50%;
        transform: translateX(-50%);
        width: 100%;
        max-width: 480px;
        background: var(--bg2);
        border-top: 1px solid var(--border2);
        border-radius: 0;
        padding: 8px;
        padding-bottom: max(8px, var(--sab));
        z-index: var(--z-mobile-nav);
        justify-content: space-around;
        box-shadow: 0 -4px 16px rgba(0, 0, 0, 0.3);
      }

      .toggle-btn {
        flex: 1;
        flex-direction: column;
        gap: 4px;
        padding: 8px 4px;
        border-radius: 12px;
      }

      .toggle-btn span:first-child {
        font-size: 24px;
        line-height: 1;
      }

      .toggle-btn span:last-child {
        display: block !important;
        font-size: 11px;
        font-weight: 600;
      }

      /* Content areas need bottom padding for nav */
      .news-list,
      .podcast-content,
      .all-content {
        padding: var(--mobile-space-md);
        padding-bottom: calc(70px + var(--sab));
      }

      /* Extra padding when mini player is active (nav bar is hidden, player is at bottom) */
      .player.active ~ .main .news-list,
      .player.active ~ .main .podcast-content,
      .player.active ~ .main .all-content,
      body:has(.player.active) .news-list,
      body:has(.player.active) .podcast-content,
      body:has(.player.active) .podcast-inbox-content,
      body:has(.player.active) .all-content {
        padding-bottom: calc(100px + var(--sab));
      }

      /* Articles */
      .article {
        padding: var(--mobile-space-lg);
        gap: var(--mobile-space-md);
        margin-bottom: var(--mobile-space-md);
        border-radius: 16px;
      }

      .article-icon {
        display: none;
      }

      .article-meta {
        gap: 6px;
        margin-bottom: 8px;
      }

      .article-title {
        margin-bottom: 8px;
      }

      .article-image {
        width: 100px;
        height: 80px;
      }

      /* Episodes */
      .episode {
        padding: var(--mobile-space-lg);
        gap: var(--mobile-space-md);
        margin-bottom: var(--mobile-space-md);
      }

      .episode-art-wrap {
        width: 72px;
        height: 72px;
      }

      .ep-play {
        width: var(--mobile-touch-min);
        height: var(--mobile-touch-min);
      }

      .ep-play svg {
        width: 14px;
        height: 14px;
      }

      /* Cards */
      .articles-cards,
      .episodes-cards,
      .all-cards {
        grid-template-columns: 1fr !important;
        gap: var(--mobile-space-md);
      }

      .article-card-image,
      .episode-card-art-wrap,
      .all-card-image {
        height: 200px;
        aspect-ratio: auto;
      }

      .article-card-body,
      .episode-card-body,
      .all-card-body {
        padding: var(--mobile-space-lg);
      }

      /* Masonry - single column */
      .articles-masonry,
      .episodes-masonry,
      .all-masonry {
        column-count: 1 !important;
        gap: var(--mobile-space-md);
      }

      /* Section spacing */
      .section {
        margin-bottom: var(--mobile-space-2xl);
      }

      .section-header {
        margin-bottom: var(--mobile-space-lg);
      }

      /* ==================
         PHASE 5: MOBILE MINI PLAYER - Full functionality
         ================== */

      /* Mini player stays at bottom with all controls visible */

      /* ==================
         PHASE 6: EXPANDED PLAYER
         ================== */

      .expanded-header {
        padding: var(--mobile-space-lg) var(--mobile-space-md);
        padding-top: max(var(--mobile-space-lg), var(--sat));
      }

      .expanded-body {
        padding: var(--mobile-space-2xl) var(--mobile-space-lg);
      }

      .expanded-art {
        width: min(320px, 80vw);
        height: min(320px, 80vw);
        margin-bottom: var(--mobile-space-2xl);
      }

      .expanded-info {
        margin-bottom: var(--mobile-space-2xl);
      }

      .expanded-title {
        font-size: var(--mobile-text-3xl);
        line-height: 1.3;
        margin-bottom: var(--mobile-space-sm);
      }

      .expanded-show {
        font-size: var(--mobile-text-lg);
      }

      .expanded-progress {
        max-width: 100%;
        margin-bottom: var(--mobile-space-2xl);
      }

      .expanded-bar {
        height: 8px;
        margin-bottom: var(--mobile-space-sm);
      }

      .expanded-times {
        font-size: var(--mobile-text-sm);
      }

      .expanded-controls {
        gap: var(--mobile-space-2xl);
      }

      .expanded-skip {
        width: 56px;
        height: 56px;
        font-size: var(--mobile-text-base);
      }

      .expanded-play {
        width: 72px;
        height: 72px;
      }

      .expanded-play svg {
        width: 28px;
        height: 28px;
      }

      /* ==================
         PHASE 7: PANELS & MODALS
         ================== */

      .speed-panel,
      .bookmarks-panel,
      .queue-panel {
        /* Make panels full-width bottom sheets on mobile */
        position: fixed;
        bottom: 0;
        left: 50%;
        transform: translateX(-50%) translateY(100%);
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        width: 100%;
        max-width: 480px;
        max-height: 60vh;
        border-radius: 20px 20px 0 0;
        padding: var(--mobile-space-xl) var(--mobile-space-lg);
        padding-bottom: max(var(--mobile-space-xl), var(--sab));
        overflow-y: auto;
      }

      .speed-panel.active,
      .bookmarks-panel.active,
      .queue-panel.active {
        display: block;
        transform: translateX(-50%) translateY(0);
      }

      .speed-panel-title,
      .bookmarks-title {
        font-size: var(--mobile-text-2xl);
        margin-bottom: var(--mobile-space-lg);
      }

      .speed-value {
        font-size: 48px;
        margin-bottom: var(--mobile-space-md);
      }

      .speed-slider {
        height: 8px;
      }

      .speed-slider::-webkit-slider-thumb {
        width: 28px;
        height: 28px;
      }

      .speed-slider::-moz-range-thumb {
        width: 28px;
        height: 28px;
      }

      .speed-preset-btn {
        min-height: var(--mobile-touch-min);
        padding: 12px 16px;
        font-size: var(--mobile-text-base);
      }

      .bookmark-item {
        min-height: var(--mobile-touch-comfortable);
        padding: var(--mobile-space-md);
        margin-bottom: var(--mobile-space-sm);
      }

      .bookmark-time {
        font-size: var(--mobile-text-base);
      }

      .bookmark-note {
        font-size: var(--mobile-text-sm);
      }

      .bookmark-delete {
        min-width: var(--mobile-touch-min);
        min-height: var(--mobile-touch-min);
        padding: 12px;
        opacity: 1;
      }

      /* Modal */
      .modal-box {
        width: calc(100% - 32px);
        max-width: none;
        margin: var(--mobile-space-md);
      }

      .modal-header {
        padding: var(--mobile-space-lg) var(--mobile-space-lg);
      }

      .modal-header h2 {
        font-size: var(--mobile-text-2xl);
      }

      .modal-body {
        padding: var(--mobile-space-lg);
      }

      .form-input {
        min-height: var(--mobile-touch-comfortable);
        padding: 14px 16px;
        font-size: var(--mobile-text-md);
      }

      .type-btn {
        min-height: 80px;
        padding: var(--mobile-space-lg);
      }

      .type-btn .icon {
        font-size: 32px;
      }

      .type-btn .label {
        font-size: var(--mobile-text-base);
      }

      .submit-btn,
      .fetch-btn {
        min-height: var(--mobile-touch-comfortable);
        padding: 14px 20px;
        font-size: var(--mobile-text-md);
      }

      /* Sleep Timer Modal */
      .sleep-timer-box {
        width: calc(100% - 32px);
        padding: var(--mobile-space-xl) var(--mobile-space-lg);
        padding-bottom: max(var(--mobile-space-xl), var(--sab));
      }

      .sleep-timer-title {
        font-size: var(--mobile-text-2xl);
        margin-bottom: var(--mobile-space-lg);
      }

      .sleep-preset {
        min-height: var(--mobile-touch-comfortable);
        padding: 14px;
        font-size: var(--mobile-text-base);
      }

      .sleep-custom input {
        min-height: var(--mobile-touch-comfortable);
        padding: 14px 16px;
        font-size: var(--mobile-text-md);
      }

      .sleep-custom button {
        min-height: var(--mobile-touch-comfortable);
        padding: 14px 24px;
      }

      /* ==================
         PHASE 8: DRAWER
         ================== */

      .drawer {
        width: 85vw;
        max-width: 320px;
      }

      .drawer-header {
        padding: var(--mobile-space-lg);
        padding-top: max(var(--mobile-space-lg), var(--sat));
      }

      .drawer-content {
        padding: var(--mobile-space-md);
      }

      .drawer-section {
        margin-bottom: var(--mobile-space-lg);
      }

      .drawer-section-title {
        padding: var(--mobile-space-sm) var(--mobile-space-md);
      }

      /* ==================
         PHASE 9: SHOW/SOURCE PAGES
         ================== */

      .show-hero,
      .source-hero {
        flex-direction: column;
        align-items: center;
        text-align: center;
        padding: var(--mobile-space-xl) var(--mobile-space-lg);
      }

      .show-hero-art,
      .source-hero-art {
        width: 180px;
        height: 180px;
        margin-bottom: var(--mobile-space-lg);
      }

      .show-hero-title,
      .source-hero-title {
        font-size: var(--mobile-text-4xl);
        line-height: 1.2;
        margin-bottom: var(--mobile-space-sm);
      }

      .show-hero-author,
      .source-hero-author {
        font-size: var(--mobile-text-base);
      }

      .show-actions,
      .source-actions {
        padding: var(--mobile-space-lg) var(--mobile-space-md);
        flex-wrap: wrap;
      }

      .show-play {
        width: 60px;
        height: 60px;
      }

      .show-play svg {
        width: 24px;
        height: 24px;
      }

      .show-episodes,
      .source-articles {
        padding: 0 var(--mobile-space-md);
        padding-bottom: calc(150px + var(--sab));
      }

      .show-episodes-title,
      .source-articles-title {
        font-size: var(--mobile-text-2xl);
        margin-bottom: var(--mobile-space-lg);
      }

      /* ==================
         PHASE 10: SHOWS GRID
         ================== */

      .shows-grid {
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)) !important;
        gap: var(--mobile-space-lg);
      }

      .show-card {
        max-width: none;
      }

      .show-art {
        margin-bottom: var(--mobile-space-md);
      }

      .show-name {
        font-size: var(--mobile-text-base);
        line-height: 1.3;
      }

      .show-author {
        font-size: var(--mobile-text-sm);
      }

      /* ==================
         PHASE 11: TAG FILTERS
         ================== */

      .tag-filter-section {
        padding: var(--mobile-space-md);
      }

      .tag-filter-header {
        margin-bottom: var(--mobile-space-sm);
      }

      .tag-chips {
        gap: 8px;
        padding-bottom: 8px;
      }

      /* ==================
         PHASE 12: CATEGORY CHIPS - HIDDEN ON MOBILE
         ================== */

      /* Hide category chips on mobile - they show All/Uncategorized which is useless */
      .category-chips {
        display: none;
      }

      .news-header {
        padding: var(--mobile-space-md);
      }

      .news-title {
        font-size: var(--mobile-text-lg);
        margin-bottom: 0;
      }

      /* ==================
         PHASE 13: TABLE VIEWS
         ================== */

      /* Make tables scroll horizontally on mobile */
      .articles-table,
      .episodes-table,
      .all-table {
        display: table;
        min-width: 600px;
      }

      .source-articles-content,
      .show-episodes-content {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
      }

      /* ==================
         PHASE 14: TOAST
         ================== */

      .toast {
        bottom: calc(80px + var(--sab));
        padding: var(--mobile-space-md) var(--mobile-space-xl);
        font-size: var(--mobile-text-base);
        max-width: calc(100% - 32px);
      }

      /* ==================
         PHASE 15: SEARCH
         ================== */

      .search-box {
        display: block;
        max-width: none;
        flex: 1;
      }

      .search-box input {
        font-size: var(--mobile-text-md);
        padding: 10px 16px 10px 38px;
      }

      /* ==================
         PHASE 16: EMPTY STATES
         ================== */

      .empty {
        padding: calc(var(--mobile-space-2xl) * 2) var(--mobile-space-lg);
      }

      .empty-icon {
        font-size: 72px;
        margin-bottom: var(--mobile-space-lg);
      }

      .empty-title {
        font-size: var(--mobile-text-2xl);
        margin-bottom: var(--mobile-space-sm);
      }

      /* ==================
         PHASE 17: PERFORMANCE
         ================== */

      /* Reduce animations on mobile for better performance */
      @media (prefers-reduced-motion: no-preference) {
        .article:active,
        .episode:active,
        .show-card:active {
          /* Instant feedback on tap */
          transform: scale(0.98);
          transition-duration: 0.1s;
        }
      }

      /* Reduce motion for accessibility */
      @media (prefers-reduced-motion: reduce) {
        *,
        *::before,
        *::after {
          animation-duration: 0.01ms !important;
          animation-iteration-count: 1 !important;
          transition-duration: 0.01ms !important;
          scroll-behavior: auto !important;
        }
      }

      /* ==================
         PHASE 18: SWIPE IMPROVEMENTS
         ================== */

      .swipe-indicator {
        border-radius: 20px;
      }

      .swipe-indicator-icon {
        font-size: 48px;
      }

      .swipe-indicator-text {
        font-size: 40px;
      }

      .swipe-indicator-label {
        font-size: var(--mobile-text-sm);
      }

      /* ==================
         PHASE 19: FEED VIEW
         ================== */

      .feed-container {
        padding-bottom: calc(80px + var(--sab));
      }

      .feed-scroll {
        padding-bottom: calc(80px + var(--sab));
      }

      /* Compact feed-nav on mobile - icon-only pills */
      .feed-nav {
        padding: 6px 12px;
        gap: 4px;
        background: var(--bg);
        border-bottom: 1px solid var(--border);
        justify-content: center;
      }

      .feed-nav-btn {
        padding: 6px 14px;
        min-height: 36px;
        border-radius: 18px;
        border-bottom: none;
        background: var(--bg3);
        gap: 6px;
        font-size: 12px;
      }

      .feed-nav-btn.active {
        background: var(--blue);
        color: #fff;
        border-bottom: none;
      }

      .feed-nav-btn.active .feed-nav-count {
        background: rgba(255,255,255,0.2);
        color: #fff;
      }

      /* Hide text labels, show only icons and counts on mobile */
      .feed-nav-btn span:not(.feed-nav-icon):not(.feed-nav-count) {
        display: none;
      }

      .feed-nav-btn .feed-nav-icon {
        font-size: 16px;
      }

      .feed-nav-btn .feed-nav-count {
        font-size: 11px;
        padding: 1px 6px;
      }

      /* Default mobile view - more compact than desktop */
      .feed-post-inner {
        padding: 12px;
      }

      .feed-post-header {
        gap: 10px;
        margin-bottom: 8px;
      }

      .feed-post-avatar {
        width: 36px;
        height: 36px;
        font-size: 16px;
      }

      .feed-post-source {
        font-size: 14px;
      }

      .feed-post-handle {
        font-size: 12px;
        margin-top: 1px;
      }

      .feed-post-body {
        padding-left: 46px;
      }

      .feed-post-title {
        font-size: 15px;
        margin-bottom: 6px;
        -webkit-line-clamp: 2;
      }

      .feed-post-summary {
        font-size: 14px;
        -webkit-line-clamp: 3;
        line-height: 1.4;
      }

      .feed-post-media {
        margin-bottom: 10px;
        border-radius: 12px;
      }

      .feed-post-media img {
        max-height: 220px;
      }

      .feed-post-play {
        min-height: var(--mobile-touch-min);
        padding: 12px 24px;
      }

      /* ==================
         MOBILE CARD DISPLAY MODES
         ================== */

      /* View toggle button in feed nav */
      .mobile-view-toggle {
        display: flex;
        margin-left: auto;
        background: var(--bg3);
        border: none;
        color: var(--text2);
        padding: 6px 10px;
        border-radius: 18px;
        font-size: 16px;
        cursor: pointer;
        align-items: center;
        gap: 4px;
      }

      .mobile-view-toggle:active {
        background: var(--bg4);
      }

      /* === COMPACT MODE - More preview text, smaller elements === */
      .feed-scroll.mobile-compact .feed-post-inner {
        padding: 12px;
      }

      .feed-scroll.mobile-compact .feed-post-header {
        gap: 10px;
        margin-bottom: 6px;
      }

      .feed-scroll.mobile-compact .feed-post-avatar {
        width: 32px;
        height: 32px;
        font-size: 14px;
      }

      .feed-scroll.mobile-compact .feed-post-source {
        font-size: 13px;
      }

      .feed-scroll.mobile-compact .feed-post-handle {
        font-size: 11px;
      }

      .feed-scroll.mobile-compact .feed-post-body {
        padding-left: 42px;
      }

      .feed-scroll.mobile-compact .feed-post-title {
        font-size: 14px;
        margin-bottom: 4px;
        -webkit-line-clamp: 2;
      }

      .feed-scroll.mobile-compact .feed-post-summary {
        font-size: 13px;
        -webkit-line-clamp: 4;
        line-height: 1.4;
      }

      .feed-scroll.mobile-compact .feed-post-media {
        margin-bottom: 8px;
        border-radius: 12px;
      }

      .feed-scroll.mobile-compact .feed-post-media img {
        max-height: 200px;
      }

      .feed-scroll.mobile-compact .feed-post-play {
        padding: 8px 16px;
        font-size: 13px;
        min-height: 36px;
      }

      /* === DENSE MODE - Maximum content density, text-focused === */
      .feed-scroll.mobile-dense .feed-post-inner {
        padding: 10px 12px;
      }

      .feed-scroll.mobile-dense .feed-post-header {
        display: none;
      }

      .feed-scroll.mobile-dense .feed-post-body {
        padding-left: 0;
      }

      .feed-scroll.mobile-dense .feed-post-title {
        font-size: 14px;
        font-weight: 600;
        margin-bottom: 2px;
        -webkit-line-clamp: 2;
      }

      .feed-scroll.mobile-dense .feed-post-summary {
        font-size: 12px;
        -webkit-line-clamp: 2;
        line-height: 1.3;
        margin-bottom: 4px;
      }

      .feed-scroll.mobile-dense .feed-post-media {
        display: none;
      }

      .feed-scroll.mobile-dense .feed-post-actions {
        display: none;
      }

      .feed-scroll.mobile-dense .feed-post-play {
        display: none;
      }

      .feed-scroll.mobile-dense .feed-post-duration {
        display: none;
      }

      /* Add source/time inline in dense mode */
      .feed-scroll.mobile-dense .feed-post {
        position: relative;
      }

      .feed-scroll.mobile-dense .feed-post::before {
        content: attr(data-source) " Â· " attr(data-time);
        display: block;
        font-size: 11px;
        color: var(--text3);
        margin-bottom: 2px;
      }

      /* Dense mode type badge */
      .feed-scroll.mobile-dense .feed-post-type-badge {
        position: absolute;
        top: 10px;
        right: 12px;
        font-size: 9px;
        padding: 2px 6px;
      }

      /* === LIST MODE - Super compact, headlines only === */
      .feed-scroll.mobile-list .feed-post {
        border-bottom: 1px solid var(--border);
      }

      .feed-scroll.mobile-list .feed-post-inner {
        padding: 8px 12px;
      }

      .feed-scroll.mobile-list .feed-post-header {
        display: none;
      }

      .feed-scroll.mobile-list .feed-post-body {
        padding-left: 0;
      }

      .feed-scroll.mobile-list .feed-post-title {
        font-size: 14px;
        font-weight: 500;
        margin-bottom: 0;
        -webkit-line-clamp: 1;
      }

      .feed-scroll.mobile-list .feed-post-summary {
        display: none;
      }

      .feed-scroll.mobile-list .feed-post-media {
        display: none;
      }

      .feed-scroll.mobile-list .feed-post-actions,
      .feed-scroll.mobile-list .feed-post-tags,
      .feed-scroll.mobile-list .feed-post-play,
      .feed-scroll.mobile-list .feed-post-duration {
        display: none;
      }

      /* ==================
         PHASE 20: SPOTIFY-STYLE MOBILE
         ================== */

      /* Mobile Shows Browser - horizontal scroll at top */
      .mobile-shows-scroll {
        display: flex;
        gap: var(--mobile-space-md);
        overflow-x: auto;
        scroll-snap-type: x mandatory;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none;
        padding: 4px 0;
      }

      .mobile-shows-scroll::-webkit-scrollbar {
        display: none;
      }

      .mobile-show-card {
        flex: 0 0 auto;
        width: 80px;
        text-align: center;
        cursor: pointer;
        scroll-snap-align: start;
      }

      .mobile-show-card.all-shows {
        width: 80px;
      }

      .mobile-show-card .show-art {
        width: 64px;
        height: 64px;
        border-radius: 12px;
        margin: 0 auto var(--mobile-space-xs);
        background: var(--bg3);
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.15s, box-shadow 0.15s;
      }

      .mobile-show-card:active .show-art {
        transform: scale(0.95);
      }

      .mobile-show-card.active .show-art {
        box-shadow: 0 0 0 2px var(--blue), 0 4px 12px rgba(59,130,246,0.4);
      }

      .mobile-show-card .show-art img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .mobile-show-card .show-art i {
        font-size: 28px;
        color: var(--text3);
      }

      .mobile-show-card .show-name {
        font-size: 11px;
        color: var(--text2);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 80px;
        line-height: 1.3;
      }

      .mobile-show-card.active .show-name {
        color: var(--blue);
        font-weight: 600;
      }

      /* New indicator for mobile show cards */
      .mobile-show-card.has-new {
        position: relative;
      }

      .mobile-show-card.has-new::after {
        content: '';
        position: absolute;
        top: 2px;
        right: 6px;
        width: 12px;
        height: 12px;
        background: var(--blue);
        border-radius: 50%;
        border: 2px solid var(--bg);
        z-index: 1;
      }

      /* Episode list - full width, minimal padding */
      .podcast-inbox-list {
        padding: 0;
        padding-bottom: calc(70px + var(--sab));
      }

      /* Extra padding when player is active */
      body:has(.player.active) .podcast-inbox-list {
        padding-bottom: calc(140px + var(--sab));
      }

      /* Mobile News Sources Header */
      .mobile-news-scroll {
        display: flex;
        gap: var(--mobile-space-md);
        overflow-x: auto;
        scroll-snap-type: x mandatory;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none;
        padding: 4px 0;
      }

      .mobile-news-scroll::-webkit-scrollbar {
        display: none;
      }

      .mobile-news-card {
        flex: 0 0 auto;
        width: 80px;
        text-align: center;
        cursor: pointer;
        scroll-snap-align: start;
      }

      .mobile-news-card .source-art {
        width: 64px;
        height: 64px;
        border-radius: 12px;
        margin: 0 auto var(--mobile-space-xs);
        background: var(--bg3);
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.15s, box-shadow 0.15s;
      }

      .mobile-news-card:active .source-art {
        transform: scale(0.95);
      }

      .mobile-news-card.active .source-art {
        box-shadow: 0 0 0 2px var(--blue), 0 4px 12px rgba(59,130,246,0.4);
      }

      .mobile-news-card .source-art img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .mobile-news-card .source-art i {
        font-size: 28px;
        color: var(--text3);
      }

      .mobile-news-card .source-name {
        font-size: 11px;
        color: var(--text2);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 80px;
        line-height: 1.3;
      }

      .mobile-news-card.active .source-name {
        color: var(--blue);
        font-weight: 600;
      }

      .mobile-news-card.has-new {
        position: relative;
      }

      .mobile-news-card.has-new::after {
        content: '';
        position: absolute;
        top: 2px;
        right: 6px;
        width: 12px;
        height: 12px;
        background: var(--blue);
        border-radius: 50%;
        border: 2px solid var(--bg);
        z-index: 1;
      }

      /* Mobile view options in headers */
      .mobile-inbox-view-toggle {
        display: flex;
        gap: 4px;
        margin-left: auto;
      }

      .mobile-inbox-view-toggle .view-btn {
        width: 32px;
        height: 32px;
        border-radius: 8px;
        background: var(--bg3);
        border: 1px solid var(--border);
        color: var(--text3);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.15s;
      }

      .mobile-inbox-view-toggle .view-btn.active {
        background: var(--blue);
        border-color: var(--blue);
        color: #fff;
      }

      .spotify-ep {
        padding: 14px 16px;
        gap: 14px;
      }

      .spotify-ep-art {
        width: 52px;
        height: 52px;
        border-radius: 6px;
      }

      .spotify-ep-play-overlay {
        opacity: 0;
      }

      .spotify-ep:active .spotify-ep-play-overlay,
      .spotify-ep.now-playing .spotify-ep-play-overlay {
        opacity: 1;
      }

      .spotify-ep-title {
        font-size: 14px;
        -webkit-line-clamp: 2;
      }

      .spotify-ep-meta {
        font-size: 12px;
      }

      .spotify-ep-duration {
        font-size: 11px;
      }

      /* Mini player - mobile optimized, locked to bottom */
      .player {
        bottom: 0;
        border-radius: 0;
        margin: 0;
        width: 100%;
        padding-bottom: max(12px, var(--sab));
        box-shadow: 0 -4px 20px rgba(0,0,0,0.5);
      }

      /* Hide nav bar when player is active on mobile */
      body:has(.player.active) .controls {
        display: none !important;
      }

      .player-main {
        padding: 10px 12px 6px;
        gap: 10px;
      }

      .player-art {
        width: 44px;
        height: 44px;
        border-radius: 6px;
      }

      .player-title {
        font-size: 13px;
      }

      .player-show {
        font-size: 11px;
      }

      .player-center {
        gap: 4px;
      }

      .player-skip {
        width: 32px;
        height: 32px;
        font-size: 11px;
        padding: 4px;
      }

      .player-play {
        width: 40px;
        height: 40px;
      }

      .player-play svg {
        width: 16px;
        height: 16px;
      }

      .player-track-btn {
        padding: 6px;
      }

      .player-track-btn svg {
        width: 16px;
        height: 16px;
      }

      .player-right {
        display: flex;
        gap: 6px;
      }

      .player-btn {
        padding: 6px;
      }

      .player-btn svg {
        width: 14px;
        height: 14px;
      }

      .speed-btn {
        font-size: 11px;
        padding: 6px 10px;
      }

      .volume-control {
        display: flex;
        gap: 4px;
      }

      .volume-slider {
        width: 60px;
      }

      #pExpand {
        padding: 6px;
      }

      #pExpand svg {
        width: 14px;
        height: 14px;
      }

      .player-progress {
        padding: 0 12px 10px;
        gap: 6px;
      }

      .player-time {
        font-size: 10px;
        min-width: 32px;
      }

      .player-bar {
        height: 3px;
      }

      /* Expanded player - full mobile experience */
      .expanded-header {
        padding: 12px 16px;
        padding-top: max(12px, var(--sat));
      }

      .expanded-body {
        padding: 16px;
        padding-bottom: max(32px, var(--sab));
        gap: 20px;
        justify-content: flex-start;
        padding-top: 0;
      }

      .swipe-container {
        width: min(280px, 70vw);
        margin-top: 20px;
      }

      .expanded-art {
        border-radius: 8px;
      }

      .expanded-info {
        padding: 0;
      }

      .expanded-title {
        font-size: 18px;
        margin-bottom: 6px;
      }

      .expanded-show {
        font-size: 13px;
      }

      .expanded-progress {
        max-width: 100%;
        padding: 0 8px;
      }

      .expanded-bar {
        height: 4px;
        margin-bottom: 6px;
      }

      .expanded-times {
        font-size: 11px;
      }

      .expanded-controls {
        gap: 20px;
        margin-top: 8px;
      }

      .expanded-skip {
        width: 48px;
        height: 48px;
        font-size: 13px;
      }

      .expanded-play {
        width: 64px;
        height: 64px;
      }

      .expanded-play svg {
        width: 24px;
        height: 24px;
      }

      .expanded-extra {
        gap: 24px;
        margin-top: 24px;
      }

      .expanded-btn i {
        font-size: 20px;
      }

      .expanded-btn span {
        font-size: 9px;
      }

      /* Hide sidebars on all screens */
      .news-sidebar,
      .podcast-sidebar {
        display: none !important;
      }

      /* Bottom nav adjustments when player is visible */
      .main-toggle {
        z-index: var(--z-mobile-nav);
      }
    }

    /* ==================
       LANDSCAPE MOBILE ADJUSTMENTS
       ================== */

    @media (max-width: 896px) and (orientation: landscape) {
      /* Optimize for landscape phone viewing */

      .expanded-art {
        width: 200px;
        height: 200px;
        margin-bottom: var(--mobile-space-lg);
      }

      .expanded-body {
        padding: var(--mobile-space-lg);
      }

      .expanded-controls {
        gap: var(--mobile-space-lg);
      }

      .expanded-skip {
        width: 48px;
        height: 48px;
      }

      .expanded-play {
        width: 60px;
        height: 60px;
      }

      /* Make show grid denser */
      .shows-grid {
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
        gap: var(--mobile-space-md);
      }
    }

    /* Skeleton loading animation */
    .skeleton {
      background: linear-gradient(
        90deg,
        var(--bg3) 25%,
        var(--bg4) 50%,
        var(--bg3) 75%
      );
      background-size: 200% 100%;
      animation: shimmer 1.5s ease-in-out infinite;
      border-radius: 8px;
    }

    @keyframes shimmer {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }

    .skeleton-wrapper {
      opacity: 0.6;
    }

    /* Image loading - immediate display with smooth fade-in */
    .img-container {
      position: relative;
      background: var(--bg3);
      overflow: hidden;
    }

    .img-container img {
      opacity: 0;
      transition: opacity 0.2s ease-out;
    }

    .img-container img.loaded {
      opacity: 1;
    }

    .img-container .img-fallback {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text3);
      font-size: 24px;
      pointer-events: none;
    }

    /* Direct image loading - no lazy loading flicker */
    img.eager-img {
      opacity: 0;
      transition: opacity 0.15s ease-out;
    }

    img.eager-img.loaded {
      opacity: 1;
    }

    /* Legacy lazy-img support - works with new ImageLoader */
    .lazy-img {
      opacity: 0;
      transition: opacity 0.15s ease-out;
    }
    .lazy-img.loaded { opacity: 1; }

    /* Content loading states */
    .content-loading {
      position: relative;
    }

    .content-loading::after {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(
        90deg,
        transparent 0%,
        rgba(255,255,255,0.03) 50%,
        transparent 100%
      );
      background-size: 200% 100%;
      animation: shimmer 2s ease-in-out infinite;
      pointer-events: none;
    }

    /* Fast fade-in for cached content */
    .from-cache {
      animation: fadeIn 0.15s ease-out;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    /* Virtual scroll container */
    .virtual-scroll-wrapper {
      will-change: transform;
    }

    .virtual-scroll-viewport {
      will-change: transform;
    }

    /* Ripple animation */
    @keyframes ripple {
      to {
        transform: scale(2.5);
        opacity: 0;
      }
    }

    /* Pull to refresh indicator */
    .pull-to-refresh-indicator {
      position: fixed;
      top: -80px;
      left: 0;
      right: 0;
      height: 80px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 8px;
      background: var(--bg2);
      z-index: 99;
      transition: transform 0.2s ease-out;
      color: var(--text2);
    }

    .pull-spinner {
      animation: spin 1s linear infinite;
    }

    .pull-spinner.ready {
      animation: none;
      transform: rotate(180deg);
    }

    .pull-text {
      font-size: 13px;
      font-weight: 500;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Swipe delete button */
    .swipe-delete-btn {
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      width: 80px;
      background: #ef4444;
      border: none;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    /* Bottom sheet backdrop */
    .bottom-sheet-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.6);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease-out;
      z-index: 109;
      backdrop-filter: blur(4px);
    }

    /* ===========================================
       FORCE MOBILE MODE - Hide desktop version
       Always show mobile UI regardless of screen size
       =========================================== */

    /* Constrain app to mobile-like width and center on large screens */
    .app {
      max-width: 480px;
      margin: 0 auto;
      position: relative;
      box-shadow: 0 0 60px rgba(0, 0, 0, 0.5);
    }

    /* Background for desktop to show app is mobile-only */
    html {
      background: #000;
    }

    /* Force mobile tap behaviors */
    * {
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
    }

    /* Force mobile header - hide desktop elements */
    .header {
      padding: var(--mobile-space-sm) var(--mobile-space-md);
      padding-top: max(var(--mobile-space-lg), var(--sat));
      gap: var(--mobile-space-sm);
      position: sticky;
      top: 0;
      z-index: var(--z-mobile-header);
      backdrop-filter: blur(12px);
      background: rgba(26, 26, 26, 0.95);
      min-height: auto;
    }

    .header .logo,
    .header .spacer,
    .header #refreshBtn,
    .header #settingsBtn,
    .header #addBtn,
    .header .search-box {
      display: none !important;
    }

    .header .hamburger {
      margin-right: auto;
      display: flex !important;
    }

    /* Force toggle bar to bottom navigation */
    .main-toggle {
      position: fixed;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 100%;
      max-width: 480px;
      background: var(--bg2);
      border-top: 1px solid var(--border2);
      border-radius: 0;
      padding: 8px;
      padding-bottom: max(8px, var(--sab));
      z-index: var(--z-mobile-nav);
      justify-content: space-around;
      box-shadow: 0 -4px 16px rgba(0, 0, 0, 0.3);
    }

    .toggle-btn {
      flex: 1;
      flex-direction: column;
      gap: 4px;
      padding: 8px 4px;
      border-radius: 12px;
      min-height: var(--mobile-touch-min);
      font-size: var(--mobile-text-base);
    }

    .toggle-btn span:first-child {
      font-size: 24px;
      line-height: 1;
    }

    .toggle-btn span:last-child {
      display: block !important;
      font-size: 11px;
      font-weight: 600;
    }

    /* Force single column layouts */
    .articles-cards,
    .episodes-cards,
    .all-cards {
      grid-template-columns: 1fr !important;
      gap: var(--mobile-space-md);
    }

    .articles-masonry,
    .episodes-masonry,
    .all-masonry {
      column-count: 1 !important;
      gap: var(--mobile-space-md);
    }

    /* Force mobile content padding */
    .news-list,
    .podcast-content,
    .all-content {
      padding: var(--mobile-space-md);
      padding-bottom: calc(70px + var(--sab));
    }

    /* Extra padding when mini player is active */
    body:has(.player.active) .news-list,
    body:has(.player.active) .podcast-content,
    body:has(.player.active) .podcast-inbox-content,
    body:has(.player.active) .all-content {
      padding-bottom: calc(100px + var(--sab));
    }

    /* Hide sidebars on all screens */
    .news-sidebar,
    .podcast-sidebar {
      display: none !important;
    }

    /* Force mobile player styles - full width, positioned above tab bar */
    .player {
      position: fixed;
      bottom: 65px; /* Position above mobile tab bar */
      left: 0;
      right: 0;
      width: 100%;
      max-width: none;
      padding: 12px 16px;
      border-radius: 12px 12px 0 0;
      z-index: var(--z-mobile-player);
      background: linear-gradient(180deg, var(--bg3) 0%, var(--bg2) 100%);
      box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.5);
      transform: none;
    }

    /* Account for safe area on devices with home indicator */
    @supports (padding-bottom: env(safe-area-inset-bottom)) {
      .player {
        bottom: calc(65px + env(safe-area-inset-bottom));
      }
    }

    /* Hide bottom nav when player is active */
    body:has(.player.active) .main-toggle {
      display: none !important;
    }

    .player-main {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 0;
    }

    .player-left {
      display: flex;
      align-items: center;
      gap: 12px;
      flex: 1;
      min-width: 0;
    }

    .player-center {
      display: flex !important;
      align-items: center;
      gap: 4px;
    }

    .player-controls {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .player-skip {
      display: flex !important;
      width: 32px;
      height: 32px;
      font-size: 11px;
    }

    .player-track-btn {
      display: flex !important;
      padding: 6px;
    }

    .player-progress {
      display: flex !important;
      padding: 8px 0 0;
      gap: 8px;
    }

    .player-time {
      font-size: 11px;
      min-width: 36px;
    }

    .player-bar {
      height: 4px;
    }

    .player-right {
      display: flex !important;
      align-items: center;
      gap: 4px;
    }

    .player-btn,
    .speed-btn,
    #pExpand {
      display: flex !important;
    }

    .player-btn {
      padding: 8px;
    }

    .speed-btn {
      font-size: 11px;
      padding: 6px 10px;
    }

    #pExpand {
      padding: 8px;
    }

    .volume-control {
      display: none;
    }

    .player-art {
      width: 48px;
      height: 48px;
      border-radius: 8px;
      flex-shrink: 0;
    }

    .player-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 2px;
    }

    .player-show {
      font-size: 12px;
    }

    .player-play {
      width: 44px;
      height: 44px;
      background: var(--blue);
      border-radius: 50%;
    }

    /* Force mobile shows grid */
    .shows-grid {
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)) !important;
      gap: var(--mobile-space-lg);
    }

    .show-card {
      max-width: none;
    }

    /* Force drawer width for mobile */
    .drawer {
      width: 85vw;
      max-width: 320px;
    }

    /* Force mobile typography */
    .article-title {
      font-size: var(--mobile-text-xl);
      line-height: 1.4;
    }

    .episode-title {
      font-size: var(--mobile-text-lg);
      line-height: 1.4;
    }

    /* Force mobile hero pages */
    .show-hero,
    .source-hero {
      flex-direction: column;
      align-items: center;
      text-align: center;
      padding: var(--mobile-space-xl) var(--mobile-space-lg);
    }

    .show-hero-art,
    .source-hero-art {
      width: 180px;
      height: 180px;
      margin-bottom: var(--mobile-space-lg);
    }

    /* Force mobile modal sizing */
    .modal-box {
      width: calc(100% - 32px);
      max-width: none;
      margin: var(--mobile-space-md);
    }

    /* Force mobile panels to bottom sheets */
    .speed-panel,
    .bookmarks-panel,
    .queue-panel {
      position: fixed;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%) translateY(100%);
      width: 100%;
      max-width: 480px;
      max-height: 60vh;
      border-radius: 20px 20px 0 0;
    }

    .speed-panel.active,
    .bookmarks-panel.active,
    .queue-panel.active {
      transform: translateX(-50%) translateY(0);
    }
  </style>
</head>
<body>
<div class="app">
  <header class="header">
    <button class="hamburger" id="hamburgerBtn"><svg width="24" height="24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 6h16M4 12h16M4 18h16"/></svg></button>
    <div class="logo"><img src="https://storage.googleapis.com/intelechia-content/im/BRRST%20(2).png" alt="BRRST"></div>
    <div class="spacer"></div>
    <div class="search-box" id="searchBox">
      <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2"><circle cx="7" cy="7" r="5"/><path d="M12 12l3 3"/></svg>
      <input type="text" id="searchInput" placeholder="Search all content...">
      <button class="search-clear" id="searchClear" title="Clear search">&times;</button>
      <div class="search-scope" id="searchScope"></div>
    </div>
    <button class="icon-btn" id="refreshBtn" title="Refresh feeds"><svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M1 4v6h6M23 20v-6h-6"/><path d="M20.49 9A9 9 0 005.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 013.51 15"/></svg></button>
    <button class="icon-btn" id="settingsBtn" title="Settings"><svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M12 15a3 3 0 100-6 3 3 0 000 6z"/><path d="M19.4 15a1.65 1.65 0 00.33 1.82l.06.06a2 2 0 010 2.83 2 2 0 01-2.83 0l-.06-.06a1.65 1.65 0 00-1.82-.33 1.65 1.65 0 00-1 1.51V21a2 2 0 01-2 2 2 2 0 01-2-2v-.09A1.65 1.65 0 009 19.4a1.65 1.65 0 00-1.82.33l-.06.06a2 2 0 01-2.83 0 2 2 0 010-2.83l.06-.06a1.65 1.65 0 00.33-1.82 1.65 1.65 0 00-1.51-1H3a2 2 0 01-2-2 2 2 0 012-2h.09A1.65 1.65 0 004.6 9a1.65 1.65 0 00-.33-1.82l-.06-.06a2 2 0 010-2.83 2 2 0 012.83 0l.06.06a1.65 1.65 0 001.82.33H9a1.65 1.65 0 001-1.51V3a2 2 0 012-2 2 2 0 012 2v.09a1.65 1.65 0 001 1.51 1.65 1.65 0 001.82-.33l.06-.06a2 2 0 012.83 0 2 2 0 010 2.83l-.06.06a1.65 1.65 0 00-.33 1.82V9a1.65 1.65 0 001.51 1H21a2 2 0 012 2 2 2 0 01-2 2h-.09a1.65 1.65 0 00-1.51 1z"/></svg></button>
    <button class="icon-btn" id="addBtn"><svg width="22" height="22" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12h14"/></svg></button>
  </header>
  
  <div class="main">
    <!-- NEWS VIEW -->
    <div class="news-view active" id="newsView">
      <aside class="news-sidebar">
        <div class="sidebar-header"><h2>Sources</h2><button class="add-btn" id="addNewsBtn">+</button></div>
        <div class="sidebar-content" id="newsSources"></div>
      </aside>
      <div class="news-content" id="newsContent">
        <div class="mobile-news-header" id="mobileNewsHeader"></div>
        <div class="news-header">
          <div class="news-title" id="newsTitle">All Articles</div>
          <div class="category-chips" id="categoryChips"></div>
        </div>
        <div class="tag-filter-section" id="tagFilterSection">
          <div class="tag-filter-header">
            <span class="tag-filter-title">Filter by Topic</span>
          </div>
          <div class="tag-chips" id="tagChips"></div>
        </div>
        <div class="news-list" id="newsList"></div>
      </div>
      <div class="source-page" id="sourcePage"></div>
    </div>
    
    <!-- PODCAST VIEW -->
    <div class="podcast-view" id="podcastView">
      <aside class="podcast-sidebar">
        <div class="sidebar-header"><h2>Shows</h2><button class="add-btn discover-btn" id="discoverPodcastBtn" title="Discover Podcasts"><i class="ph ph-magnifying-glass"></i></button><button class="add-btn" id="addPodcastBtn" title="Add by URL">+</button></div>
        <div class="sidebar-content" id="podcastSources"></div>
      </aside>
      <div class="podcast-inbox-content" id="podcastInboxContent">
        <div class="mobile-shows-header" id="mobileShowsHeader"></div>
        <div class="podcast-inbox-header" id="podcastInboxHeader">
          <div class="inbox-title">Latest Episodes</div>
        </div>
        <div class="podcast-inbox-list" id="podcastInboxList"></div>
      </div>
      <div class="show-page" id="showPage"></div>
      <div class="episode-page" id="episodePage"></div>
    </div>

    <!-- ALL VIEW -->
    <div class="all-view" id="allView">
      <nav class="feed-nav" id="feedNav">
        <button class="feed-nav-btn active" data-filter="podcast">
          <span class="feed-nav-icon"><i class="ph ph-headphones"></i></span>
          <span>Podcasts</span>
          <span class="feed-nav-count" id="feedCountPodcast">0</span>
        </button>
        <button class="feed-nav-btn" data-filter="news">
          <span class="feed-nav-icon"><i class="ph ph-newspaper"></i></span>
          <span>News</span>
          <span class="feed-nav-count" id="feedCountNews">0</span>
        </button>
        <button class="feed-nav-btn" data-filter="all">
          <span class="feed-nav-icon"><i class="ph ph-books"></i></span>
          <span>All</span>
          <span class="feed-nav-count" id="feedCountAll">0</span>
        </button>
        <button class="mobile-view-toggle" id="mobileViewToggle" title="Change card layout">
          <i class="ph ph-rows" id="mobileViewIcon"></i>
        </button>
      </nav>
      <div class="feed-container">
        <div class="feed-scroll" id="feedScroll"></div>
      </div>
    </div>

    <!-- FOR LATER VIEW -->
    <div class="for-later-view" id="forLaterView">
      <div class="for-later-content">
        <div class="for-later-header">
          <div class="for-later-title">
            <i class="ph ph-clock"></i>
            <span>For Later</span>
          </div>
        </div>
        <div class="for-later-list" id="forLaterList"></div>
      </div>
    </div>
  </div>

  <!-- MOBILE BOTTOM TAB BAR -->
  <nav class="mobile-tab-bar" id="mobileTabBar">
    <button class="mobile-tab" data-tab="podcasts">
      <i class="ph ph-headphones"></i>
      <span>Podcasts</span>
    </button>
    <button class="mobile-tab" data-tab="news">
      <i class="ph ph-newspaper"></i>
      <span>News</span>
    </button>
    <button class="mobile-tab" data-tab="discover">
      <i class="ph ph-magnifying-glass"></i>
      <span>Discover</span>
    </button>
    <button class="mobile-tab" data-tab="forLater">
      <i class="ph ph-bookmark-simple"></i>
      <span>Saved</span>
    </button>
    <button class="mobile-tab" data-tab="library">
      <i class="ph ph-list"></i>
      <span>Library</span>
    </button>
  </nav>

  <!-- PLAYER -->
  <div class="player" id="player">
    <div class="player-main">
      <div class="player-left">
        <img class="player-art" id="playerArt" src="">
        <div class="player-info">
          <div class="player-title" id="playerTitle"></div>
          <div class="player-show" id="playerShow"></div>
        </div>
      </div>
      <div class="player-center">
        <div class="player-controls">
          <button class="player-track-btn" id="pPrev" title="Previous Episode (Shift+P)"><svg width="20" height="20" fill="currentColor" viewBox="0 0 24 24"><path d="M6 6h2v12H6V6zm3.5 6l8.5 6V6l-8.5 6z"/></svg></button>
          <button class="player-skip" id="pSkipBack" title="Rewind 15s (â†)">-15</button>
          <button class="player-play" id="pPlay" title="Play/Pause (Space)"><svg width="18" height="18" fill="currentColor" viewBox="0 0 24 24" id="pPlayIcon"><path d="M8 5v14l11-7z"/></svg></button>
          <button class="player-skip" id="pSkipFwd" title="Forward 30s (â†’)">+30</button>
          <button class="player-track-btn" id="pNext" title="Next Episode (Shift+N)"><svg width="20" height="20" fill="currentColor" viewBox="0 0 24 24"><path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/></svg></button>
        </div>
      </div>
      <div class="player-right">
        <button class="player-btn" id="pQueue" title="Queue (Q)"><i class="ph ph-queue"></i><span class="queue-badge" id="queueBadge" style="display:none">0</span></button>
        <button class="player-btn" id="pBookmark" title="Bookmarks (B)"><svg width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M19 21l-7-5-7 5V5a2 2 0 012-2h10a2 2 0 012 2z"/></svg></button>
        <button class="player-btn" id="pSleep" title="Sleep Timer (Ctrl+M)"><svg width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><span class="sleep-badge" id="sleepBadge" style="display:none"></span></button>
        <button class="speed-btn" id="pSpeed" title="Speed (S)">1x</button>
        <div class="volume-control" title="Volume (M to mute, Shift+â†‘â†“ to adjust)">
          <button class="player-btn" id="pVolumeBtn" title="Mute/Unmute (M)"><svg width="18" height="18" fill="currentColor" viewBox="0 0 24 24" id="volumeIcon"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg></button>
          <input type="range" class="volume-slider" id="volumeSlider" min="0" max="100" value="100" title="Volume (Shift+â†‘â†“)">
        </div>
        <button class="icon-btn" id="pExpand" title="Fullscreen (F)"><svg width="16" height="16" fill="currentColor" viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg></button>
      </div>
    </div>
    <div class="player-progress">
      <span class="player-time" id="pCur">0:00</span>
      <div class="player-bar" id="pBar"><div class="player-fill" id="pFill"></div><div class="scrub-tooltip" id="scrubTooltip">0:00</div></div>
      <span class="player-time right" id="pDur">0:00</span>
    </div>
    <div class="player-panels" style="position: relative;">
      <!-- Speed Panel -->
      <div class="speed-panel" id="speedPanel">
        <div class="speed-panel-title">Playback Speed</div>
        <div class="speed-slider-container">
          <div class="speed-value" id="speedValue">1.00x</div>
          <input type="range" class="speed-slider" id="speedSlider" min="0.5" max="3" step="0.05" value="1">
        </div>
        <div class="speed-presets">
          <button class="speed-preset-btn" data-speed="0.75">0.75x</button>
          <button class="speed-preset-btn active" data-speed="1">1x</button>
          <button class="speed-preset-btn" data-speed="1.25">1.25x</button>
          <button class="speed-preset-btn" data-speed="1.5">1.5x</button>
          <button class="speed-preset-btn" data-speed="2">2x</button>
        </div>
      </div>
      <!-- Bookmarks Panel -->
      <div class="bookmarks-panel" id="bookmarksPanel">
        <div class="bookmarks-title">
          <span>Bookmarks</span>
          <button class="bookmark-add-btn" id="addBookmarkBtn" title="Add bookmark at current position">+</button>
        </div>
        <div id="bookmarksList"></div>
      </div>
      <!-- Queue Panel -->
      <div class="queue-panel" id="queuePanel">
        <div class="queue-title">
          <span>Up Next</span>
          <button class="queue-clear-btn" id="queueClearBtn" title="Clear queue">Clear</button>
        </div>
        <div class="queue-list" id="queueList"></div>
      </div>
    </div>
  </div>

  <!-- EXPANDED PLAYER -->
  <div class="expanded" id="expanded">
    <div class="expanded-header">
      <button class="icon-btn" id="expClose"><svg width="24" height="24" fill="none" stroke="currentColor" stroke-width="2"><path d="M6 9l6 6 6-6"/></svg></button>
      <span class="expanded-label">Now Playing</span>
      <div style="width:44px"></div>
    </div>
    <div class="expanded-body">
      <div class="swipe-container" id="swipeContainer">
        <img class="expanded-art" id="expArt" src="">
        <div class="swipe-indicator" id="swipeIndicator">
          <div class="swipe-indicator-content">
            <div class="swipe-indicator-icon" id="swipeIcon"><i class="ph ph-rewind"></i></div>
            <div class="swipe-indicator-text" id="swipeText">-15s</div>
            <div class="swipe-indicator-label" id="swipeLabel">Rewind</div>
          </div>
        </div>
      </div>
      <div class="expanded-info">
        <div class="expanded-title" id="expTitle"></div>
        <div class="expanded-show" id="expShow"></div>
      </div>
      <div class="expanded-progress">
        <div class="expanded-bar" id="expBar"><div class="expanded-fill" id="expFill"></div></div>
        <div class="expanded-times"><span id="expCur">0:00</span><span id="expDur">0:00</span></div>
      </div>
      <div class="expanded-controls">
        <button class="expanded-track-btn" id="expPrev" title="Previous Episode (Shift+P)"><svg width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M6 6h2v12H6V6zm3.5 6l8.5 6V6l-8.5 6z"/></svg></button>
        <button class="expanded-skip" id="expBack">-15</button>
        <button class="expanded-play" id="expPlay"><svg width="24" height="24" fill="currentColor" viewBox="0 0 24 24" id="expPlayIcon"><path d="M8 5v14l11-7z"/></svg></button>
        <button class="expanded-skip" id="expFwd">+30</button>
        <button class="expanded-track-btn" id="expNext" title="Next Episode (Shift+N)"><svg width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/></svg></button>
      </div>
      <div class="expanded-extra">
        <button class="expanded-btn" id="expSpeed">
          <i class="ph ph-gauge"></i>
          <span id="expSpeedLabel">1x</span>
        </button>
        <button class="expanded-btn" id="expSleep">
          <i class="ph ph-moon"></i>
          <span>Sleep</span>
        </button>
        <button class="expanded-btn" id="expBookmark">
          <i class="ph ph-bookmark-simple"></i>
          <span>Save</span>
        </button>
      </div>
    </div>
  </div>
</div>

<!-- MODAL -->
<div class="modal" id="modal">
  <div class="modal-box">
    <div class="modal-header">
      <h2>Add Feed</h2>
      <button class="modal-close" id="modalClose"><svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 5L5 15M5 5l10 10"/></svg></button>
    </div>
    <div class="modal-body">
      <div class="form-group">
        <label class="form-label">Feed URL</label>
        <div style="display:flex;gap:8px">
          <input type="url" class="form-input" id="fUrl" placeholder="https://..." style="flex:1">
          <button class="fetch-btn" id="fFetch" disabled>Fetch</button>
        </div>
        <div class="fetch-status" id="fStatus"></div>
      </div>
      <div class="form-group"><label class="form-label">Name</label><input type="text" class="form-input" id="fName" placeholder="Auto-detected from feed..."></div>
      <div class="form-group"><label class="form-label">Creator / Author</label><input type="text" class="form-input" id="fAuthor" placeholder="Auto-detected from feed..."></div>
      <div class="form-group"><label class="form-label">Type</label>
        <div class="type-sel">
          <button class="type-btn active" id="tNews"><span class="icon"><i class="ph ph-newspaper"></i></span><span class="label">News</span></button>
          <button class="type-btn" id="tPodcast"><span class="icon"><i class="ph ph-microphone-stage"></i></span><span class="label">Podcast</span></button>
        </div>
      </div>
      <div class="form-group"><label class="form-label">Category</label><input type="text" class="form-input" id="fCat" placeholder="Tech, News..."></div>
      <button class="submit-btn" id="fSubmit" disabled>Add Feed</button>
    </div>
  </div>
</div>
<div class="toast" id="toast"></div>

<!-- Edit Feed Modal -->
<div class="modal" id="editModal">
  <div class="modal-box">
    <div class="modal-header">
      <h2>Edit Feed</h2>
      <button class="modal-close" id="editModalClose"><svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 5L5 15M5 5l10 10"/></svg></button>
    </div>
    <div class="modal-body">
      <input type="hidden" id="editFeedId">
      <div class="form-group"><label class="form-label">Name</label><input type="text" class="form-input" id="editName" placeholder="Feed name"></div>
      <div class="form-group"><label class="form-label">Creator / Author</label><input type="text" class="form-input" id="editAuthor" placeholder="Author name"></div>
      <div class="form-group"><label class="form-label">Category</label><input type="text" class="form-input" id="editCat" placeholder="Tech, News..."></div>
      <div class="form-group"><label class="form-label">Header Image URL</label><input type="url" class="form-input" id="editImage" placeholder="https://example.com/image.jpg"></div>
      <div class="fetch-status" id="editStatus"></div>
      <button class="submit-btn" id="editSubmit">Save Changes</button>
    </div>
  </div>
</div>

<!-- Mobile Drawer -->
<div class="drawer-overlay" id="drawerOverlay"></div>
<div class="drawer" id="drawer">
  <div class="drawer-header">
    <div class="logo"><img src="https://storage.googleapis.com/intelechia-content/im/BRRST%20(2).png" alt="BRRST"></div>
    <button class="drawer-close" id="drawerClose"><svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 5L5 15M5 5l10 10"/></svg></button>
  </div>
  <div class="drawer-content" id="drawerContent"></div>
</div>

<!-- Sleep Timer Modal -->
<div class="sleep-timer-modal" id="sleepTimerModal">
  <div class="sleep-timer-box">
    <div class="sleep-timer-title"><svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg> Sleep Timer</div>
    <div id="sleepTimerContent">
      <div class="sleep-timer-presets" id="sleepPresets">
        <button class="sleep-preset" data-minutes="5">5 min</button>
        <button class="sleep-preset" data-minutes="10">10 min</button>
        <button class="sleep-preset" data-minutes="15">15 min</button>
        <button class="sleep-preset" data-minutes="30">30 min</button>
        <button class="sleep-preset" data-minutes="45">45 min</button>
        <button class="sleep-preset" data-minutes="60">60 min</button>
        <button class="sleep-preset" data-minutes="episode" style="grid-column: span 3">End of Episode</button>
      </div>
      <div class="sleep-custom">
        <input type="number" id="sleepCustomInput" placeholder="Custom minutes" min="1" max="999">
        <button id="sleepCustomBtn">Set</button>
      </div>
    </div>
    <div id="sleepTimerActive" class="sleep-timer-active" style="display:none">
      <div>
        <div style="font-size:12px;color:var(--text2);margin-bottom:4px">Stopping in</div>
        <div class="sleep-timer-countdown" id="sleepCountdown">00:00</div>
      </div>
      <button class="sleep-timer-cancel" id="sleepCancelBtn">Cancel</button>
    </div>
  </div>
</div>

<!-- Settings Modal -->
<div class="settings-modal" id="settingsModal">
  <div class="settings-box">
    <div class="settings-header">
      <h2><svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M12 15a3 3 0 100-6 3 3 0 000 6z"/><path d="M19.4 15a1.65 1.65 0 00.33 1.82l.06.06a2 2 0 010 2.83 2 2 0 01-2.83 0l-.06-.06a1.65 1.65 0 00-1.82-.33 1.65 1.65 0 00-1 1.51V21a2 2 0 01-2 2 2 2 0 01-2-2v-.09A1.65 1.65 0 009 19.4a1.65 1.65 0 00-1.82.33l-.06.06a2 2 0 01-2.83 0 2 2 0 010-2.83l.06-.06a1.65 1.65 0 00.33-1.82 1.65 1.65 0 00-1.51-1H3a2 2 0 01-2-2 2 2 0 012-2h.09A1.65 1.65 0 004.6 9a1.65 1.65 0 00-.33-1.82l-.06-.06a2 2 0 010-2.83 2 2 0 012.83 0l.06.06a1.65 1.65 0 001.82.33H9a1.65 1.65 0 001-1.51V3a2 2 0 012-2 2 2 0 012 2v.09a1.65 1.65 0 001 1.51 1.65 1.65 0 001.82-.33l.06-.06a2 2 0 012.83 0 2 2 0 010 2.83l-.06.06a1.65 1.65 0 00-.33 1.82V9a1.65 1.65 0 001.51 1H21a2 2 0 012 2 2 2 0 01-2 2h-.09a1.65 1.65 0 00-1.51 1z"/></svg> Settings</h2>
      <button class="settings-close" id="settingsClose"><svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 5L5 15M5 5l10 10"/></svg></button>
    </div>
    <div class="settings-body">
      <div class="settings-section">
        <div class="settings-section-title">Article Behavior</div>
        <div class="settings-item">
          <div>
            <div class="settings-item-label">Open links in new tab</div>
            <div class="settings-item-desc">When disabled, articles open in the current tab</div>
          </div>
          <label class="toggle-switch">
            <input type="checkbox" id="openLinksToggle" checked>
            <span class="toggle-slider"></span>
          </label>
        </div>
      </div>

      <div class="settings-section">
        <div class="settings-section-title">Activity Store</div>
        <div class="settings-item" style="flex-direction:column;align-items:stretch;gap:12px">
          <div id="activityStats" style="font-size:13px;color:var(--text2);padding:8px 12px;background:var(--bg2);border-radius:8px">
            <div style="display:flex;justify-content:space-between;margin-bottom:4px">
              <span>Total activities:</span>
              <span id="activityStatTotal">-</span>
            </div>
            <div style="display:flex;justify-content:space-between;margin-bottom:4px">
              <span>Snapshots:</span>
              <span id="activityStatSnapshots">-</span>
            </div>
            <div style="display:flex;justify-content:space-between">
              <span>Potential savings:</span>
              <span id="activityStatSavings">-</span>
            </div>
          </div>
          <div style="display:flex;gap:8px">
            <button class="submit-btn" id="refreshActivityStats" style="flex:1;padding:8px 12px;font-size:13px">
              <i class="ph ph-arrow-clockwise"></i> Refresh Stats
            </button>
            <button class="submit-btn" id="runActivityCleanup" style="flex:1;padding:8px 12px;font-size:13px;background:var(--accent2)">
              <i class="ph ph-broom"></i> Run Cleanup
            </button>
          </div>
          <div id="cleanupStatus" style="font-size:12px;color:var(--text2);text-align:center;display:none"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Snapshot/History Modal -->
<div class="modal" id="snapshotModal">
  <div class="modal-box" style="max-width:500px">
    <div class="modal-header">
      <h2><i class="ph ph-clock-counter-clockwise"></i> History Snapshots</h2>
      <button class="modal-close" id="snapshotModalClose"><svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 5L5 15M5 5l10 10"/></svg></button>
    </div>
    <div class="modal-body">
      <div class="snapshot-actions" style="display:flex;gap:8px;margin-bottom:16px">
        <button class="submit-btn" id="createSnapshotBtn" style="flex:1"><i class="ph ph-camera"></i> Create Snapshot</button>
      </div>
      <div class="snapshot-list" id="snapshotList">
        <div class="snapshot-empty" style="text-align:center;padding:32px;color:var(--text2)">
          <i class="ph ph-clock-counter-clockwise" style="font-size:48px;opacity:0.3"></i>
          <p style="margin-top:12px">No snapshots yet</p>
          <p style="font-size:13px">Create a snapshot to save your current state</p>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Podcast Search Modal -->
<div class="podcast-search-modal" id="podcastSearchModal">
  <div class="podcast-search-box">
    <div class="podcast-search-header">
      <h2><i class="ph ph-magnifying-glass"></i> Discover Podcasts</h2>
      <button class="podcast-search-close" id="podcastSearchClose"><svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 5L5 15M5 5l10 10"/></svg></button>
    </div>
    <div class="podcast-search-body">
      <div class="podcast-search-input-wrap">
        <input type="text" class="podcast-search-input" id="podcastSearchInput" placeholder="Search by name, author, or topic...">
        <button class="podcast-search-btn" id="podcastSearchBtn"><i class="ph ph-magnifying-glass"></i> Search</button>
      </div>
      <div id="podcastSearchStatus" class="podcast-search-status" style="display:none"></div>
      <div id="podcastSearchResults" class="podcast-search-results">
        <div class="podcast-search-empty">
          <i class="ph ph-microphone-stage"></i>
          <p>Search for podcasts to add to your library</p>
        </div>
      </div>
      <div class="podcast-search-powered">
        Powered by <a href="https://podcastindex.org" target="_blank" rel="noopener">PodcastIndex.org</a>
      </div>
    </div>
  </div>
</div>

<!-- Article Details Modal -->
<div class="article-modal" id="articleModal">
  <div class="article-modal-box">
    <div class="article-modal-header">
      <button class="article-modal-close" id="articleModalClose"><svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 5L5 15M5 5l10 10"/></svg></button>
    </div>
    <div class="article-modal-body" id="articleModalBody">
      <!-- Content populated by JS -->
    </div>
  </div>
</div>

<!-- Audio element for actual playback -->
<audio id="audioPlayer" preload="metadata"></audio>

<script>
(function() {
  'use strict';

  // === PERFORMANCE MONITORING ===
  const Perf = {
    marks: {},
    measures: [],

    mark(name) {
      this.marks[name] = performance.now();
    },

    measure(name, startMark) {
      const end = performance.now();
      const start = this.marks[startMark] || end;
      const duration = end - start;
      this.measures.push({ name, duration, timestamp: Date.now() });
      if (duration > 100) console.log(`[Perf] ${name}: ${duration.toFixed(1)}ms`);
      return duration;
    },

    // Track scroll performance
    scrollFPS: { frames: 0, lastTime: 0, fps: 60 },

    trackScroll(container) {
      let ticking = false;
      container.addEventListener('scroll', () => {
        if (!ticking) {
          requestAnimationFrame(() => {
            this.scrollFPS.frames++;
            const now = performance.now();
            if (now - this.scrollFPS.lastTime >= 1000) {
              this.scrollFPS.fps = this.scrollFPS.frames;
              this.scrollFPS.frames = 0;
              this.scrollFPS.lastTime = now;
            }
            ticking = false;
          });
          ticking = true;
        }
      }, { passive: true });
    }
  };

  // === IMAGE CACHE ===
  const ImageCache = {
    cache: new Map(),
    maxSize: 100, // Max cached images

    get(url) {
      const entry = this.cache.get(url);
      if (entry) {
        entry.lastAccess = Date.now();
        return entry.loaded;
      }
      return false;
    },

    set(url) {
      if (this.cache.size >= this.maxSize) {
        // Evict least recently accessed
        let oldest = null;
        let oldestTime = Infinity;
        for (const [key, val] of this.cache) {
          if (val.lastAccess < oldestTime) {
            oldestTime = val.lastAccess;
            oldest = key;
          }
        }
        if (oldest) this.cache.delete(oldest);
      }
      this.cache.set(url, { loaded: true, lastAccess: Date.now() });
    },

    preload(urls) {
      urls.forEach(url => {
        if (url && !this.get(url)) {
          const img = new Image();
          img.onload = () => this.set(url);
          img.src = url;
        }
      });
    }
  };

  // === VIRTUAL LIST STATE ===
  const VirtualList = {
    podcast: { rendered: 0, batchSize: 30, total: 0, loading: false },
    news: { rendered: 0, batchSize: 30, total: 0, loading: false },
    feed: { rendered: 0, batchSize: 30, total: 0, loading: false }
  };

  // === GUID GENERATION UTILITIES ===
  // Generates stable, deterministic GUIDs based on content
  // These persist across deletion/re-addition of feeds
  const GUID = {
    // FNV-1a hash - produces consistent 32-bit hash
    hash32(str) {
      let h = 0x811c9dc5;
      for (let i = 0; i < str.length; i++) {
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 0x01000193);
      }
      return h >>> 0;
    },

    // Generate 64-bit hash as two 32-bit values combined
    hash64(str) {
      const h1 = this.hash32(str);
      const h2 = this.hash32(str + '_salt_' + h1);
      return h1.toString(16).padStart(8, '0') + h2.toString(16).padStart(8, '0');
    },

    // Normalize URL for consistent hashing
    normalizeUrl(url) {
      try {
        const u = new URL(url);
        // Remove trailing slashes, normalize to lowercase host
        return (u.protocol + '//' + u.host.toLowerCase() + u.pathname.replace(/\/+$/, '') + u.search).toLowerCase();
      } catch {
        return url.toLowerCase().trim();
      }
    },

    // Generate feed GUID from URL - same URL always = same GUID
    forFeed(feedUrl) {
      const normalized = this.normalizeUrl(feedUrl);
      return 'feed_' + this.hash64(normalized);
    },

    // Generate article GUID - stable across feed re-adds
    // Uses: feedUrl + (link OR title+pubDate)
    forArticle(feedUrl, link, title, pubDate) {
      const feedPart = this.normalizeUrl(feedUrl);
      // Prefer link as it's most stable, fallback to title+date
      const contentPart = link
        ? this.normalizeUrl(link)
        : (title + '|' + (pubDate || '')).toLowerCase();
      return 'art_' + this.hash64(feedPart + '::' + contentPart);
    },

    // Generate episode GUID - stable across feed re-adds
    // Uses: feedUrl + (audioUrl OR title+pubDate)
    forEpisode(feedUrl, audioUrl, title, pubDate) {
      const feedPart = this.normalizeUrl(feedUrl);
      // Prefer audioUrl as it's unique per episode, fallback to title+date
      const contentPart = audioUrl
        ? this.normalizeUrl(audioUrl)
        : (title + '|' + (pubDate || '')).toLowerCase();
      return 'ep_' + this.hash64(feedPart + '::' + contentPart);
    }
  };

  // === MEMORY & USER BEHAVIOR SYSTEM ===
  // Optimized tracking: only sync meaningful content interactions to Xano
  // Ephemeral UI state (view changes, filters) stays local only
  const Mem = {
    pending: [],
    session: 's_' + Date.now(),
    endpoint: 'https://xvkq-pq7i-idtl.n7d.xano.io/api:Hj4C6PGO/activity-post',
    syncInterval: null,
    syncing: false,

    // Actions that represent meaningful content interactions - sync to DB
    SYNC_ACTIONS: new Set([
      'article_opened',      // User engaged with article content
      'play_pressed',        // Started listening to episode
      'pause_pressed',       // Paused playback (context for session)
      'episode_completed',   // Finished an episode
      'episode_exited',      // Left episode (captures exit point)
      'playback_progress',   // Significant progress updates
      'returned_to_episode', // Resumption patterns
      'seek',                // Intentional navigation within content
      'bookmark_added',      // User marked important moment
      'download_completed',  // Content acquisition
      'download_removed',    // Content removal
      'feed_added',          // Subscription change
      'feed_removed',        // Subscription change
      'feed_updated'         // Feed metadata change (name, tags, category)
    ]),

    // Actions that stay local only - UI state, preferences, filtering
    // view_changed, feed_opened, feed_filter_changed, category_changed,
    // tag_filter_changed, podcast_category_changed, podcast_tag_filter_changed,
    // speed_changed, swipe_seek

    // Extract stable content_url from content
    getContentUrl(data) {
      if (data.link) return data.link;
      if (data.audioUrl) return data.audioUrl;
      if (data.url) return data.url;
      // For episodes/articles, try to find the content
      if (data.episodeId) {
        const ep = state.podcasts.find(p => p.id === data.episodeId);
        if (ep) return ep.audioUrl || ep.link;
      }
      if (data.articleId) {
        const art = state.articles.find(a => a.id === data.articleId);
        if (art) return art.link;
      }
      return null;
    },

    // Check if action should be synced to remote DB
    shouldSync(action) {
      return this.SYNC_ACTIONS.has(action);
    },

    log(action, target, data = {}) {
      const content_url = this.getContentUrl(data);
      const shouldSync = this.shouldSync(action);
      const m = {
        id: 'm_' + Date.now() + '_' + Math.random().toString(36).substr(2,4),
        ts: new Date().toISOString(),
        action,
        target,
        content_url,
        session: this.session,
        ctx: { view: state.view, tab: state.tab },
        local_only: !shouldSync,
        ...data
      };

      // Always store locally for history/stats
      try {
        const a = JSON.parse(localStorage.getItem('mem') || '[]');
        a.push(m);
        // Keep more local-only events (they're cheap), fewer synced ones cached
        if (a.length > 500) a.splice(0, a.length - 500);
        localStorage.setItem('mem', JSON.stringify(a));
      } catch(e) {}

      // Only queue for remote sync if it's a meaningful content interaction
      if (shouldSync) {
        // For critical feed operations, use beacon for guaranteed delivery
        if (action === 'feed_added' || action === 'feed_removed') {
          this.syncWithBeacon(m);
        } else {
          this.pending.push(m);
          this._savePendingQueue(); // Persist in case of page refresh
          this.sync();
        }
      }
    },

    // Sync critical activity using sendBeacon - guaranteed even during page unload
    syncWithBeacon(m) {
      if (!this.endpoint) return false;

      const { id, ts, session, action, target, content_url, ctx, local_only, ...rest } = m;
      const payload = {
        session_id: session,
        action,
        content_url: content_url || null,
        data: {
          target,
          ctx,
          ts,
          ...rest
        }
      };

      // Use text/plain to avoid CORS preflight (server accepts JSON regardless of Content-Type)
      const blob = new Blob([JSON.stringify(payload)], { type: 'text/plain' });
      const success = navigator.sendBeacon(this.endpoint, blob);

      if (success) {
        console.log('[Mem] Beacon sent', action, 'activity');

        // Trigger immediate cross-tab/cross-device sync for feed changes
        if (action === 'feed_added' || action === 'feed_removed' || action === 'feed_updated') {
          try {
            localStorage.setItem('feed_sync_trigger', Date.now().toString());
            console.log('[Mem] Set cross-tab sync trigger for', action);
          } catch(e) {}
        }
      } else {
        // Fallback: queue for regular sync
        console.warn('[Mem] Beacon failed for', action, ', queuing for retry');
        this.pending.push(m);
        this._savePendingQueue(); // Persist in case of page refresh
        this.sync();
      }
      return success;
    },

    async sync() {
      if (!this.endpoint || !this.pending.length || this.syncing) return;
      this.syncing = true;

      while (this.pending.length > 0) {
        const m = this.pending[0];
        try {
          // POST each activity individually (append-only)
          const { id, ts, session, action, target, content_url, ctx, local_only, ...rest } = m;
          const response = await fetch(this.endpoint, {
            method: 'POST',
            body: JSON.stringify({
              session_id: session,
              action,
              content_url: content_url || null,
              data: {
                target,
                ctx,
                ts,
                ...rest
              }
            })
          });

          // Validate response before marking as synced
          if (!response.ok) {
            console.warn('[Mem] Activity sync failed with status:', response.status, action);
            break; // Keep item in queue for retry
          }

          this.pending.shift(); // Remove successfully synced item
          this._savePendingQueue(); // Persist queue state

          // Trigger immediate cross-tab/cross-device sync for feed changes
          if (action === 'feed_added' || action === 'feed_removed' || action === 'feed_updated') {
            try {
              localStorage.setItem('feed_sync_trigger', Date.now().toString());
              console.log('[Mem] Set cross-tab sync trigger for', action);
            } catch(e) {}
          }
        } catch(e) {
          // On failure, stop and retry later
          console.warn('[Mem] Activity sync failed, will retry:', e);
          break;
        }
      }
      this.syncing = false;
    },

    setEndpoint(u) {
      this.endpoint = u;
      // Start periodic sync every 30 seconds
      if (this.syncInterval) clearInterval(this.syncInterval);
      if (u) {
        this.syncInterval = setInterval(() => this.sync(), 30000);
      }
      this.sync();
    },

    // Persist pending queue to localStorage (survives page refresh)
    _savePendingQueue() {
      try {
        if (this.pending.length > 0) {
          localStorage.setItem('mem_pending', JSON.stringify(this.pending));
        } else {
          localStorage.removeItem('mem_pending');
        }
      } catch (e) {
        console.warn('[Mem] Failed to save pending queue:', e);
      }
    },

    // Load pending queue from localStorage
    _loadPendingQueue() {
      try {
        const saved = localStorage.getItem('mem_pending');
        if (saved) {
          const items = JSON.parse(saved);
          if (Array.isArray(items) && items.length > 0) {
            this.pending = items;
            console.log('[Mem] Restored', items.length, 'pending activities from previous session');
          }
        }
      } catch (e) {
        console.warn('[Mem] Failed to load pending queue:', e);
      }
    },

    init() {
      // Load any pending activities from previous session
      this._loadPendingQueue();

      // Start periodic sync on load
      if (this.endpoint) {
        this.syncInterval = setInterval(() => this.sync(), 30000);
        // Immediately sync any restored pending items
        if (this.pending.length > 0) {
          setTimeout(() => this.sync(), 1000);
        }
      }
    },

    getLocal() {
      try { return JSON.parse(localStorage.getItem('mem') || '[]'); }
      catch(e) { return []; }
    },

    // Get only synced (meaningful) events
    getSynced() {
      return this.getLocal().filter(l => !l.local_only);
    },

    // Get only local (ephemeral) events
    getEphemeral() {
      return this.getLocal().filter(l => l.local_only);
    },

    // Get aggregated behavior stats
    getStats() {
      const logs = this.getLocal();
      const syncedLogs = logs.filter(l => !l.local_only);
      const stats = {
        totalEvents: logs.length,
        syncedEvents: syncedLogs.length,
        localOnlyEvents: logs.length - syncedLogs.length,
        sessions: [...new Set(logs.map(l => l.session))].length,
        articleReads: logs.filter(l => l.action === 'article_opened').length,
        episodePlays: logs.filter(l => l.action === 'play_pressed').length,
        searches: logs.filter(l => l.action === 'search').length,
        tagFilters: logs.filter(l => l.action === 'tag_filter_changed').length,
        byAction: {},
        byTag: {}
      };

      // Count by action type
      logs.forEach(l => {
        stats.byAction[l.action] = (stats.byAction[l.action] || 0) + 1;
      });

      // Count tag filter usage
      logs.filter(l => l.action === 'tag_filter_changed').forEach(l => {
        const tag = l.target?.replace('tag_', '') || 'unknown';
        stats.byTag[tag] = (stats.byTag[tag] || 0) + 1;
      });

      return stats;
    },

    // Clear all local logs
    clear() {
      localStorage.removeItem('mem');
      this.pending = [];
    },

    // Export all behavior data for API sync
    exportForSync() {
      return {
        logs: this.getLocal(),
        stats: this.getStats(),
        feeds: state.feeds.map(f => ({
          id: f.id,
          name: f.name,
          type: f.type,
          tags: f.tags,
          category: f.category
        })),
        preferences: {
          viewPrefs: state.viewPrefs,
          bookmarks: Object.keys(state.bookmarks).length,
          progress: Object.keys(state.progress).length
        },
        session: this.session,
        exportedAt: new Date().toISOString()
      };
    }
  };
  window.Memory = Mem;

  // === FEEDING ACTIVITY SYNC ===
  // Syncs all feeding-related activities (add, edit, remove) to dedicated activity-post endpoint
  const FeedingActivity = {
    endpoint: 'https://xvkq-pq7i-idtl.n7d.xano.io/api:Hj4C6PGO/activity-post',
    pending: [],
    syncing: false,

    // Log and sync a feeding activity
    log(action, feedData) {
      const activity = {
        id: 'fa_' + Date.now() + '_' + Math.random().toString(36).substr(2, 4),
        ts: new Date().toISOString(),
        session: Mem.session,
        action,
        ...feedData
      };

      console.log('[FeedingActivity] Logging:', action, feedData.feedId || feedData.url);

      // Use beacon for guaranteed delivery
      this.syncWithBeacon(activity);
    },

    // Sync using sendBeacon for guaranteed delivery
    syncWithBeacon(activity) {
      if (!this.endpoint) return false;

      const payload = {
        session_id: activity.session,
        action: activity.action,
        timestamp: activity.ts,
        data: {
          feedId: activity.feedId,
          url: activity.url,
          name: activity.name,
          type: activity.type,
          category: activity.category,
          author: activity.author,
          image: activity.image,
          tags: activity.tags,
          description: activity.description
        }
      };

      // Use application/json for proper parsing by Xano
      const blob = new Blob([JSON.stringify(payload)], { type: 'application/json' });
      const success = navigator.sendBeacon(this.endpoint, blob);

      if (success) {
        console.log('[FeedingActivity] Beacon sent:', activity.action);
      } else {
        // Fallback: queue for fetch-based sync
        console.warn('[FeedingActivity] Beacon failed, queuing for retry');
        this.pending.push(activity);
        this._savePendingQueue();
        this.sync();
      }
      return success;
    },

    // Fallback sync using fetch
    async sync() {
      if (!this.endpoint || !this.pending.length || this.syncing) return;
      this.syncing = true;

      while (this.pending.length > 0) {
        const activity = this.pending[0];
        try {
          const payload = {
            session_id: activity.session,
            action: activity.action,
            timestamp: activity.ts,
            data: {
              feedId: activity.feedId,
              url: activity.url,
              name: activity.name,
              type: activity.type,
              category: activity.category,
              author: activity.author,
              image: activity.image,
              tags: activity.tags,
              description: activity.description
            }
          };

          const response = await fetch(this.endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });

          if (!response.ok) {
            console.warn('[FeedingActivity] Sync failed:', response.status);
            break;
          }

          this.pending.shift();
          this._savePendingQueue();
          console.log('[FeedingActivity] Synced:', activity.action);
        } catch (e) {
          console.warn('[FeedingActivity] Sync error:', e);
          break;
        }
      }
      this.syncing = false;
    },

    _savePendingQueue() {
      try {
        if (this.pending.length > 0) {
          localStorage.setItem('feeding_activity_pending', JSON.stringify(this.pending));
        } else {
          localStorage.removeItem('feeding_activity_pending');
        }
      } catch (e) {}
    },

    _loadPendingQueue() {
      try {
        const saved = localStorage.getItem('feeding_activity_pending');
        if (saved) {
          this.pending = JSON.parse(saved) || [];
          if (this.pending.length > 0) {
            console.log('[FeedingActivity] Restored', this.pending.length, 'pending activities');
          }
        }
      } catch (e) {}
    },

    init() {
      this._loadPendingQueue();
      if (this.pending.length > 0) {
        setTimeout(() => this.sync(), 2000);
      }
    }
  };
  window.FeedingActivity = FeedingActivity;

  // === STATE SYNC - Activity-Only Storage ===
  // Everything stored as activities: both state snapshots AND individual actions
  const StateSync = {
    endpoint: 'https://xvkq-pq7i-idtl.n7d.xano.io/api:Hj4C6PGO/activity-post',
    syncing: false,
    syncTimeout: null,
    syncQueue: null,
    snapshotInterval: 10, // Save full snapshot every 10 changes
    changeCounter: 0,
    lastSyncedFeeds: null, // Track what we last synced to detect changes

    // Sync using sendBeacon - guaranteed to complete even if page is closing
    // This is critical for feed additions/removals to ensure cross-device sync
    syncWithBeacon(stateData) {
      if (!this.endpoint) return false;

      const payload = {
        session_id: Mem.session,
        action: 'state_snapshot',
        content_url: null,
        data: {
          feeds: stateData.feeds,
          progress: stateData.progress,
          bookmarks: stateData.bookmarks,
          feedLastViewed: stateData.feedLastViewed,
          ctx: { view: state.view, tab: state.tab },
          ts: new Date().toISOString()
        }
      };

      // sendBeacon guarantees delivery even during page unload
      // Use text/plain to avoid CORS preflight (server accepts JSON regardless of Content-Type)
      const blob = new Blob([JSON.stringify(payload)], { type: 'text/plain' });
      const success = navigator.sendBeacon(this.endpoint, blob);

      if (success) {
        this.changeCounter = 0;
        this.lastSyncedFeeds = JSON.stringify(stateData.feeds.map(f => f.url).sort());
        console.log('[StateSync] Beacon sent state snapshot with', stateData.feeds.length, 'feeds');
      } else {
        console.warn('[StateSync] Beacon failed, falling back to fetch');
        // Fallback to regular fetch if beacon fails (rare)
        this._doSync();
      }
      return success;
    },

    // Fetch state by reconstructing from activity log
    async fetchState() {
      if (!this.endpoint) return null;

      try {
        const response = await fetch(this.endpoint);

        if (!response.ok) {
          console.warn('[StateSync] Server returned', response.status);
          return null;
        }

        const rawData = await response.json();
        console.log('[StateSync] Fetched activities:', rawData);

        if (!rawData || !rawData.items || !Array.isArray(rawData.items)) {
          console.warn('[StateSync] Invalid response format');
          return null;
        }

        // Sort by timestamp
        const activities = rawData.items.sort((a, b) =>
          new Date(a.created_at || 0) - new Date(b.created_at || 0)
        );

        // Parse data field if it's a JSON string (Xano stores as text)
        for (const item of activities) {
          if (item.data && typeof item.data === 'string') {
            try {
              item.data = JSON.parse(item.data);
            } catch (e) {
              console.warn('[StateSync] Failed to parse data for activity:', item.action, e);
            }
          }

          // FIX: Handle case where entire payload was stored in data field
          // This happens when sendBeacon sends as text/plain and Xano stores whole body in 'data'
          // The structure becomes: item.data = { action, data: { feeds: [...] }, created_at }
          // We need to unwrap it to: item.action, item.data = { feeds: [...] }
          if (!item.action && item.data && item.data.action) {
            item.action = item.data.action;
            item.created_at = item.data.created_at || item.created_at;
            item.data = item.data.data; // Unwrap nested data
            console.log('[StateSync] Unwrapped nested payload, action:', item.action);
          }
        }

        // Strategy: Find most recent state snapshot, then apply subsequent actions
        let baseState = null;
        let baseIndex = -1;

        // Look for most recent state_snapshot
        for (let i = activities.length - 1; i >= 0; i--) {
          const item = activities[i];
          if (item.action === 'state_snapshot' && item.data && item.data.feeds) {
            baseState = {
              feeds: item.data.feeds || [],
              progress: item.data.progress || {},
              bookmarks: item.data.bookmarks || {},
              feedLastViewed: item.data.feedLastViewed || {}
            };
            baseIndex = i;
            console.log('[StateSync] Found state snapshot from', item.created_at, 'with', baseState.feeds.length, 'feeds');
            break;
          }
        }

        // If no snapshot found, start from empty state
        if (!baseState) {
          baseState = {
            feeds: [],
            progress: {},
            bookmarks: {},
            feedLastViewed: {}
          };
          console.log('[StateSync] No snapshot found, reconstructing from scratch');
        }

        // Apply all actions after the snapshot
        const actionsToApply = activities.slice(baseIndex + 1);
        console.log('[StateSync] Applying', actionsToApply.length, 'actions after snapshot');

        for (const item of actionsToApply) {
          if (!item.action || !item.data) continue;

          switch (item.action) {
            case 'feed_added':
              const url = item.data.url || item.content_url;
              if (url && !baseState.feeds.find(f => f.url === url)) {
                baseState.feeds.push({
                  id: item.data.target || GUID.forFeed(url),
                  url: url,
                  name: item.data.name || 'Unknown',
                  type: item.data.type || 'news',
                  author: item.data.author || '',
                  category: item.data.category || 'Uncategorized',
                  tags: item.data.tags || []
                });
                console.log('[StateSync] Applied feed_added:', item.data.name);
              }
              break;

            case 'feed_removed':
              const removeUrl = item.data.url || item.content_url;
              if (removeUrl) {
                const beforeCount = baseState.feeds.length;
                baseState.feeds = baseState.feeds.filter(f => f.url !== removeUrl);
                if (baseState.feeds.length < beforeCount) {
                  console.log('[StateSync] Applied feed_removed:', item.data.name || removeUrl);
                }
              }
              break;

            case 'feed_updated':
              const updateUrl = item.data.url || item.content_url;
              if (updateUrl) {
                const existingFeed = baseState.feeds.find(f => f.url === updateUrl);
                if (existingFeed) {
                  if (item.data.name) existingFeed.name = item.data.name;
                  if (item.data.tags) existingFeed.tags = item.data.tags;
                  if (item.data.category) existingFeed.category = item.data.category;
                  if (item.data.description !== undefined) existingFeed.description = item.data.description;
                  if (item.data.image !== undefined) existingFeed.image = item.data.image;
                  console.log('[StateSync] Applied feed_updated:', item.data.name || updateUrl);
                }
              }
              break;

            case 'article_bookmarked':
            case 'podcast_bookmarked':
              if (item.data.target) {
                baseState.bookmarks[item.data.target] = true;
              }
              break;

            case 'article_unbookmarked':
            case 'podcast_unbookmarked':
              if (item.data.target) {
                delete baseState.bookmarks[item.data.target];
              }
              break;

            case 'progress_updated':
              if (item.data.target && item.data.progress !== undefined) {
                baseState.progress[item.data.target] = item.data.progress;
              }
              break;
          }
        }

        console.log('[StateSync] Reconstructed state:', {
          feeds: baseState.feeds.length,
          bookmarks: Object.keys(baseState.bookmarks).length,
          progress: Object.keys(baseState.progress).length
        });

        return { data: baseState };

      } catch (e) {
        console.warn('[StateSync] Fetch failed:', e.message);
        return null;
      }
    },

    // Save state as activity
    async saveState(stateData) {
      if (!this.endpoint) return false;

      this.syncQueue = stateData;
      this.changeCounter++;

      if (this.syncTimeout) clearTimeout(this.syncTimeout);

      // Debounce: wait 2 seconds before syncing
      this.syncTimeout = setTimeout(() => this._doSync(), 2000);
      return true;
    },

    // Actually perform the sync
    async _doSync() {
      if (this.syncing || !this.syncQueue) return;
      this.syncing = true;

      const stateData = this.syncQueue;
      this.syncQueue = null;

      try {
        // Every N changes, save a full state snapshot
        // Otherwise, individual actions are logged by Mem
        const shouldSnapshot = this.changeCounter >= this.snapshotInterval;

        if (shouldSnapshot) {
          const payload = {
            session_id: Mem.session,
            action: 'state_snapshot',
            content_url: null,
            data: {
              feeds: stateData.feeds,
              progress: stateData.progress,
              bookmarks: stateData.bookmarks,
              feedLastViewed: stateData.feedLastViewed,
              ctx: { view: state.view, tab: state.tab },
              ts: new Date().toISOString()
            }
          };

          const response = await fetch(this.endpoint, {
            method: 'POST',
            body: JSON.stringify(payload)
          });

          if (response.ok) {
            this.changeCounter = 0; // Reset counter
            console.log('[StateSync] Saved state snapshot with', stateData.feeds.length, 'feeds');

            // Trigger cleanup after successful snapshot (non-blocking)
            setTimeout(async () => {
              try {
                if (window.ActivityCleanup) {
                  const stats = await ActivityCleanup.getStats();
                  const totalPotential =
                    stats.potentialSavings.duplicateProgress +
                    stats.potentialSavings.oldEphemeral +
                    stats.potentialSavings.redundantPairs;

                  // Only run cleanup if there's significant savings (>20 activities)
                  if (totalPotential > 20) {
                    console.log('[StateSync] Running post-snapshot cleanup...');
                    await ActivityCleanup.consolidateProgress();
                    await ActivityCleanup.pruneOldSessions(7);
                  }
                }
              } catch (e) {
                console.warn('[StateSync] Post-snapshot cleanup failed:', e.message);
              }
            }, 5000); // Wait 5 seconds after snapshot before cleanup
          } else {
            console.warn('[StateSync] Snapshot failed:', response.status, await response.text());
          }
        } else {
          console.log('[StateSync] Skipping snapshot (', this.changeCounter, '/', this.snapshotInterval, 'changes)');
        }
      } catch (e) {
        console.warn('[StateSync] Sync error:', e.message);
      }
      this.syncing = false;
    },

    // Force immediate snapshot - uses beacon for reliability during page unload
    flushSync() {
      if (this.syncTimeout) {
        clearTimeout(this.syncTimeout);
        this.syncTimeout = null;
      }
      if (this.syncQueue) {
        // Use beacon for guaranteed delivery during page unload
        this.syncWithBeacon(this.syncQueue);
        this.syncQueue = null;
      }
    }
  };
  window.StateSync = StateSync;

  // === FEED SCANNER - Detect new feeds from other devices ===
  const FeedScanner = {
    baseScanInterval: 30000, // Base scan interval (30 seconds)
    maxScanInterval: 300000, // Max scan interval (5 minutes)
    currentScanInterval: 30000, // Current scan interval (starts at base)
    intervalId: null,
    scanning: false,
    lastScanTime: 0,
    minScanGap: 10000, // Minimum 10 seconds between scans
    consecutiveNoChanges: 0, // Track consecutive scans with no changes

    // Start periodic scanning
    start() {
      if (this.intervalId) return;

      console.log('[FeedScanner] Starting periodic scan (every', this.currentScanInterval / 1000, 'seconds)');

      // Do initial scan after delay (let app fully load and initial sync complete)
      setTimeout(() => this.scan(), 10000);

      // Set up periodic scanning with current interval
      this.intervalId = setInterval(() => this.scan(), this.currentScanInterval);

      // Scan when tab becomes visible (user returns to app)
      document.addEventListener('visibilitychange', this._onVisibilityChange.bind(this));

      // Listen for cross-tab feed sync triggers (immediate sync when feed added/removed)
      window.addEventListener('storage', this._onStorageChange.bind(this));
    },

    // Update scan interval with exponential backoff
    _updateScanInterval(newInterval) {
      if (newInterval === this.currentScanInterval) return;

      this.currentScanInterval = newInterval;

      // Restart interval with new timing
      if (this.intervalId) {
        clearInterval(this.intervalId);
        this.intervalId = setInterval(() => this.scan(), this.currentScanInterval);
        console.log('[FeedScanner] Updated scan interval to', this.currentScanInterval / 1000, 'seconds');
      }
    },

    // Stop scanning
    stop() {
      if (this.intervalId) {
        clearInterval(this.intervalId);
        this.intervalId = null;
      }
      document.removeEventListener('visibilitychange', this._onVisibilityChange.bind(this));
      window.removeEventListener('storage', this._onStorageChange.bind(this));
      console.log('[FeedScanner] Stopped');
    },

    // Handle visibility change - scan when user returns to tab
    _onVisibilityChange() {
      if (document.visibilityState === 'visible') {
        // Only scan if enough time has passed since last scan
        const timeSinceLastScan = Date.now() - this.lastScanTime;
        if (timeSinceLastScan > this.minScanGap) {
          console.log('[FeedScanner] Tab visible, checking for new feeds...');
          this.scan();
        }
      }
    },

    // Handle storage change - scan immediately when feed sync trigger is set
    _onStorageChange(e) {
      if (e.key === 'feed_sync_trigger') {
        // Another tab/window synced a feed change, scan immediately
        const timeSinceLastScan = Date.now() - this.lastScanTime;
        if (timeSinceLastScan > this.minScanGap) {
          console.log('[FeedScanner] Cross-tab feed sync detected, scanning immediately...');
          // Reset backoff since we know a change occurred
          this.consecutiveNoChanges = 0;
          this._updateScanInterval(this.baseScanInterval);
          this.scan();
        }
      }
    },

    // Scan for new feeds from the server
    async scan() {
      if (this.scanning) return;
      if (!StateSync.endpoint) return;

      this.scanning = true;
      this.lastScanTime = Date.now();

      try {
        const serverState = await StateSync.fetchState();

        if (!serverState || !serverState.data || !serverState.data.feeds) {
          this.scanning = false;
          return;
        }

        const serverFeeds = serverState.data.feeds;
        const localFeedUrls = new Set(state.feeds.map(f => f.url));
        const serverFeedUrls = new Set(serverFeeds.map(f => f.url));

        // Find feeds on server that we don't have locally
        const newFeeds = serverFeeds.filter(sf => !localFeedUrls.has(sf.url));

        // Find feeds we have locally that aren't on server yet
        // IMPORTANT: Never delete local feeds - instead re-sync them to server
        // Local device is authoritative for its own feeds
        const localOnlyFeeds = state.feeds.filter(lf => !serverFeedUrls.has(lf.url));

        // Re-sync local-only feeds to server (they may have failed to sync initially)
        for (const localFeed of localOnlyFeeds) {
          console.log('[FeedScanner] Re-syncing local feed to server:', localFeed.name || localFeed.url);
          Mem.log('feed_added', localFeed.id, {
            url: localFeed.url,
            name: localFeed.name || 'Loading...',
            type: localFeed.type || 'news',
            category: localFeed.category || 'Uncategorized',
            author: localFeed.author || ''
          });
        }

        if (newFeeds.length === 0 && localOnlyFeeds.length === 0) {
          // Also sync progress and bookmarks even if no feed changes
          const hasProgressChanges = this._mergeProgress(serverState.data.progress);
          const hasBookmarkChanges = this._mergeBookmarks(serverState.data.bookmarks);

          if (hasProgressChanges || hasBookmarkChanges) {
            save();
          }

          // No feed changes detected - apply exponential backoff
          this.consecutiveNoChanges++;
          const newInterval = Math.min(
            this.baseScanInterval * Math.pow(2, this.consecutiveNoChanges),
            this.maxScanInterval
          );
          this._updateScanInterval(newInterval);

          this.scanning = false;
          return;
        }

        console.log('[FeedScanner] Found', newFeeds.length, 'new feeds from server,', localOnlyFeeds.length, 'local feeds to re-sync');

        // Add new feeds from other devices
        for (const serverFeed of newFeeds) {
          console.log('[FeedScanner] Adding new feed from other device:', serverFeed.name || serverFeed.url);

          // Create local feed object
          const feed = {
            id: serverFeed.id || GUID.forFeed(serverFeed.url),
            url: serverFeed.url,
            name: serverFeed.name || 'Loading...',
            type: serverFeed.type || 'news',
            category: serverFeed.category || 'Uncategorized',
            image: serverFeed.image || '',
            author: serverFeed.author || '',
            unread: 0,
            tags: serverFeed.tags || [],
            description: serverFeed.description || ''
          };

          // Add to state without triggering another sync (it's already on server)
          state.feeds.push(feed);
          state.categories.add(feed.category);

          // Fetch content for the new feed
          try {
            await fetchAndParseFeed(feed);
            console.log('[FeedScanner] Fetched content for:', feed.name);
          } catch (e) {
            console.warn('[FeedScanner] Failed to fetch content for:', feed.name, e.message);
          }
        }

        // Update existing feeds with metadata changes from server
        let updatedFeeds = 0;
        for (const serverFeed of serverFeeds) {
          const localFeed = state.feeds.find(f => f.url === serverFeed.url);
          if (localFeed) {
            let changed = false;
            if (serverFeed.name && localFeed.name !== serverFeed.name) {
              localFeed.name = serverFeed.name;
              changed = true;
            }
            if (serverFeed.tags && JSON.stringify(localFeed.tags) !== JSON.stringify(serverFeed.tags)) {
              localFeed.tags = serverFeed.tags;
              changed = true;
            }
            if (serverFeed.category && localFeed.category !== serverFeed.category) {
              localFeed.category = serverFeed.category;
              changed = true;
            }
            if (serverFeed.description !== undefined && localFeed.description !== serverFeed.description) {
              localFeed.description = serverFeed.description;
              changed = true;
            }
            if (serverFeed.image !== undefined && localFeed.image !== serverFeed.image) {
              localFeed.image = serverFeed.image;
              changed = true;
            }
            if (changed) {
              updatedFeeds++;
              console.log('[FeedScanner] Updated metadata for feed:', localFeed.name);
            }
          }
        }

        // Merge progress and bookmarks
        this._mergeProgress(serverState.data.progress);
        this._mergeBookmarks(serverState.data.bookmarks);

        // Save locally (but don't trigger server sync since data came from server)
        localStorage.setItem('feedr2', JSON.stringify(state));

        // Re-render UI to show changes
        if (newFeeds.length > 0 || localOnlyFeeds.length > 0 || updatedFeeds > 0) {
          renderNewsSources();
          renderPodcastSources();
          renderCategories();
          renderTagFilters();
          renderNews();
          if (state.view === 'podcasts') {
            renderPodcasts();
            renderPodcastInbox();
          }
          if (state.view === 'all') renderAll();
        }

        // Exponential backoff: adjust scan interval based on whether changes were detected
        const anyChanges = newFeeds.length > 0 || localOnlyFeeds.length > 0 || updatedFeeds > 0;
        if (anyChanges) {
          // Changes detected - reset to base interval
          this.consecutiveNoChanges = 0;
          this._updateScanInterval(this.baseScanInterval);
        } else {
          // No changes - increase interval with exponential backoff
          this.consecutiveNoChanges++;
          const newInterval = Math.min(
            this.baseScanInterval * Math.pow(2, this.consecutiveNoChanges),
            this.maxScanInterval
          );
          this._updateScanInterval(newInterval);
        }

      } catch (e) {
        console.warn('[FeedScanner] Scan failed:', e.message);
      }

      this.scanning = false;
    },

    // Merge server progress with local (server wins for newer progress)
    _mergeProgress(serverProgress) {
      if (!serverProgress) return false;

      let changed = false;
      for (const [id, progress] of Object.entries(serverProgress)) {
        // Only update if server has higher progress (user listened further on another device)
        if (!state.progress[id] || progress > state.progress[id]) {
          state.progress[id] = progress;
          changed = true;
        }
      }
      return changed;
    },

    // Merge server bookmarks with local (union of both)
    // Bookmarks are arrays of {time, note, created} objects per episode
    _mergeBookmarks(serverBookmarks) {
      if (!serverBookmarks) return false;

      let changed = false;
      for (const [id, serverValue] of Object.entries(serverBookmarks)) {
        const localValue = state.bookmarks[id];

        // Server has array of bookmarks
        if (Array.isArray(serverValue)) {
          if (!localValue) {
            // No local bookmarks, use server's
            state.bookmarks[id] = serverValue;
            changed = true;
          } else if (Array.isArray(localValue)) {
            // Both are arrays - merge unique bookmarks by time
            const localTimes = new Set(localValue.map(b => b.time));
            for (const serverBookmark of serverValue) {
              if (!localTimes.has(serverBookmark.time)) {
                localValue.push(serverBookmark);
                changed = true;
              }
            }
            // Sort by time after merge
            if (changed) localValue.sort((a, b) => a.time - b.time);
          }
          // If local is not array but server is, server wins
          else {
            state.bookmarks[id] = serverValue;
            changed = true;
          }
        }
        // Server has boolean true (legacy format) - only use if no local data
        else if (serverValue === true && !localValue) {
          state.bookmarks[id] = [];
          changed = true;
        }
      }
      return changed;
    }
  };
  window.FeedScanner = FeedScanner;

  // === ACTIVITY CLEANUP - Delete and Prune Activities ===
  const ActivityCleanup = {
    endpoint: 'https://xvkq-pq7i-idtl.n7d.xano.io/api:Hj4C6PGO/activity',

    // Actions that should NEVER be deleted (state-defining)
    PROTECTED_ACTIONS: new Set([
      'state_snapshot',
      'feed_added',
      'feed_removed',
      'feed_updated'
    ]),

    // Actions safe to consolidate/prune aggressively
    EPHEMERAL_ACTIONS: new Set([
      'playback_progress',
      'seek',
      'play_pressed',
      'pause_pressed'
    ]),

    // Delete a single activity by ID
    async deleteActivity(activityId) {
      try {
        const response = await fetch(`${this.endpoint}/${activityId}`, {
          method: 'DELETE'
        });
        if (response.ok) {
          console.log('[ActivityCleanup] Deleted activity:', activityId);
          return true;
        }
        console.warn('[ActivityCleanup] Delete failed:', activityId, response.status);
        return false;
      } catch (e) {
        console.error('[ActivityCleanup] Delete error:', e.message);
        return false;
      }
    },

    // Delete multiple activities with rate limiting
    async deleteActivities(activityIds, delayMs = 100) {
      let deleted = 0;
      let failed = 0;

      for (const id of activityIds) {
        const success = await this.deleteActivity(id);
        if (success) deleted++;
        else failed++;

        // Rate limit to avoid overwhelming the API
        if (delayMs > 0 && activityIds.indexOf(id) < activityIds.length - 1) {
          await new Promise(r => setTimeout(r, delayMs));
        }
      }

      console.log(`[ActivityCleanup] Batch delete complete: ${deleted} deleted, ${failed} failed`);
      return { deleted, failed };
    },

    // Fetch all activities from remote
    async fetchActivities() {
      try {
        const response = await fetch(this.endpoint);

        if (!response.ok) return [];

        const data = await response.json();
        if (!data || !data.items) return [];

        // Sort by creation time
        return data.items.sort((a, b) =>
          new Date(a.created_at || 0) - new Date(b.created_at || 0)
        );
      } catch (e) {
        console.error('[ActivityCleanup] Fetch failed:', e.message);
        return [];
      }
    },

    // Strategy 1: Prune all activities before the latest snapshot
    // Keeps N most recent snapshots as safety buffer
    async pruneBeforeSnapshot(keepSnapshots = 2) {
      console.log('[ActivityCleanup] Starting snapshot-based cleanup...');
      const activities = await this.fetchActivities();

      if (activities.length === 0) {
        console.log('[ActivityCleanup] No activities found');
        return { deleted: 0, failed: 0 };
      }

      // Find all snapshots (from newest to oldest)
      const snapshots = [];
      for (let i = activities.length - 1; i >= 0; i--) {
        if (activities[i].action === 'state_snapshot') {
          snapshots.push({ index: i, activity: activities[i] });
        }
      }

      if (snapshots.length <= keepSnapshots) {
        console.log(`[ActivityCleanup] Only ${snapshots.length} snapshot(s) found, keeping all`);
        return { deleted: 0, failed: 0 };
      }

      // Find the cutoff point (keep the N most recent snapshots)
      const cutoffSnapshot = snapshots[keepSnapshots - 1];
      const cutoffIndex = cutoffSnapshot.index;

      // Collect activities to delete (everything before the cutoff snapshot)
      // But NEVER delete protected actions that might be needed for reconstruction
      const toDelete = [];
      for (let i = 0; i < cutoffIndex; i++) {
        const activity = activities[i];
        // Skip protected actions unless they're superseded by a newer snapshot
        if (!this.PROTECTED_ACTIONS.has(activity.action) || activity.action !== 'state_snapshot') {
          toDelete.push(activity.id);
        }
      }

      // Also delete old snapshots (except the buffer)
      for (let i = keepSnapshots; i < snapshots.length; i++) {
        toDelete.push(snapshots[i].activity.id);
      }

      if (toDelete.length === 0) {
        console.log('[ActivityCleanup] Nothing to prune');
        return { deleted: 0, failed: 0 };
      }

      console.log(`[ActivityCleanup] Pruning ${toDelete.length} activities before snapshot from ${cutoffSnapshot.activity.created_at}`);
      return await this.deleteActivities(toDelete);
    },

    // Strategy 2: Consolidate progress - keep only most recent per episode
    async consolidateProgress() {
      console.log('[ActivityCleanup] Starting progress consolidation...');
      const activities = await this.fetchActivities();

      const progressByEpisode = new Map();
      const toDelete = [];

      // Walk through chronologically, track latest progress per episode
      for (const activity of activities) {
        if (activity.action === 'playback_progress') {
          const key = activity.data?.episodeId || activity.content_url;
          if (!key) continue;

          // If we already have a progress for this episode, mark old one for deletion
          if (progressByEpisode.has(key)) {
            toDelete.push(progressByEpisode.get(key).id);
          }
          progressByEpisode.set(key, activity);
        }
      }

      if (toDelete.length === 0) {
        console.log('[ActivityCleanup] No duplicate progress entries found');
        return { deleted: 0, failed: 0 };
      }

      console.log(`[ActivityCleanup] Consolidating ${toDelete.length} redundant progress entries`);
      return await this.deleteActivities(toDelete);
    },

    // Strategy 3: Prune old session data (ephemeral actions only)
    async pruneOldSessions(maxAgeDays = 7) {
      console.log(`[ActivityCleanup] Pruning ephemeral actions older than ${maxAgeDays} days...`);
      const activities = await this.fetchActivities();

      const cutoff = Date.now() - (maxAgeDays * 24 * 60 * 60 * 1000);
      const toDelete = [];

      for (const activity of activities) {
        const activityTime = new Date(activity.created_at).getTime();

        // Only delete old ephemeral actions, never protected ones
        if (activityTime < cutoff &&
            this.EPHEMERAL_ACTIONS.has(activity.action) &&
            !this.PROTECTED_ACTIONS.has(activity.action)) {
          toDelete.push(activity.id);
        }
      }

      if (toDelete.length === 0) {
        console.log('[ActivityCleanup] No old ephemeral actions to prune');
        return { deleted: 0, failed: 0 };
      }

      console.log(`[ActivityCleanup] Pruning ${toDelete.length} old ephemeral actions`);
      return await this.deleteActivities(toDelete);
    },

    // Strategy 4: Remove cancelled-out actions (add + remove pairs)
    async pruneRedundantPairs() {
      console.log('[ActivityCleanup] Looking for redundant action pairs...');
      const activities = await this.fetchActivities();

      const feedAdds = new Map();  // url -> activity
      const feedRemoves = new Map();
      const bookmarkAdds = new Map();  // id -> activity
      const bookmarkRemoves = new Map();
      const toDelete = [];

      for (const activity of activities) {
        const url = activity.data?.url || activity.content_url;
        const id = activity.data?.target;

        switch (activity.action) {
          case 'feed_added':
            if (url) feedAdds.set(url, activity);
            break;
          case 'feed_removed':
            if (url && feedAdds.has(url)) {
              // Found a pair - both can be deleted
              toDelete.push(feedAdds.get(url).id);
              toDelete.push(activity.id);
              feedAdds.delete(url);
            }
            break;
          case 'bookmark_added':
          case 'article_bookmarked':
          case 'podcast_bookmarked':
            if (id) bookmarkAdds.set(id, activity);
            break;
          case 'bookmark_removed':
          case 'article_unbookmarked':
          case 'podcast_unbookmarked':
            if (id && bookmarkAdds.has(id)) {
              toDelete.push(bookmarkAdds.get(id).id);
              toDelete.push(activity.id);
              bookmarkAdds.delete(id);
            }
            break;
        }
      }

      if (toDelete.length === 0) {
        console.log('[ActivityCleanup] No redundant pairs found');
        return { deleted: 0, failed: 0 };
      }

      console.log(`[ActivityCleanup] Removing ${toDelete.length} activities from ${toDelete.length / 2} cancelled pairs`);
      return await this.deleteActivities(toDelete);
    },

    // Get cleanup statistics without deleting
    async getStats() {
      const activities = await this.fetchActivities();

      const stats = {
        total: activities.length,
        byAction: {},
        snapshots: 0,
        oldestActivity: null,
        newestActivity: null,
        potentialSavings: {
          beforeSnapshot: 0,
          duplicateProgress: 0,
          oldEphemeral: 0,
          redundantPairs: 0
        }
      };

      if (activities.length === 0) return stats;

      stats.oldestActivity = activities[0].created_at;
      stats.newestActivity = activities[activities.length - 1].created_at;

      // Count by action
      const progressByEpisode = new Map();
      const feedAdds = new Set();
      const bookmarkAdds = new Set();
      const cutoff = Date.now() - (7 * 24 * 60 * 60 * 1000);
      let latestSnapshotIndex = -1;

      activities.forEach((a, i) => {
        stats.byAction[a.action] = (stats.byAction[a.action] || 0) + 1;

        if (a.action === 'state_snapshot') {
          stats.snapshots++;
          latestSnapshotIndex = i;
        }

        // Count duplicate progress
        if (a.action === 'playback_progress') {
          const key = a.data?.episodeId || a.content_url;
          if (key && progressByEpisode.has(key)) {
            stats.potentialSavings.duplicateProgress++;
          }
          if (key) progressByEpisode.set(key, true);
        }

        // Count old ephemeral
        if (this.EPHEMERAL_ACTIONS.has(a.action) && new Date(a.created_at).getTime() < cutoff) {
          stats.potentialSavings.oldEphemeral++;
        }

        // Count redundant pairs
        const url = a.data?.url || a.content_url;
        const id = a.data?.target;
        if (a.action === 'feed_added' && url) feedAdds.add(url);
        if (a.action === 'feed_removed' && url && feedAdds.has(url)) {
          stats.potentialSavings.redundantPairs += 2;
          feedAdds.delete(url);
        }
        if (['bookmark_added', 'article_bookmarked', 'podcast_bookmarked'].includes(a.action) && id) {
          bookmarkAdds.add(id);
        }
        if (['bookmark_removed', 'article_unbookmarked', 'podcast_unbookmarked'].includes(a.action) && id && bookmarkAdds.has(id)) {
          stats.potentialSavings.redundantPairs += 2;
          bookmarkAdds.delete(id);
        }
      });

      // Count before snapshot (keeping 2 snapshots buffer)
      if (stats.snapshots > 2) {
        stats.potentialSavings.beforeSnapshot = latestSnapshotIndex;
      }

      return stats;
    },

    // Full cleanup routine - runs all strategies
    async runFullCleanup() {
      console.log('[ActivityCleanup] === Starting Full Cleanup ===');
      const startTime = Date.now();

      const results = {
        redundantPairs: { deleted: 0, failed: 0 },
        duplicateProgress: { deleted: 0, failed: 0 },
        oldSessions: { deleted: 0, failed: 0 },
        beforeSnapshot: { deleted: 0, failed: 0 },
        totalDeleted: 0,
        totalFailed: 0,
        duration: 0
      };

      // Run strategies in order (least destructive first)

      // 1. Remove redundant pairs first (safest)
      results.redundantPairs = await this.pruneRedundantPairs();

      // 2. Consolidate progress
      results.duplicateProgress = await this.consolidateProgress();

      // 3. Prune old ephemeral actions
      results.oldSessions = await this.pruneOldSessions(7);

      // 4. Snapshot-based cleanup (most aggressive)
      results.beforeSnapshot = await this.pruneBeforeSnapshot(2);

      results.totalDeleted =
        results.redundantPairs.deleted +
        results.duplicateProgress.deleted +
        results.oldSessions.deleted +
        results.beforeSnapshot.deleted;

      results.totalFailed =
        results.redundantPairs.failed +
        results.duplicateProgress.failed +
        results.oldSessions.failed +
        results.beforeSnapshot.failed;

      results.duration = Date.now() - startTime;

      console.log('[ActivityCleanup] === Cleanup Complete ===');
      console.log(`[ActivityCleanup] Total: ${results.totalDeleted} deleted, ${results.totalFailed} failed in ${results.duration}ms`);

      return results;
    }
  };
  window.ActivityCleanup = ActivityCleanup;

  // === DOWNLOAD STORAGE (IndexedDB) ===
  const DownloadDB = {
    db: null,
    DB_NAME: 'feedr_downloads',
    STORE_NAME: 'audio_files',

    async init() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(this.DB_NAME, 1);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => { this.db = request.result; resolve(); };
        request.onupgradeneeded = (e) => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains(this.STORE_NAME)) {
            db.createObjectStore(this.STORE_NAME, { keyPath: 'id' });
          }
        };
      });
    },

    async save(id, blob, metadata = {}) {
      return new Promise((resolve, reject) => {
        const tx = this.db.transaction(this.STORE_NAME, 'readwrite');
        const store = tx.objectStore(this.STORE_NAME);
        const request = store.put({ id, blob, metadata, savedAt: Date.now() });
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    },

    async get(id) {
      return new Promise((resolve, reject) => {
        const tx = this.db.transaction(this.STORE_NAME, 'readonly');
        const store = tx.objectStore(this.STORE_NAME);
        const request = store.get(id);
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    },

    async delete(id) {
      return new Promise((resolve, reject) => {
        const tx = this.db.transaction(this.STORE_NAME, 'readwrite');
        const store = tx.objectStore(this.STORE_NAME);
        const request = store.delete(id);
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    },

    async has(id) {
      const record = await this.get(id);
      return !!record;
    },

    async getAll() {
      return new Promise((resolve, reject) => {
        const tx = this.db.transaction(this.STORE_NAME, 'readonly');
        const store = tx.objectStore(this.STORE_NAME);
        const request = store.getAllKeys();
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }
  };

  // === CONTENT CACHE (IndexedDB) ===
  // Caches feed XML, parsed content, and images for fast loading
  const ContentCache = {
    db: null,
    DB_NAME: 'feedr_cache',
    DB_VERSION: 2,
    STORES: {
      feeds: 'feed_cache',      // Cached feed XML and parsed data
      images: 'image_cache',    // Cached images as blobs
      metadata: 'cache_meta'    // ETags, timestamps, etc.
    },
    // Cache expiry times
    FEED_TTL: 5 * 60 * 1000,      // 5 minutes for feed content
    IMAGE_TTL: 7 * 24 * 60 * 60 * 1000, // 7 days for images
    MAX_IMAGES: 500,               // Max cached images

    async init() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => { this.db = request.result; resolve(); };
        request.onupgradeneeded = (e) => {
          const db = e.target.result;
          // Feed cache store
          if (!db.objectStoreNames.contains(this.STORES.feeds)) {
            const feedStore = db.createObjectStore(this.STORES.feeds, { keyPath: 'url' });
            feedStore.createIndex('timestamp', 'timestamp', { unique: false });
          }
          // Image cache store
          if (!db.objectStoreNames.contains(this.STORES.images)) {
            const imgStore = db.createObjectStore(this.STORES.images, { keyPath: 'url' });
            imgStore.createIndex('timestamp', 'timestamp', { unique: false });
          }
          // Metadata store for ETags
          if (!db.objectStoreNames.contains(this.STORES.metadata)) {
            db.createObjectStore(this.STORES.metadata, { keyPath: 'url' });
          }
        };
      });
    },

    // === FEED CACHING ===
    async cacheFeed(url, xml, parsedData, etag = null) {
      if (!this.db) return;
      return new Promise((resolve, reject) => {
        const tx = this.db.transaction([this.STORES.feeds, this.STORES.metadata], 'readwrite');
        const feedStore = tx.objectStore(this.STORES.feeds);
        const metaStore = tx.objectStore(this.STORES.metadata);

        feedStore.put({
          url,
          xml,
          parsedData,
          timestamp: Date.now()
        });

        if (etag) {
          metaStore.put({ url, etag, timestamp: Date.now() });
        }

        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      });
    },

    async getCachedFeed(url) {
      if (!this.db) return null;
      return new Promise((resolve, reject) => {
        const tx = this.db.transaction(this.STORES.feeds, 'readonly');
        const store = tx.objectStore(this.STORES.feeds);
        const request = store.get(url);
        request.onsuccess = () => {
          const result = request.result;
          if (result && (Date.now() - result.timestamp) < this.FEED_TTL) {
            resolve(result);
          } else {
            resolve(null);
          }
        };
        request.onerror = () => reject(request.error);
      });
    },

    async getEtag(url) {
      if (!this.db) return null;
      return new Promise((resolve, reject) => {
        const tx = this.db.transaction(this.STORES.metadata, 'readonly');
        const store = tx.objectStore(this.STORES.metadata);
        const request = store.get(url);
        request.onsuccess = () => resolve(request.result?.etag || null);
        request.onerror = () => reject(request.error);
      });
    },

    // === IMAGE CACHING ===
    async cacheImage(url, blob) {
      if (!this.db || !url) return;
      return new Promise((resolve, reject) => {
        const tx = this.db.transaction(this.STORES.images, 'readwrite');
        const store = tx.objectStore(this.STORES.images);
        store.put({
          url,
          blob,
          timestamp: Date.now()
        });
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      });
    },

    async getCachedImage(url) {
      if (!this.db || !url) return null;
      return new Promise((resolve, reject) => {
        const tx = this.db.transaction(this.STORES.images, 'readonly');
        const store = tx.objectStore(this.STORES.images);
        const request = store.get(url);
        request.onsuccess = () => {
          const result = request.result;
          if (result && (Date.now() - result.timestamp) < this.IMAGE_TTL) {
            resolve(result.blob);
          } else {
            resolve(null);
          }
        };
        request.onerror = () => reject(request.error);
      });
    },

    async getImageAsDataUrl(url) {
      const blob = await this.getCachedImage(url);
      if (!blob) return null;
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.readAsDataURL(blob);
      });
    },

    // Clean up old cache entries
    async cleanup() {
      if (!this.db) return;
      const now = Date.now();

      // Clean old images
      const imgTx = this.db.transaction(this.STORES.images, 'readwrite');
      const imgStore = imgTx.objectStore(this.STORES.images);
      const imgCursor = imgStore.index('timestamp').openCursor();

      let imgCount = 0;
      const toDelete = [];

      imgCursor.onsuccess = (e) => {
        const cursor = e.target.result;
        if (cursor) {
          imgCount++;
          if ((now - cursor.value.timestamp) > this.IMAGE_TTL || imgCount > this.MAX_IMAGES) {
            toDelete.push(cursor.value.url);
          }
          cursor.continue();
        } else {
          // Delete old entries
          toDelete.forEach(url => imgStore.delete(url));
        }
      };

      // Clean old feed cache
      const feedTx = this.db.transaction(this.STORES.feeds, 'readwrite');
      const feedStore = feedTx.objectStore(this.STORES.feeds);
      const feedCursor = feedStore.index('timestamp').openCursor();

      feedCursor.onsuccess = (e) => {
        const cursor = e.target.result;
        if (cursor) {
          if ((now - cursor.value.timestamp) > this.FEED_TTL * 12) { // 1 hour for feeds
            feedStore.delete(cursor.value.url);
          }
          cursor.continue();
        }
      };
    }
  };

  // === IMAGE LOADER - SIMPLE & RELIABLE ===
  // Loads images immediately with proper fallbacks - no lazy loading flicker
  const ImageLoader = {
    loadedUrls: new Set(), // Track successfully loaded URLs
    failedUrls: new Set(), // Track failed URLs to avoid retrying
    preloadQueue: new Set(), // URLs being preloaded

    init() {
      // Set up scroll-based preloading after DOM is ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => this.setupPreloader());
      } else {
        this.setupPreloader();
      }
    },

    // Setup aggressive preloading on scroll
    setupPreloader() {
      let preloadTimeout = null;

      const preloadVisible = () => {
        // Find all images that need loading in viewport + buffer
        document.querySelectorAll('img[data-src]:not(.loaded)').forEach(img => {
          const rect = img.getBoundingClientRect();
          const buffer = 500; // Preload 500px ahead
          if (rect.top < window.innerHeight + buffer && rect.bottom > -buffer) {
            this.loadImage(img, img.dataset.src);
          }
        });
      };

      // Debounced preload on scroll
      const onScroll = () => {
        if (preloadTimeout) clearTimeout(preloadTimeout);
        preloadTimeout = setTimeout(preloadVisible, 50);
      };

      // Use MutationObserver to watch for new scroll containers
      const attachScrollListener = (container) => {
        if (container && !container._imageLoaderAttached) {
          container.addEventListener('scroll', onScroll, { passive: true });
          container._imageLoaderAttached = true;
        }
      };

      // Watch for container changes
      const observer = new MutationObserver(() => {
        ['podcastInboxList', 'newsList', 'feedScroll', 'showPageContent'].forEach(id => {
          attachScrollListener(document.getElementById(id));
        });
      });
      observer.observe(document.body, { childList: true, subtree: true });

      // Also listen to window scroll
      window.addEventListener('scroll', onScroll, { passive: true });

      // Initial preload after short delay
      setTimeout(preloadVisible, 100);

      // Periodic check for unloaded images (backup)
      setInterval(preloadVisible, 2000);
    },

    // Load an image - simple and direct
    loadImage(imgElement, src) {
      if (!imgElement || imgElement.classList.contains('loaded')) return;

      // Invalid source - show fallback immediately
      if (!src || src === 'undefined' || src === 'null') {
        this.showFallback(imgElement);
        return;
      }

      // Already failed - show fallback
      if (this.failedUrls.has(src)) {
        this.showFallback(imgElement);
        return;
      }

      // Data URLs - load immediately
      if (src.startsWith('data:')) {
        imgElement.src = src;
        imgElement.classList.add('loaded');
        return;
      }

      // Already loaded successfully - reuse
      if (this.loadedUrls.has(src)) {
        imgElement.src = src;
        imgElement.classList.add('loaded');
        return;
      }

      // Set up load handlers
      imgElement.onload = () => {
        imgElement.classList.add('loaded');
        this.loadedUrls.add(src);
        // Keep set size manageable
        if (this.loadedUrls.size > 500) {
          const first = this.loadedUrls.values().next().value;
          this.loadedUrls.delete(first);
        }
      };

      imgElement.onerror = () => {
        this.failedUrls.add(src);
        this.showFallback(imgElement);
        // Clear failed URLs periodically to allow retries
        if (this.failedUrls.size > 100) {
          this.failedUrls.clear();
        }
      };

      // Load directly - let browser handle caching
      imgElement.src = src;
    },

    // Show fallback icon
    showFallback(imgElement) {
      imgElement.classList.add('loaded', 'failed');
      const parent = imgElement.parentElement;
      if (parent && !parent.querySelector('.img-fallback')) {
        // Don't replace the img, just add a fallback icon behind it
        const fallback = document.createElement('i');
        fallback.className = 'ph ph-microphone-stage img-fallback';
        fallback.style.cssText = 'position:absolute;inset:0;display:flex;align-items:center;justify-content:center;font-size:24px;color:var(--text3);';
        parent.style.position = 'relative';
        parent.insertBefore(fallback, imgElement);
      }
    },

    // Observe an image for loading (backwards compatibility)
    observe(imgElement) {
      if (imgElement && imgElement.dataset.src) {
        // Load immediately if in viewport, otherwise queue
        const rect = imgElement.getBoundingClientRect();
        if (rect.top < window.innerHeight + 300 && rect.bottom > -300) {
          this.loadImage(imgElement, imgElement.dataset.src);
        }
      }
    },

    // Preload images in advance (for upcoming content)
    preloadImages(urls) {
      urls.forEach(url => {
        if (!url || this.loadedUrls.has(url) || this.failedUrls.has(url) || this.preloadQueue.has(url)) return;
        if (url.startsWith('data:')) return;

        this.preloadQueue.add(url);
        const img = new Image();
        img.onload = () => {
          this.loadedUrls.add(url);
          this.preloadQueue.delete(url);
        };
        img.onerror = () => {
          this.preloadQueue.delete(url);
        };
        img.src = url;
      });
    },

    // Load all visible images immediately
    loadAllVisible() {
      document.querySelectorAll('img[data-src]:not(.loaded)').forEach(img => {
        this.loadImage(img, img.dataset.src);
      });
    }
  };

  // === CONTENT PRELOADER ===
  // Preloads content for faster page transitions
  const ContentPreloader = {
    preloadQueue: [],
    isPreloading: false,

    // Queue feeds for background preloading
    queueFeedPreload(feeds) {
      feeds.forEach(f => {
        if (!this.preloadQueue.includes(f.url)) {
          this.preloadQueue.push(f.url);
        }
      });
      this.processQueue();
    },

    async processQueue() {
      if (this.isPreloading || !this.preloadQueue.length) return;
      this.isPreloading = true;

      while (this.preloadQueue.length > 0) {
        const url = this.preloadQueue.shift();
        try {
          const cached = await ContentCache.getCachedFeed(url);
          if (!cached) {
            // Low priority fetch for preloading
            const xml = await fetchWithProxy(url);
            const meta = extractFeedMeta(xml);
            await ContentCache.cacheFeed(url, xml, { meta });
          }
        } catch (e) {
          // Ignore preload errors
        }
        // Small delay between preloads to not block main thread
        await new Promise(r => setTimeout(r, 100));
      }

      this.isPreloading = false;
    },

    // Preload images for visible content
    preloadVisibleImages() {
      const images = [];
      // Collect image URLs from current view
      state.articles.slice(0, 20).forEach(a => {
        if (a.image) images.push(a.image);
        const feed = state.feeds.find(f => f.id === a.feedId);
        if (feed?.image) images.push(feed.image);
      });
      state.podcasts.slice(0, 20).forEach(p => {
        if (p.image) images.push(p.image);
        const feed = state.feeds.find(f => f.id === p.feedId);
        if (feed?.image) images.push(feed.image);
      });
      state.feeds.forEach(f => {
        if (f.image) images.push(f.image);
      });

      ImageLoader.preloadImages([...new Set(images)]);
    }
  };

  // === VIRTUAL SCROLL FOR LARGE LISTS ===
  // Renders only visible items for better performance
  const VirtualScroll = {
    instances: new Map(),

    create(container, items, renderItem, options = {}) {
      const itemHeight = options.itemHeight || 80;
      const bufferSize = options.bufferSize || 5;
      const id = options.id || 'default';

      // Store instance
      const instance = {
        container,
        items,
        renderItem,
        itemHeight,
        bufferSize,
        scrollTop: 0,
        visibleStart: 0,
        visibleEnd: 0
      };

      this.instances.set(id, instance);

      // Setup scroll container
      container.style.overflow = 'auto';
      container.innerHTML = '';

      // Create content wrapper
      const wrapper = document.createElement('div');
      wrapper.className = 'virtual-scroll-wrapper';
      wrapper.style.position = 'relative';
      wrapper.style.height = (items.length * itemHeight) + 'px';
      container.appendChild(wrapper);

      // Create viewport
      const viewport = document.createElement('div');
      viewport.className = 'virtual-scroll-viewport';
      viewport.style.position = 'absolute';
      viewport.style.width = '100%';
      wrapper.appendChild(viewport);

      // Initial render
      this.render(id);

      // Listen for scroll
      container.addEventListener('scroll', () => {
        requestAnimationFrame(() => this.render(id));
      });

      return instance;
    },

    render(id) {
      const instance = this.instances.get(id);
      if (!instance) return;

      const { container, items, renderItem, itemHeight, bufferSize } = instance;
      const viewport = container.querySelector('.virtual-scroll-viewport');
      if (!viewport) return;

      const scrollTop = container.scrollTop;
      const containerHeight = container.clientHeight;

      // Calculate visible range
      const visibleStart = Math.max(0, Math.floor(scrollTop / itemHeight) - bufferSize);
      const visibleEnd = Math.min(items.length, Math.ceil((scrollTop + containerHeight) / itemHeight) + bufferSize);

      // Only re-render if range changed significantly
      if (visibleStart === instance.visibleStart && visibleEnd === instance.visibleEnd) {
        return;
      }

      instance.visibleStart = visibleStart;
      instance.visibleEnd = visibleEnd;

      // Position viewport
      viewport.style.transform = `translateY(${visibleStart * itemHeight}px)`;

      // Render visible items
      viewport.innerHTML = items.slice(visibleStart, visibleEnd).map(renderItem).join('');

      // Setup lazy loading for images
      viewport.querySelectorAll('img[data-src]').forEach(img => {
        ImageLoader.observe(img);
      });
    },

    update(id, items) {
      const instance = this.instances.get(id);
      if (instance) {
        instance.items = items;
        const wrapper = instance.container.querySelector('.virtual-scroll-wrapper');
        if (wrapper) {
          wrapper.style.height = (items.length * instance.itemHeight) + 'px';
        }
        this.render(id);
      }
    },

    destroy(id) {
      this.instances.delete(id);
    }
  };

  // === STATE SNAPSHOT SYSTEM (IndexedDB) ===
  // Enables historical state restoration - keeps last N snapshots
  const SnapshotDB = {
    db: null,
    DB_NAME: 'feedr_snapshots',
    STORE_NAME: 'snapshots',
    MAX_SNAPSHOTS: 20, // Keep last 20 snapshots

    async init() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(this.DB_NAME, 1);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => { this.db = request.result; resolve(); };
        request.onupgradeneeded = (e) => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains(this.STORE_NAME)) {
            const store = db.createObjectStore(this.STORE_NAME, { keyPath: 'id' });
            store.createIndex('timestamp', 'timestamp', { unique: false });
          }
        };
      });
    },

    // Create a snapshot of the current state
    async createSnapshot(reason = 'manual') {
      if (!this.db) await this.init();

      // Note: We intentionally exclude transient articles/podcasts from snapshots.
      // These are re-fetched from RSS feeds on refresh, so snapshotting them wastes storage.
      // Only archived content (no longer in feeds) needs preservation.
      const snapshot = {
        id: 'snap_' + Date.now(),
        timestamp: Date.now(),
        reason, // 'manual', 'auto', 'before_delete', 'before_refresh', etc.
        state: {
          feeds: JSON.parse(JSON.stringify(state.feeds)),
          archivedArticles: JSON.parse(JSON.stringify(state.archivedArticles || [])),
          archivedPodcasts: JSON.parse(JSON.stringify(state.archivedPodcasts || [])),
          progress: JSON.parse(JSON.stringify(state.progress)),
          bookmarks: JSON.parse(JSON.stringify(state.bookmarks)),
          feedLastViewed: JSON.parse(JSON.stringify(state.feedLastViewed || {}))
        },
        stats: {
          feedCount: state.feeds.length,
          archivedArticleCount: (state.archivedArticles || []).length,
          archivedPodcastCount: (state.archivedPodcasts || []).length,
          bookmarkCount: Object.keys(state.bookmarks || {}).length
        }
      };

      return new Promise(async (resolve, reject) => {
        try {
          const tx = this.db.transaction(this.STORE_NAME, 'readwrite');
          const store = tx.objectStore(this.STORE_NAME);

          await new Promise((res, rej) => {
            const request = store.put(snapshot);
            request.onsuccess = () => res();
            request.onerror = () => rej(request.error);
          });

          // Prune old snapshots to keep only MAX_SNAPSHOTS
          await this.pruneOldSnapshots();

          resolve(snapshot.id);
        } catch (e) {
          reject(e);
        }
      });
    },

    // Get all snapshots (metadata only, not full state)
    async listSnapshots() {
      if (!this.db) await this.init();

      return new Promise((resolve, reject) => {
        const tx = this.db.transaction(this.STORE_NAME, 'readonly');
        const store = tx.objectStore(this.STORE_NAME);
        const request = store.getAll();
        request.onsuccess = () => {
          // Return metadata without full state (for UI listing)
          const snapshots = request.result.map(s => ({
            id: s.id,
            timestamp: s.timestamp,
            reason: s.reason,
            stats: s.stats,
            date: new Date(s.timestamp).toLocaleString()
          }));
          // Sort newest first
          snapshots.sort((a, b) => b.timestamp - a.timestamp);
          resolve(snapshots);
        };
        request.onerror = () => reject(request.error);
      });
    },

    // Get a specific snapshot with full state
    async getSnapshot(id) {
      if (!this.db) await this.init();

      return new Promise((resolve, reject) => {
        const tx = this.db.transaction(this.STORE_NAME, 'readonly');
        const store = tx.objectStore(this.STORE_NAME);
        const request = store.get(id);
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    },

    // Restore state from a snapshot
    async restoreSnapshot(id) {
      const snapshot = await this.getSnapshot(id);
      if (!snapshot) throw new Error('Snapshot not found');

      // Create a snapshot of current state before restoring (safety net)
      await this.createSnapshot('before_restore');

      // Restore the state
      // Note: articles/podcasts are not stored in snapshots (they're transient, re-fetched from feeds)
      // Clear them so they get refreshed from the restored feed list
      const s = snapshot.state;
      state.feeds = s.feeds || [];
      state.articles = []; // Clear - will be re-fetched from restored feeds
      state.podcasts = []; // Clear - will be re-fetched from restored feeds
      state.archivedArticles = s.archivedArticles || [];
      state.archivedPodcasts = s.archivedPodcasts || [];
      state.progress = s.progress || {};
      state.bookmarks = s.bookmarks || {};
      state.feedLastViewed = s.feedLastViewed || {};

      // Rebuild categories from restored feeds
      state.categories.clear();
      state.feeds.forEach(f => f.category && state.categories.add(f.category));

      // Save the restored state
      save();

      return snapshot;
    },

    // Delete a specific snapshot
    async deleteSnapshot(id) {
      if (!this.db) await this.init();

      return new Promise((resolve, reject) => {
        const tx = this.db.transaction(this.STORE_NAME, 'readwrite');
        const store = tx.objectStore(this.STORE_NAME);
        const request = store.delete(id);
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    },

    // Remove old snapshots keeping only MAX_SNAPSHOTS
    async pruneOldSnapshots() {
      const snapshots = await this.listSnapshots();
      if (snapshots.length > this.MAX_SNAPSHOTS) {
        const toDelete = snapshots.slice(this.MAX_SNAPSHOTS);
        for (const snap of toDelete) {
          await this.deleteSnapshot(snap.id);
        }
      }
    },

    // Clear all snapshots
    async clearAll() {
      if (!this.db) await this.init();

      return new Promise((resolve, reject) => {
        const tx = this.db.transaction(this.STORE_NAME, 'readwrite');
        const store = tx.objectStore(this.STORE_NAME);
        const request = store.clear();
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    }
  };

  // Expose snapshot functions globally
  window.Snapshots = {
    create: (reason) => SnapshotDB.createSnapshot(reason),
    list: () => SnapshotDB.listSnapshots(),
    get: (id) => SnapshotDB.getSnapshot(id),
    restore: (id) => SnapshotDB.restoreSnapshot(id),
    delete: (id) => SnapshotDB.deleteSnapshot(id)
  };

  // Track ongoing downloads
  const downloadProgress = {}; // { episodeId: { progress: 0-100, status: 'downloading'|'done'|'error' } }
  
  // === CONTENT TAGS TAXONOMY ===
  // Tag system for content categories
  const CONTENT_TAGS = {
    // News Categories
    technology: {
      label: 'Technology',
      icon: '<i class="ph ph-desktop"></i>'
    },
    business: {
      label: 'Business',
      icon: '<i class="ph ph-briefcase"></i>'
    },
    politics: {
      label: 'Politics',
      icon: '<i class="ph ph-bank"></i>'
    },
    science: {
      label: 'Science',
      icon: '<i class="ph ph-flask"></i>'
    },
    health: {
      label: 'Health',
      icon: '<i class="ph ph-first-aid-kit"></i>'
    },
    entertainment: {
      label: 'Entertainment',
      icon: '<i class="ph ph-film-strip"></i>'
    },
    sports: {
      label: 'Sports',
      icon: '<i class="ph ph-soccer-ball"></i>'
    },
    gaming: {
      label: 'Gaming',
      icon: '<i class="ph ph-game-controller"></i>'
    },
    world: {
      label: 'World News',
      icon: '<i class="ph ph-globe"></i>'
    },
    finance: {
      label: 'Finance',
      icon: '<i class="ph ph-chart-line-up"></i>'
    },
    education: {
      label: 'Education',
      icon: '<i class="ph ph-books"></i>'
    },
    lifestyle: {
      label: 'Lifestyle',
      icon: '<i class="ph ph-sparkle"></i>'
    },

    // Podcast Categories
    truecrime: {
      label: 'True Crime',
      icon: '<i class="ph ph-magnifying-glass"></i>'
    },
    comedy: {
      label: 'Comedy',
      icon: '<i class="ph ph-smiley"></i>'
    },
    interview: {
      label: 'Interviews',
      icon: '<i class="ph ph-microphone"></i>'
    },
    history: {
      label: 'History',
      icon: '<i class="ph ph-scroll"></i>'
    },
    selfhelp: {
      label: 'Self-Help',
      icon: '<i class="ph ph-flower-lotus"></i>'
    },
    storytelling: {
      label: 'Storytelling',
      icon: '<i class="ph ph-book-open"></i>'
    },
    news_daily: {
      label: 'Daily News',
      icon: '<i class="ph ph-newspaper"></i>'
    },
    culture: {
      label: 'Culture',
      icon: '<i class="ph ph-masks-theater"></i>'
    }
  };

  // Get all tag keys for iteration
  const TAG_KEYS = Object.keys(CONTENT_TAGS);

  // Auto-detect tags for a feed (returns empty - no keyword matching)
  const autoDetectFeedTags = (feed, feedContent = '') => [];

  // Auto-detect tags for an individual content item (inherits from feed if available)
  const autoDetectItemTags = (item, feedTags = []) => feedTags.length > 0 ? [feedTags[0]] : [];

  // Get tag info by key
  const getTagInfo = (tagKey) => CONTENT_TAGS[tagKey] || { label: tagKey, icon: '<i class="ph ph-tag"></i>' };

  // === FUZZY SEARCH ===
  // Enhanced fuzzy search with scoring and multi-term support
  const fuzzy = (q, items, fields) => {
    if (!q.trim()) return items;
    const terms = q.toLowerCase().split(/\s+/).filter(t => t.length > 0);

    return items.map(item => {
      let totalScore = 0;
      let matchedTerms = 0;

      for (const term of terms) {
        let termScore = 0;
        for (const f of fields) {
          const v = f.split('.').reduce((o, k) => o?.[k], item);
          if (!v) continue;
          const vl = String(v).toLowerCase();

          // Exact match (highest score)
          if (vl === term) {
            termScore = Math.max(termScore, 100);
          }
          // Word boundary match (high score)
          else if (new RegExp(`\\b${term}\\b`, 'i').test(vl)) {
            termScore = Math.max(termScore, 50);
          }
          // Title field gets higher score for partial matches
          else if (vl.includes(term)) {
            const fieldBoost = f.includes('title') ? 20 : 10;
            termScore = Math.max(termScore, fieldBoost);
          }
        }
        if (termScore > 0) {
          matchedTerms++;
          totalScore += termScore;
        }
      }

      // All terms must match (AND logic)
      const allTermsMatch = matchedTerms === terms.length;
      return { item, score: allTermsMatch ? totalScore : 0 };
    })
    .filter(x => x.score > 0)
    .sort((a, b) => b.score - a.score)
    .map(x => x.item);
  };

  // Highlight search matches in text
  const highlightSearch = (text, query) => {
    if (!query || !text) return text || '';
    const terms = query.toLowerCase().split(/\s+/).filter(t => t.length > 0);
    let result = text;
    for (const term of terms) {
      const regex = new RegExp(`(${term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
      result = result.replace(regex, '<mark class="search-highlight">$1</mark>');
    }
    return result;
  };

  // Filter items by tag
  const filterByTag = (items, tag) => {
    if (!tag || tag === 'all') return items;
    return items.filter(item => item.tags && item.tags.includes(tag));
  };
  
  // === STATE ===
  const state = {
    view: 'podcasts',
    tab: 'home',
    feeds: [],
    articles: [],
    podcasts: [],
    archivedArticles: [], // Historical articles no longer in feed but preserved locally
    archivedPodcasts: [], // Historical episodes no longer in feed but preserved locally
    categories: new Set(['All']),
    podcastCategories: new Set(['All']), // Categories for podcast feeds
    selectedSource: null,
    selectedCat: 'All',
    selectedTag: 'all', // Selected tag filter
    // Podcast inbox filters
    selectedPodcastSource: null, // Currently selected podcast source (null = all)
    selectedPodcastCat: 'All', // Category filter for podcasts
    selectedPodcastTag: 'all', // Tag filter for podcasts
    feedFilter: 'podcast', // Feed filter: 'all', 'news', 'podcast'
    mobileCardView: 'default', // Mobile card view: 'default', 'compact', 'dense', 'list'
    newsInboxView: 'list', // News inbox view: 'list', 'cards', 'table', 'masonry'
    podcastInboxView: 'list', // Podcast inbox view: 'list', 'cards'
    allView: 'list', // All view: 'list', 'cards'
    query: '',
    searchScope: null, // null = all feeds, or feedId to search within specific feed
    feedType: 'news',
    currentEp: null,
    playing: false,
    speed: 1,
    progress: {},
    queue: [], // Episode queue: [{ id, feedId, ... }]
    queuePanelOpen: false,
    viewPrefs: {}, // { sourceId: 'list'|'table'|'cards'|'masonry' }
    currentSourcePage: null, // Currently viewing source page (news)
    currentShowPage: null, // Currently viewing show page (podcasts)
    currentEpisodePage: null, // Currently viewing episode page (episode detail)
    bookmarks: {}, // { episodeId: [{ time, note, created }] }
    sleepTimer: null, // { endTime, intervalId, fadeIntervalId }
    speedPanelOpen: false,
    bookmarksPanelOpen: false,
    feedLastViewed: {}, // { feedId: timestamp } - when user last viewed each feed
    userBehavior: { // Track user behavior for API sync
      reads: [], // { articleId, timestamp, duration }
      plays: [], // { episodeId, timestamp, duration, completed }
      searches: [], // { query, timestamp, results }
      subscriptions: [] // { feedId, timestamp, action: 'add'|'remove' }
    },
    openLinksInNewTab: true, // Whether clicking articles opens in new tab (true) or same tab (false)
    forLater: [] // For Later list: [{ id, contentId, contentType: 'article'|'episode', addedAt, completed }]
  };
  
  // === DOM ===
  const $ = id => document.getElementById(id);
  const el = {
    newsView: $('newsView'), podcastView: $('podcastView'), allView: $('allView'), forLaterView: $('forLaterView'),
    feedNav: $('feedNav'), feedScroll: $('feedScroll'), forLaterList: $('forLaterList'),
    mobileViewToggle: $('mobileViewToggle'), mobileViewIcon: $('mobileViewIcon'),
    feedCountAll: $('feedCountAll'), feedCountNews: $('feedCountNews'), feedCountPodcast: $('feedCountPodcast'),
    newsSources: $('newsSources'), newsTitle: $('newsTitle'),
    categoryChips: $('categoryChips'), newsList: $('newsList'),
    newsContent: $('newsContent'), sourcePage: $('sourcePage'),
    tagFilterSection: $('tagFilterSection'), tagChips: $('tagChips'),
    // Podcast inbox elements
    podcastSources: $('podcastSources'),
    podcastInboxList: $('podcastInboxList'),
    podcastInboxContent: $('podcastInboxContent'),
    mobileShowsHeader: $('mobileShowsHeader'),
    mobileNewsHeader: $('mobileNewsHeader'),
    podcastInboxHeader: $('podcastInboxHeader'),
    showPage: $('showPage'),
    episodePage: $('episodePage'),
    player: $('player'), playerArt: $('playerArt'), playerTitle: $('playerTitle'),
    playerShow: $('playerShow'), pPlay: $('pPlay'), pPlayIcon: $('pPlayIcon'),
    pCur: $('pCur'), pDur: $('pDur'), pBar: $('pBar'), pFill: $('pFill'), pSpeed: $('pSpeed'), scrubTooltip: $('scrubTooltip'),
    pBookmark: $('pBookmark'), pSleep: $('pSleep'), pPrev: $('pPrev'), pNext: $('pNext'),
    volumeSlider: $('volumeSlider'), pVolumeBtn: $('pVolumeBtn'), volumeIcon: $('volumeIcon'),
    speedPanel: $('speedPanel'), speedSlider: $('speedSlider'), speedValue: $('speedValue'),
    bookmarksPanel: $('bookmarksPanel'), bookmarksList: $('bookmarksList'), addBookmarkBtn: $('addBookmarkBtn'),
    queuePanel: $('queuePanel'), queueList: $('queueList'), queueClearBtn: $('queueClearBtn'),
    pQueue: $('pQueue'), queueBadge: $('queueBadge'),
    sleepBadge: $('sleepBadge'),
    expanded: $('expanded'), expArt: $('expArt'), expTitle: $('expTitle'),
    expShow: $('expShow'), expPlay: $('expPlay'), expPlayIcon: $('expPlayIcon'),
    expCur: $('expCur'), expDur: $('expDur'), expBar: $('expBar'), expFill: $('expFill'),
    expPrev: $('expPrev'), expNext: $('expNext'),
    swipeContainer: $('swipeContainer'), swipeIndicator: $('swipeIndicator'),
    swipeIcon: $('swipeIcon'), swipeText: $('swipeText'), swipeLabel: $('swipeLabel'),
    modal: $('modal'), fUrl: $('fUrl'), fName: $('fName'), fAuthor: $('fAuthor'), fCat: $('fCat'),
    fFetch: $('fFetch'), fStatus: $('fStatus'), fSubmit: $('fSubmit'),
    // Edit feed modal
    editModal: $('editModal'), editFeedId: $('editFeedId'), editName: $('editName'),
    editAuthor: $('editAuthor'), editCat: $('editCat'), editImage: $('editImage'),
    editStatus: $('editStatus'), editSubmit: $('editSubmit'), editModalClose: $('editModalClose'),
    toast: $('toast'), searchInput: $('searchInput'),
    searchBox: $('searchBox'), searchClear: $('searchClear'), searchScope: $('searchScope'),
    audio: $('audioPlayer'),
    // New elements
    hamburgerBtn: $('hamburgerBtn'), drawer: $('drawer'), drawerOverlay: $('drawerOverlay'),
    drawerContent: $('drawerContent'), drawerClose: $('drawerClose'),
    mobileTabBar: $('mobileTabBar'),
    sleepTimerModal: $('sleepTimerModal'), sleepTimerContent: $('sleepTimerContent'),
    sleepTimerActive: $('sleepTimerActive'), sleepCountdown: $('sleepCountdown'),
    sleepPresets: $('sleepPresets'), sleepCustomInput: $('sleepCustomInput'),
    sleepCustomBtn: $('sleepCustomBtn'), sleepCancelBtn: $('sleepCancelBtn'),
    // Settings modal
    settingsBtn: $('settingsBtn'), settingsModal: $('settingsModal'),
    settingsClose: $('settingsClose'), openLinksToggle: $('openLinksToggle'),
    // Activity cleanup
    refreshActivityStats: $('refreshActivityStats'), runActivityCleanup: $('runActivityCleanup'),
    activityStatTotal: $('activityStatTotal'), activityStatSnapshots: $('activityStatSnapshots'),
    activityStatSavings: $('activityStatSavings'), cleanupStatus: $('cleanupStatus'),
    // Snapshot modal
    snapshotModal: $('snapshotModal'), snapshotModalClose: $('snapshotModalClose'),
    snapshotList: $('snapshotList'), createSnapshotBtn: $('createSnapshotBtn'),
    // Podcast search modal
    podcastSearchModal: $('podcastSearchModal'), podcastSearchClose: $('podcastSearchClose'),
    podcastSearchInput: $('podcastSearchInput'), podcastSearchBtn: $('podcastSearchBtn'),
    podcastSearchResults: $('podcastSearchResults'), podcastSearchStatus: $('podcastSearchStatus'),
    // Article details modal
    articleModal: $('articleModal'), articleModalClose: $('articleModalClose'),
    articleModalBody: $('articleModalBody')
  };
  
  // === UTILS ===
  const fmt = s => { if (isNaN(s) || s < 0) return '0:00'; const m = Math.floor(s / 60), sec = Math.floor(s % 60); return m + ':' + String(sec).padStart(2, '0'); };
  const fmtLong = s => { if (isNaN(s) || s < 0) return '0:00'; const h = Math.floor(s / 3600), m = Math.floor((s % 3600) / 60), sec = Math.floor(s % 60); return h > 0 ? h + ':' + String(m).padStart(2, '0') + ':' + String(sec).padStart(2, '0') : m + ':' + String(sec).padStart(2, '0'); };
  const toast = m => { el.toast.textContent = m; el.toast.classList.add('show'); setTimeout(() => el.toast.classList.remove('show'), 2500); };
  const openArticleLink = url => { if (url) state.openLinksInNewTab ? window.open(url, '_blank') : window.location.href = url; };

  // Show article details modal
  const showArticleModal = (article) => {
    const feed = state.feeds.find(f => f.id === article.feedId);
    const feedIcon = feed?.image || feed?.icon || '';
    const feedName = feed?.name || 'Unknown Source';

    el.articleModalBody.innerHTML = `
      ${article.image ? `<img class="article-modal-image" src="${article.image}" alt="" onerror="this.style.display='none'" data-link="${article.link || ''}">` : ''}
      <div class="article-modal-content">
        <div class="article-modal-meta">
          <div class="article-modal-source">
            ${feedIcon ? `<img src="${feedIcon}" alt="" onerror="this.style.display='none'">` : ''}
            <span>${feedName}</span>
          </div>
          <span class="article-modal-time">Â· ${article.time || ''}</span>
        </div>
        <h2 class="article-modal-title">${article.title || 'Untitled'}</h2>
        ${article.summary ? `<p class="article-modal-summary">${article.summary}</p>` : ''}
        ${article.link ? `<a href="${article.link}" class="article-modal-link" target="_blank" rel="noopener"><i class="ph ph-arrow-square-out"></i> Read Full Article</a>` : ''}
      </div>
    `;
    el.articleModal.classList.add('active');
  };

  const closeArticleModal = () => {
    el.articleModal.classList.remove('active');
  };

  // Prune state data to fit within localStorage quota (~5MB limit)
  const pruneStateForStorage = () => {
    const MAX_ARTICLES_PER_FEED = 50;
    const MAX_PODCASTS_PER_FEED = 75;
    const MAX_ARCHIVED_PER_FEED = 100;
    const MAX_BEHAVIOR_ENTRIES = 200;

    // Group articles by feed and keep only most recent
    const articlesByFeed = {};
    state.articles.forEach(a => {
      if (!articlesByFeed[a.feedId]) articlesByFeed[a.feedId] = [];
      articlesByFeed[a.feedId].push(a);
    });
    const prunedArticles = [];
    Object.values(articlesByFeed).forEach(feedArticles => {
      feedArticles.sort((a, b) => new Date(b.pubDate || 0) - new Date(a.pubDate || 0));
      prunedArticles.push(...feedArticles.slice(0, MAX_ARTICLES_PER_FEED));
    });
    const articlesPruned = state.articles.length - prunedArticles.length;

    // Group podcasts by feed and keep only most recent
    const podcastsByFeed = {};
    state.podcasts.forEach(p => {
      if (!podcastsByFeed[p.feedId]) podcastsByFeed[p.feedId] = [];
      podcastsByFeed[p.feedId].push(p);
    });
    const prunedPodcasts = [];
    Object.values(podcastsByFeed).forEach(feedPodcasts => {
      feedPodcasts.sort((a, b) => new Date(b.pubDate || 0) - new Date(a.pubDate || 0));
      prunedPodcasts.push(...feedPodcasts.slice(0, MAX_PODCASTS_PER_FEED));
    });
    const podcastsPruned = state.podcasts.length - prunedPodcasts.length;

    // Prune archived content per feed
    const archivedByFeed = {};
    state.archivedArticles.forEach(a => {
      if (!archivedByFeed[a.feedId]) archivedByFeed[a.feedId] = [];
      archivedByFeed[a.feedId].push(a);
    });
    const prunedArchivedArticles = [];
    Object.values(archivedByFeed).forEach(feedArchived => {
      feedArchived.sort((a, b) => new Date(b.pubDate || 0) - new Date(a.pubDate || 0));
      prunedArchivedArticles.push(...feedArchived.slice(0, MAX_ARCHIVED_PER_FEED));
    });

    const archivedPodcastsByFeed = {};
    state.archivedPodcasts.forEach(p => {
      if (!archivedPodcastsByFeed[p.feedId]) archivedPodcastsByFeed[p.feedId] = [];
      archivedPodcastsByFeed[p.feedId].push(p);
    });
    const prunedArchivedPodcasts = [];
    Object.values(archivedPodcastsByFeed).forEach(feedArchived => {
      feedArchived.sort((a, b) => new Date(b.pubDate || 0) - new Date(a.pubDate || 0));
      prunedArchivedPodcasts.push(...feedArchived.slice(0, MAX_ARCHIVED_PER_FEED));
    });

    // Clean up progress for non-existent podcasts
    const validPodcastIds = new Set([...prunedPodcasts.map(p => p.id), ...prunedArchivedPodcasts.map(p => p.id)]);
    const prunedProgress = {};
    Object.entries(state.progress).forEach(([id, val]) => {
      if (validPodcastIds.has(id)) prunedProgress[id] = val;
    });

    // Limit userBehavior arrays
    const prunedBehavior = {
      reads: (state.userBehavior.reads || []).slice(-MAX_BEHAVIOR_ENTRIES),
      plays: (state.userBehavior.plays || []).slice(-MAX_BEHAVIOR_ENTRIES),
      searches: (state.userBehavior.searches || []).slice(-MAX_BEHAVIOR_ENTRIES),
      subscriptions: (state.userBehavior.subscriptions || []).slice(-MAX_BEHAVIOR_ENTRIES)
    };

    if (articlesPruned > 0 || podcastsPruned > 0) {
      console.log(`[Prune] Trimmed ${articlesPruned} articles, ${podcastsPruned} podcasts for storage`);
    }

    return {
      articles: prunedArticles,
      podcasts: prunedPodcasts,
      archivedArticles: prunedArchivedArticles,
      archivedPodcasts: prunedArchivedPodcasts,
      progress: prunedProgress,
      userBehavior: prunedBehavior
    };
  };

  const save = (immediate = false) => {
    // Prune data to fit within localStorage quota before saving
    const pruned = pruneStateForStorage();

    // Full state for localStorage (includes pruned content for offline access)
    const fullStateData = {
      feeds: state.feeds,
      articles: pruned.articles,
      podcasts: pruned.podcasts,
      archivedArticles: pruned.archivedArticles,
      archivedPodcasts: pruned.archivedPodcasts,
      progress: pruned.progress,
      view: state.view,
      viewPrefs: state.viewPrefs,
      bookmarks: state.bookmarks,
      userBehavior: pruned.userBehavior,
      feedLastViewed: state.feedLastViewed,
      openLinksInNewTab: state.openLinksInNewTab,
      forLater: state.forLater
    };
    // Save full state to localStorage for immediate local access
    console.log('[Save] Saving to localStorage:', state.feeds.length, 'feeds,', pruned.podcasts.length, 'podcasts,', pruned.articles.length, 'articles');
    try {
      localStorage.setItem('feedr2', JSON.stringify(fullStateData));
      console.log('[Save] âœ“ localStorage save complete');
    } catch (e) {
      console.error('[Save] âœ— localStorage save FAILED:', e.message);
      // Show user-friendly error if quota exceeded
      if (e.name === 'QuotaExceededError') {
        toast('Storage full - please clear old data');
      } else {
        toast('Failed to save locally: ' + e.message);
      }
    }

    // Minimal state for Xano sync (only subscriptions + user data, NOT content)
    // Articles/podcasts are fetched fresh from RSS feeds on each device
    const syncData = {
      feeds: state.feeds.map(f => ({
        id: f.id,
        url: f.url,
        name: f.name,
        type: f.type,
        category: f.category,
        author: f.author,
        tags: f.tags,
        description: f.description,
        image: f.image
      })),
      progress: state.progress,
      bookmarks: state.bookmarks,
      feedLastViewed: state.feedLastViewed
    };

    // Sync minimal data to server for cross-device consistency
    if (immediate) {
      // Immediate sync for critical operations (feed add/remove)
      // Use sendBeacon for guaranteed delivery even if page is closing
      console.log('[Save] Immediate sync to API with', syncData.feeds.length, 'feeds');
      StateSync.syncWithBeacon(syncData);
    } else {
      // Debounced sync for normal operations
      console.log('[Save] Debounced sync to API');
      StateSync.saveState(syncData);
    }
  };

  // Helper to apply state data from either server or localStorage
  const applyStateData = (d) => {
    if (!d) return false;
    state.feeds = d.feeds || [];
    state.articles = d.articles || [];
    state.podcasts = d.podcasts || [];
    state.archivedArticles = d.archivedArticles || [];
    state.archivedPodcasts = d.archivedPodcasts || [];
    state.progress = d.progress || {};
    if (d.view) state.view = d.view;
    state.viewPrefs = d.viewPrefs || {};
    state.bookmarks = d.bookmarks || {};
    state.userBehavior = d.userBehavior || { reads: [], plays: [], searches: [], subscriptions: [] };
    state.feedLastViewed = d.feedLastViewed || {};
    if (typeof d.openLinksInNewTab === 'boolean') state.openLinksInNewTab = d.openLinksInNewTab;
    state.forLater = d.forLater || [];

    // Migrate: ensure all feeds have tags array
    state.feeds.forEach(f => {
      if (!f.tags) f.tags = [];
    });
    // Migrate: ensure all articles have tags array
    state.articles.forEach(a => {
      if (!a.tags) a.tags = [];
    });
    // Migrate: ensure all podcasts have tags array
    state.podcasts.forEach(p => {
      if (!p.tags) p.tags = [];
    });
    return true;
  };

  const load = async () => {
    let loaded = false;
    let localData = null;

    // Step 1: Load from localStorage (immediate)
    try {
      localData = JSON.parse(localStorage.getItem('feedr2'));
      if (localData && localData.feeds) {
        // localStorage is valid - apply it (even if feeds array is empty)
        loaded = applyStateData(localData);
        console.log('[Load] From localStorage:', state.feeds.length, 'feeds');
      }
    } catch(e) {
      console.warn('[Load] localStorage failed:', e.message);
    }

    // Step 2: Fetch from server (sync)
    try {
      const serverData = await StateSync.fetchState();

      if (serverData && serverData.data && serverData.data.feeds) {
        const serverFeeds = serverData.data.feeds;
        const localFeeds = state.feeds;

        if (serverFeeds.length > 0 || localFeeds.length > 0) {
          console.log('[Load] Server has', serverFeeds.length, 'feeds, local has', localFeeds.length);

          // BIDIRECTIONAL MERGE: Keep feeds from both local and server
          // Server feeds with local enrichment
          const mergedFeeds = serverFeeds.map(sf => {
            const localFeed = localFeeds.find(lf => lf.url === sf.url);
            return localFeed ? { ...localFeed, ...sf } : { ...sf, tags: [] };
          });

          // Add local-only feeds that aren't on server yet (preserves unsync'd feeds)
          const serverUrls = new Set(serverFeeds.map(sf => sf.url));
          const localOnlyFeeds = localFeeds.filter(lf => !serverUrls.has(lf.url));
          if (localOnlyFeeds.length > 0) {
            console.log('[Load] Preserving', localOnlyFeeds.length, 'local-only feeds not yet synced');
            mergedFeeds.push(...localOnlyFeeds);
          }

          state.feeds = mergedFeeds;

          // Keep content for all current feeds (don't orphan local content)
          const activeFeedIds = new Set(state.feeds.map(f => f.id));
          state.articles = state.articles.filter(a => activeFeedIds.has(a.feedId));
          state.podcasts = state.podcasts.filter(p => activeFeedIds.has(p.feedId));

          // Merge progress/bookmarks (both directions)
          state.progress = { ...state.progress, ...serverData.data.progress };
          state.bookmarks = { ...state.bookmarks, ...serverData.data.bookmarks };
          state.feedLastViewed = { ...state.feedLastViewed, ...serverData.data.feedLastViewed };

          console.log('[Load] Merged to', state.feeds.length, 'feeds');
          loaded = true;

          // If we had local-only feeds, force sync to push them to server
          if (localOnlyFeeds.length > 0) {
            console.log('[Load] Forcing sync to push local-only feeds to server');
            StateSync.changeCounter = StateSync.snapshotInterval;
          }
          save(true);
        } else if (localData && localData.feeds && localData.feeds.length > 0) {
          // Server empty, push local state
          console.log('[Load] Pushing local state to server');
          StateSync.changeCounter = StateSync.snapshotInterval; // Force snapshot
          save(true);
          loaded = true;
        }
      }
    } catch (e) {
      console.warn('[Load] Server fetch failed:', e.message);
    }

    // Update categories
    state.feeds.forEach(f => f.category && state.categories.add(f.category));

    // Load demo only if both: failed to load AND no feeds
    // Changed from || to && to prevent wiping user data
    if (!loaded && state.feeds.length === 0) {
      loadDemo();
    }
  };

  // Get/set view preference for a source
  const getViewPref = (sourceId, defaultView = 'list') => state.viewPrefs[sourceId] || defaultView;
  const setViewPref = (sourceId, viewMode) => { state.viewPrefs[sourceId] = viewMode; save(); };

  // === NEW CONTENT TRACKING ===
  // Mark a feed as viewed (user opened it)
  const markFeedViewed = (feedId) => {
    state.feedLastViewed[feedId] = Date.now();
    save();
  };

  // Get the newest content date for a feed
  const getNewestContentDate = (feedId) => {
    const feed = state.feeds.find(f => f.id === feedId);
    if (!feed) return null;

    const items = feed.type === 'podcast'
      ? state.podcasts.filter(p => p.feedId === feedId)
      : state.articles.filter(a => a.feedId === feedId);

    if (!items.length) return null;

    // Find newest pubDate
    let newest = null;
    items.forEach(item => {
      const date = item.pubDate ? new Date(item.pubDate).getTime() : null;
      if (date && (!newest || date > newest)) newest = date;
    });
    return newest;
  };

  // Check if feed has new content since last viewed
  const feedHasNewContent = (feedId) => {
    const lastViewed = state.feedLastViewed[feedId];
    const newestContent = getNewestContentDate(feedId);

    // If never viewed, it has new content (if there's any content)
    if (!lastViewed) return newestContent !== null;

    // Compare newest content to last viewed time
    return newestContent && newestContent > lastViewed;
  };

  // Get count of new items since last viewed
  const getNewItemCount = (feedId) => {
    const lastViewed = state.feedLastViewed[feedId];
    if (!lastViewed) return 0; // Don't show count if never viewed

    const feed = state.feeds.find(f => f.id === feedId);
    if (!feed) return 0;

    const items = feed.type === 'podcast'
      ? state.podcasts.filter(p => p.feedId === feedId)
      : state.articles.filter(a => a.feedId === feedId);

    return items.filter(item => {
      const date = item.pubDate ? new Date(item.pubDate).getTime() : null;
      return date && date > lastViewed;
    }).length;
  };

  // Format relative time for "Updated X ago" display
  const formatUpdatedAgo = (timestamp) => {
    if (!timestamp) return '';
    const now = Date.now();
    const diff = now - timestamp;
    const mins = Math.floor(diff / 60000);
    const hours = Math.floor(diff / 3600000);
    const days = Math.floor(diff / 86400000);

    if (mins < 1) return 'Just now';
    if (mins < 60) return `${mins}m ago`;
    if (hours < 24) return `${hours}h ago`;
    if (days < 7) return `${days}d ago`;
    return new Date(timestamp).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
  };
  
  const loadDemo = () => {
    // No sample data - users add their own feeds
    console.log('[LoadDemo] Initializing empty state (no feeds found)');
    state.feeds = [];
    state.articles = [];
    state.podcasts = [];
    state.progress = {};
    save();
  };

  // === RSS FEED FETCHING ===
  // Multiple CORS proxies for reliability - tried in parallel, first success wins
  const CORS_PROXIES = [
    // Primary: Own Xano RSS proxy (most reliable - we control it)
    url => `https://xvkq-pq7i-idtl.n7d.xano.io/api:Hj4C6PGO/rss-proxy?url=${encodeURIComponent(url)}`,
    // Fallback proxies
    url => `https://corsproxy.io/?${encodeURIComponent(url)}`,
    url => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
    url => `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`,
    url => `https://thingproxy.freeboard.io/fetch/${url}`
  ];

  // === PODCASTINDEX API ===
  const PodcastIndex = {
    API_KEY: 'YEAFNWVNMD4HTBNFUPM3',
    API_SECRET: '', // Add your secret here if needed
    BASE_URL: 'https://api.podcastindex.org/api/1.0',
    USER_AGENT: 'BRRST-PodcastApp/1.0',

    // SHA1 hash using Web Crypto API
    async sha1(message) {
      const msgBuffer = new TextEncoder().encode(message);
      const hashBuffer = await crypto.subtle.digest('SHA-1', msgBuffer);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    },

    // Generate auth headers for PodcastIndex API
    async getAuthHeaders() {
      const ts = Math.floor(Date.now() / 1000);
      const authString = this.API_KEY + this.API_SECRET + ts.toString();
      const authHash = await this.sha1(authString);
      return {
        'User-Agent': this.USER_AGENT,
        'X-Auth-Key': this.API_KEY,
        'X-Auth-Date': ts.toString(),
        'Authorization': authHash
      };
    },

    // Search podcasts by term
    async searchByTerm(query, max = 20) {
      try {
        const headers = await this.getAuthHeaders();
        const url = `${this.BASE_URL}/search/byterm?q=${encodeURIComponent(query)}&max=${max}`;

        const response = await fetch(url, {
          method: 'GET',
          headers: headers
        });

        if (!response.ok) {
          const errorText = await response.text();
          console.error('[PodcastIndex] API error:', response.status, errorText);
          throw new Error(`API error: ${response.status}`);
        }

        const data = await response.json();
        console.log('[PodcastIndex] Search results:', data);
        return data;
      } catch (error) {
        console.error('[PodcastIndex] Search failed:', error);
        throw error;
      }
    },

    // Get podcast by feed URL
    async getByFeedUrl(feedUrl) {
      try {
        const headers = await this.getAuthHeaders();
        const url = `${this.BASE_URL}/podcasts/byfeedurl?url=${encodeURIComponent(feedUrl)}`;

        const response = await fetch(url, {
          method: 'GET',
          headers: headers
        });

        if (!response.ok) {
          throw new Error(`API error: ${response.status}`);
        }

        return await response.json();
      } catch (error) {
        console.error('[PodcastIndex] Get by URL failed:', error);
        throw error;
      }
    },

    // Get trending podcasts
    async getTrending(max = 10, lang = 'en') {
      try {
        const headers = await this.getAuthHeaders();
        const url = `${this.BASE_URL}/podcasts/trending?max=${max}&lang=${lang}`;

        const response = await fetch(url, {
          method: 'GET',
          headers: headers
        });

        if (!response.ok) {
          throw new Error(`API error: ${response.status}`);
        }

        return await response.json();
      } catch (error) {
        console.error('[PodcastIndex] Get trending failed:', error);
        throw error;
      }
    }
  };

  const fetchWithTimeout = (url, options = {}, timeout = 15000) => {
    return Promise.race([
      fetch(url, options),
      new Promise((_, reject) =>
        setTimeout(() => reject(new Error('Request timeout')), timeout)
      )
    ]);
  };

  const fetchWithProxy = async (url, options = {}) => {
    const { useCache = true, forceFresh = false } = options;

    // Check cache first (unless forcing fresh fetch)
    if (useCache && !forceFresh && ContentCache.db) {
      const cached = await ContentCache.getCachedFeed(url);
      if (cached) {
        console.log('[Cache] Using cached feed:', url);
        return cached.xml;
      }
    }

    // Try all proxies in parallel for faster response
    const proxyAttempts = CORS_PROXIES.map(async (proxyFn, index) => {
      const proxyUrl = proxyFn(url);
      console.log(`Trying proxy ${index}:`, proxyUrl);

      // Note: Avoid custom headers like Cache-Control that trigger CORS preflight
      // Many proxy services don't properly handle preflight requests
      const response = await fetchWithTimeout(proxyUrl, {}, 12000); // Shorter timeout since we're racing

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }

      // Extract ETag for future conditional requests
      const etag = response.headers.get('ETag') || response.headers.get('etag');

      const text = await response.text();

      if (!text || text.trim().length === 0) {
        throw new Error('Empty response');
      }

      // Basic validation that this looks like XML
      if (!text.trim().startsWith('<?xml') && !text.trim().startsWith('<rss') && !text.trim().startsWith('<feed')) {
        console.warn('Response does not look like XML:', text.substring(0, 100));
      }

      return { text, etag };
    });

    // Return first successful result
    try {
      const result = await Promise.any(proxyAttempts);

      // Cache the result
      if (useCache && ContentCache.db) {
        ContentCache.cacheFeed(url, result.text, null, result.etag).catch(e => {
          console.warn('[Cache] Failed to cache feed:', e);
        });
      }

      return result.text;
    } catch (e) {
      // On network failure, try returning stale cache
      if (ContentCache.db) {
        const staleCache = await new Promise((resolve) => {
          const tx = ContentCache.db.transaction(ContentCache.STORES.feeds, 'readonly');
          const store = tx.objectStore(ContentCache.STORES.feeds);
          const request = store.get(url);
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => resolve(null);
        });
        if (staleCache) {
          console.log('[Cache] Using stale cache after network failure:', url);
          return staleCache.xml;
        }
      }
      throw new Error(`All CORS proxies failed for: ${url}`);
    }
  };

  // Download audio file with progress tracking
  const downloadAudioFile = async (episodeId, audioUrl, onProgress) => {
    // Try direct fetch first, then CORS proxies
    const urlsToTry = [
      audioUrl,
      ...CORS_PROXIES.map(p => p(audioUrl))
    ];

    for (let i = 0; i < urlsToTry.length; i++) {
      const url = urlsToTry[i];
      try {
        const response = await fetch(url);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);

        const contentLength = response.headers.get('content-length');
        const total = contentLength ? parseInt(contentLength, 10) : 0;

        if (!response.body) {
          // Fallback for browsers without ReadableStream support
          const blob = await response.blob();
          if (onProgress) onProgress(100);
          return blob;
        }

        const reader = response.body.getReader();
        const chunks = [];
        let received = 0;

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          chunks.push(value);
          received += value.length;
          if (total && onProgress) {
            onProgress(Math.round((received / total) * 100));
          }
        }

        const blob = new Blob(chunks, { type: response.headers.get('content-type') || 'audio/mpeg' });
        if (onProgress) onProgress(100);
        return blob;
      } catch (e) {
        console.warn(`Download attempt ${i + 1} failed:`, e.message);
        if (i === urlsToTry.length - 1) throw e;
      }
    }
    throw new Error('All download attempts failed');
  };

  // Start downloading an episode
  const startDownload = async (episodeId) => {
    const ep = state.podcasts.find(p => p.id === episodeId);
    if (!ep || !ep.audioUrl) {
      toast('No audio URL for this episode');
      return;
    }

    if (downloadProgress[episodeId]?.status === 'downloading') {
      toast('Already downloading...');
      return;
    }

    downloadProgress[episodeId] = { progress: 0, status: 'downloading' };
    renderPodcasts();
    if (state.currentShowPage) renderShowPage(state.currentShowPage);

    try {
      toast('Starting download...');
      const blob = await downloadAudioFile(episodeId, ep.audioUrl, (progress) => {
        downloadProgress[episodeId].progress = progress;
        // Update UI periodically (not every progress update to avoid excessive re-renders)
        if (progress % 10 === 0 || progress === 100) {
          renderPodcasts();
          if (state.currentShowPage) renderShowPage(state.currentShowPage);
        }
      });

      // Save to IndexedDB
      await DownloadDB.save(episodeId, blob, {
        title: ep.title,
        audioUrl: ep.audioUrl,
        size: blob.size
      });

      ep.downloaded = true;
      downloadProgress[episodeId] = { progress: 100, status: 'done' };
      save();
      Mem.log('download_completed', episodeId, { size: blob.size, audioUrl: ep.audioUrl });
      toast('Download complete!');
    } catch (e) {
      console.error('Download failed:', e);
      downloadProgress[episodeId] = { progress: 0, status: 'error' };
      toast('Download failed: ' + e.message);
    }

    renderPodcasts();
    if (state.currentShowPage) renderShowPage(state.currentShowPage);
  };

  // Remove a downloaded episode
  const removeDownload = async (episodeId) => {
    const ep = state.podcasts.find(p => p.id === episodeId);
    if (!ep) return;

    try {
      await DownloadDB.delete(episodeId);
      ep.downloaded = false;
      delete downloadProgress[episodeId];
      save();
      Mem.log('download_removed', episodeId, { audioUrl: ep.audioUrl });
      toast('Download removed');
    } catch (e) {
      console.error('Failed to remove download:', e);
      toast('Failed to remove download');
    }

    renderPodcasts();
    if (state.currentShowPage) renderShowPage(state.currentShowPage);
  };

  const parseRSSDate = dateStr => {
    if (!dateStr) return new Date();
    const d = new Date(dateStr);
    return isNaN(d.getTime()) ? new Date() : d;
  };

  const formatTimeAgo = date => {
    const now = new Date();
    const diff = Math.floor((now - date) / 1000);
    if (diff < 60) return 'just now';
    if (diff < 3600) return Math.floor(diff / 60) + 'm ago';
    if (diff < 86400) return Math.floor(diff / 3600) + 'h ago';
    if (diff < 604800) return Math.floor(diff / 86400) + 'd ago';
    return Math.floor(diff / 604800) + 'w ago';
  };

  const parseDuration = dur => {
    if (!dur) return 0;
    // Handle HH:MM:SS or MM:SS format
    if (dur.includes(':')) {
      const parts = dur.split(':').map(Number);
      if (parts.length === 3) return parts[0] * 3600 + parts[1] * 60 + parts[2];
      if (parts.length === 2) return parts[0] * 60 + parts[1];
    }
    // Handle seconds as number
    const num = parseInt(dur, 10);
    return isNaN(num) ? 0 : num;
  };

  // Helper to find elements with namespace support (handles itunes:*, media:*, etc.)
  const findElement = (parent, tag) => {
    // Try getElementsByTagName first (works best with namespaced elements)
    let elements = parent.getElementsByTagName(tag);
    if (elements.length > 0) return elements[0];

    // Try without namespace prefix (for local names)
    const localName = tag.includes(':') ? tag.split(':')[1] : tag;
    elements = parent.getElementsByTagName(localName);
    if (elements.length > 0) return elements[0];

    // Try with wildcard namespace
    const nsElements = parent.getElementsByTagNameNS('*', localName);
    if (nsElements.length > 0) return nsElements[0];

    // Fallback to querySelector (may not work with namespaced elements in all browsers)
    try {
      const node = parent.querySelector(tag);
      if (node) return node;
    } catch(e) {
      // Selector may be invalid for namespaced tags
    }

    return null;
  };

  // Find all elements matching a tag (for items/entries)
  const findAllElements = (parent, tag) => {
    let elements = parent.getElementsByTagName(tag);
    if (elements.length > 0) return Array.from(elements);

    const localName = tag.includes(':') ? tag.split(':')[1] : tag;
    elements = parent.getElementsByTagName(localName);
    if (elements.length > 0) return Array.from(elements);

    return [];
  };

  const getNodeText = (parent, tag) => {
    const node = findElement(parent, tag);
    return node ? node.textContent?.trim() || '' : '';
  };

  const getNodeAttr = (parent, tag, attr) => {
    const node = findElement(parent, tag);
    return node ? node.getAttribute(attr) || '' : '';
  };

  // Get image from itunes:image element (has href attribute)
  const getItunesImage = (parent) => {
    // iTunes namespace URI
    const itunesNS = 'http://www.itunes.com/dtds/podcast-1.0.dtd';

    // Try getElementsByTagNameNS with iTunes namespace
    try {
      let elements = parent.getElementsByTagNameNS(itunesNS, 'image');
      if (elements.length > 0) {
        const href = elements[0].getAttribute('href');
        if (href) { console.log('[getItunesImage] Method 1 (NS) succeeded'); return href; }
      }
    } catch(e) {}

    // Try itunes:image with colon
    try {
      let elements = parent.getElementsByTagName('itunes:image');
      if (elements.length > 0) {
        const href = elements[0].getAttribute('href');
        if (href) { console.log('[getItunesImage] Method 2 (colon) succeeded'); return href; }
      }
    } catch(e) {}

    // Try wildcard namespace with local name 'image'
    try {
      const elements = parent.getElementsByTagNameNS('*', 'image');
      for (let i = 0; i < elements.length; i++) {
        const href = elements[i].getAttribute('href');
        if (href) { console.log('[getItunesImage] Method 3 (wildcard NS) succeeded'); return href; }
      }
    } catch(e) {}

    // Try just 'image' elements with href attribute
    const imageEls = parent.getElementsByTagName('image');
    for (let i = 0; i < imageEls.length; i++) {
      const href = imageEls[i].getAttribute('href');
      if (href) { console.log('[getItunesImage] Method 4 (plain image) succeeded'); return href; }
    }

    // FALLBACK: Find ANY element with href attribute that looks like an image URL
    // This catches itunes:image when namespace parsing fails (common with Patreon feeds)
    try {
      const allElements = parent.getElementsByTagName('*');
      for (let i = 0; i < allElements.length; i++) {
        const el = allElements[i];
        const tagName = el.tagName.toLowerCase();
        // Only check elements that look like image tags
        if (!tagName.includes('image') && tagName !== 'logo' && tagName !== 'icon') continue;
        const href = el.getAttribute('href');
        if (href) { console.log('[getItunesImage] Method 5 (tagName includes image) succeeded:', tagName); return href; }
      }
    } catch(e) {}

    // LAST RESORT: Find first href that looks like an image URL (jpg/png)
    try {
      const allElements = parent.getElementsByTagName('*');
      for (let i = 0; i < allElements.length; i++) {
        const href = allElements[i].getAttribute('href');
        if (href && /\.(jpg|jpeg|png|gif|webp)/i.test(href)) {
          console.log('[getItunesImage] Method 6 (href ends with image ext) succeeded');
          return href;
        }
      }
    } catch(e) {}

    console.log('[getItunesImage] All methods failed');
    return '';
  };

  // Check if URL looks like a valid image URL (not just a homepage)
  const isValidImageUrl = url => {
    if (!url) return false;
    try {
      const parsed = new URL(url);
      // Reject URLs that are just hostnames with no meaningful path
      if (parsed.pathname === '/' || parsed.pathname === '') return false;
      // Accept URLs with image extensions or meaningful paths
      const imageExtensions = /\.(jpg|jpeg|png|gif|webp|svg|bmp|ico|avif)(\?|$)/i;
      if (imageExtensions.test(parsed.pathname)) return true;
      // Accept URLs with paths that look like they could be images
      if (parsed.pathname.length > 1) return true;
      return false;
    } catch (e) {
      return false;
    }
  };

  // Check if URL looks like a tracking pixel or icon (not a main image)
  const isLikelyTrackingOrIcon = url => {
    if (!url) return true;
    const lowUrl = url.toLowerCase();
    // Common tracking pixel patterns
    if (/pixel|track|beacon|analytics|stat|count|1x1|spacer/i.test(lowUrl)) return true;
    // Favicon patterns
    if (/favicon|icon\d*\.|apple-touch/i.test(lowUrl)) return true;
    // Common ad/tracking domains
    if (/doubleclick|googlesyndication|facebook\.com\/tr|analytics/i.test(lowUrl)) return true;
    return false;
  };

  // Extract dimensions from img tag attributes or URL
  const extractImageScore = (imgTag, url) => {
    let score = 0;
    // Check for explicit dimensions in tag
    const widthMatch = imgTag.match(/width=["']?(\d+)/i);
    const heightMatch = imgTag.match(/height=["']?(\d+)/i);
    if (widthMatch) score += parseInt(widthMatch[1]);
    if (heightMatch) score += parseInt(heightMatch[1]);
    // Bonus for large images
    if (widthMatch && parseInt(widthMatch[1]) >= 400) score += 500;
    if (heightMatch && parseInt(heightMatch[1]) >= 300) score += 500;
    // Penalty for tiny images (likely icons/tracking)
    if (widthMatch && parseInt(widthMatch[1]) < 50) score -= 1000;
    if (heightMatch && parseInt(heightMatch[1]) < 50) score -= 1000;
    // Look for size hints in URL
    if (/large|big|full|hero|featured|main|og[_-]?image/i.test(url)) score += 300;
    if (/thumb|small|tiny|icon|avatar|logo/i.test(url)) score -= 200;
    // Penalty for tracking pixels
    if (isLikelyTrackingOrIcon(url)) score -= 2000;
    return score;
  };

  // Get best URL from srcset attribute
  const getBestFromSrcset = srcset => {
    if (!srcset) return null;
    const candidates = srcset.split(',').map(s => {
      const parts = s.trim().split(/\s+/);
      const url = parts[0];
      let width = 0;
      if (parts[1]) {
        const wMatch = parts[1].match(/(\d+)w/);
        if (wMatch) width = parseInt(wMatch[1]);
      }
      return { url, width };
    }).filter(c => c.url && isValidImageUrl(c.url));
    if (!candidates.length) return null;
    // Return the largest image
    candidates.sort((a, b) => b.width - a.width);
    return candidates[0].url;
  };

  const extractImage = item => {
    // 1. Try media:content - find the best one (largest image type)
    const mediaContents = item.getElementsByTagName('media:content');
    let bestMediaContent = null;
    let bestMediaScore = -1;
    for (let i = 0; i < mediaContents.length; i++) {
      const mc = mediaContents[i];
      const url = mc.getAttribute('url');
      const medium = mc.getAttribute('medium');
      const type = mc.getAttribute('type') || '';
      const width = parseInt(mc.getAttribute('width')) || 0;
      const height = parseInt(mc.getAttribute('height')) || 0;

      if (!url || !isValidImageUrl(url)) continue;
      if (isLikelyTrackingOrIcon(url)) continue;

      // Skip non-image media
      if (medium && medium !== 'image') continue;
      if (type && !type.startsWith('image/')) continue;

      const score = width + height + (medium === 'image' ? 100 : 0);
      if (score > bestMediaScore) {
        bestMediaScore = score;
        bestMediaContent = url;
      }
    }
    if (bestMediaContent) return bestMediaContent;

    // 2. Try media:thumbnail (often used for article thumbnails)
    const thumbnails = item.getElementsByTagName('media:thumbnail');
    let bestThumb = null;
    let bestThumbScore = -1;
    for (let i = 0; i < thumbnails.length; i++) {
      const t = thumbnails[i];
      const url = t.getAttribute('url');
      const width = parseInt(t.getAttribute('width')) || 0;
      const height = parseInt(t.getAttribute('height')) || 0;
      if (url && isValidImageUrl(url) && !isLikelyTrackingOrIcon(url)) {
        const score = width + height;
        if (score > bestThumbScore) {
          bestThumbScore = score;
          bestThumb = url;
        }
      }
    }
    if (bestThumb) return bestThumb;

    // 3. Try media:group (contains multiple media elements)
    const mediaGroups = item.getElementsByTagName('media:group');
    for (let i = 0; i < mediaGroups.length; i++) {
      const group = mediaGroups[i];
      const contents = group.getElementsByTagName('media:content');
      for (let j = 0; j < contents.length; j++) {
        const url = contents[j].getAttribute('url');
        const type = contents[j].getAttribute('type') || '';
        if (url && (type.startsWith('image/') || isValidImageUrl(url)) && !isLikelyTrackingOrIcon(url)) {
          return url;
        }
      }
    }

    // 4. Try enclosure with image type OR image-like URL
    const enclosures = item.getElementsByTagName('enclosure');
    for (let i = 0; i < enclosures.length; i++) {
      const enc = enclosures[i];
      const type = enc.getAttribute('type') || '';
      const url = enc.getAttribute('url') || '';
      if (type.startsWith('image/') && isValidImageUrl(url)) {
        return url;
      }
      // Also check if URL looks like an image even without proper type
      if (!type && /\.(jpg|jpeg|png|gif|webp|avif)(\?|$)/i.test(url)) {
        return url;
      }
    }

    // 5. Try image element with url attribute (some RSS 2.0 feeds)
    const imageEl = findElement(item, 'image');
    if (imageEl) {
      const urlEl = findElement(imageEl, 'url');
      if (urlEl && urlEl.textContent && isValidImageUrl(urlEl.textContent.trim())) {
        return urlEl.textContent.trim();
      }
    }

    // 6. Try to extract from description/content HTML - find best image
    const desc = getNodeText(item, 'description') || getNodeText(item, 'content:encoded') || getNodeText(item, 'content') || getNodeText(item, 'summary');
    if (desc) {
      // Find all img tags
      const imgRegex = /<img[^>]+>/gi;
      const imgTags = desc.match(imgRegex) || [];

      let bestImg = null;
      let bestScore = -Infinity;

      for (const imgTag of imgTags) {
        // Extract src
        const srcMatch = imgTag.match(/src=["']([^"']+)["']/i);
        if (!srcMatch) continue;
        let src = srcMatch[1];

        // Check srcset for better quality
        const srcsetMatch = imgTag.match(/srcset=["']([^"']+)["']/i);
        if (srcsetMatch) {
          const betterSrc = getBestFromSrcset(srcsetMatch[1]);
          if (betterSrc) src = betterSrc;
        }

        if (!isValidImageUrl(src)) continue;

        const score = extractImageScore(imgTag, src);
        if (score > bestScore) {
          bestScore = score;
          bestImg = src;
        }
      }

      if (bestImg && bestScore > -500) return bestImg;

      // Fallback: try figure > img pattern
      const figureMatch = desc.match(/<figure[^>]*>.*?<img[^>]+src=["']([^"']+)["'][^>]*>.*?<\/figure>/is);
      if (figureMatch && isValidImageUrl(figureMatch[1]) && !isLikelyTrackingOrIcon(figureMatch[1])) {
        return figureMatch[1];
      }
    }

    return '';
  };

  const parseNewsFeed = (xml, feedId, feedUrl) => {
    const parser = new DOMParser();
    const doc = parser.parseFromString(xml, 'text/xml');

    const parserError = doc.querySelector('parsererror');
    if (parserError) {
      throw new Error('Invalid RSS feed XML');
    }

    // Use getElementsByTagName for better namespace compatibility (like podcast parser)
    let items = Array.from(doc.getElementsByTagName('item'));
    if (items.length === 0) {
      // Try Atom entry format
      items = Array.from(doc.getElementsByTagName('entry'));
    }
    const articles = [];

    items.forEach((item, index) => {
      const title = getNodeText(item, 'title');
      if (!title) return;

      const pubDate = parseRSSDate(
        getNodeText(item, 'pubDate') ||
        getNodeText(item, 'published') ||
        getNodeText(item, 'updated') ||
        getNodeText(item, 'dc:date')
      );

      // Get description and clean HTML
      let summary = getNodeText(item, 'description') || getNodeText(item, 'summary') || getNodeText(item, 'content:encoded') || '';
      // Strip HTML tags for summary
      const tmp = document.createElement('div');
      tmp.innerHTML = summary;
      summary = tmp.textContent?.trim().slice(0, 300) || '';

      // For RSS feeds, link is text content. For Atom feeds, link is in href attribute.
      // Also handle Atom feeds with multiple links (prefer rel="alternate")
      let link = getNodeText(item, 'link');
      if (!link) {
        // Atom feed - look for link elements with href attribute
        const linkElements = item.getElementsByTagName('link');
        for (let i = 0; i < linkElements.length; i++) {
          const rel = linkElements[i].getAttribute('rel') || 'alternate';
          if (rel === 'alternate') {
            link = linkElements[i].getAttribute('href') || '';
            break;
          }
        }
        // Fallback to first link if no alternate found
        if (!link && linkElements.length > 0) {
          link = linkElements[0].getAttribute('href') || '';
        }
      }
      const image = extractImage(item);

      // Create stable GUID using feed URL and article link/title
      // This ensures the same article always has the same ID even after feed deletion/re-add
      const uniqueId = GUID.forArticle(feedUrl, link, title, pubDate.toISOString());

      articles.push({
        id: uniqueId,
        feedId,
        title,
        summary,
        link,
        time: formatTimeAgo(pubDate),
        pubDate: pubDate.toISOString(),
        image,
        unread: true
      });
    });

    return articles;
  };

  const parsePodcastFeed = (xml, feedId, feedUrl) => {
    const parser = new DOMParser();
    const doc = parser.parseFromString(xml, 'text/xml');

    const parserError = doc.querySelector('parsererror');
    if (parserError) {
      console.error('XML parse error:', parserError.textContent);
      throw new Error('Invalid podcast feed XML');
    }

    // Get channel element for fallback image
    const channel = doc.querySelector('channel') || doc.querySelector('feed');
    let channelImage = '';
    if (channel) {
      channelImage = getItunesImage(channel);
      if (!channelImage) {
        // Try standard RSS image/url
        const imageEl = channel.querySelector('image');
        if (imageEl) {
          const urlEl = imageEl.querySelector('url');
          if (urlEl) channelImage = urlEl.textContent?.trim() || '';
        }
      }
    }

    // Find all items - use getElementsByTagName for better compatibility
    const items = Array.from(doc.getElementsByTagName('item'));
    if (items.length === 0) {
      // Try Atom entry format
      items.push(...Array.from(doc.getElementsByTagName('entry')));
    }

    console.log('Parsing podcast feed, found', items.length, 'items');
    const episodes = [];

    items.forEach((item, index) => {
      const title = getNodeText(item, 'title');
      if (!title) return;

      // Get audio enclosure - try multiple methods
      let audioUrl = '';
      const enclosures = item.getElementsByTagName('enclosure');
      for (let i = 0; i < enclosures.length; i++) {
        const enc = enclosures[i];
        const type = enc.getAttribute('type') || '';
        const url = enc.getAttribute('url') || '';
        if (url && (type.includes('audio') || type.includes('video') || !type)) {
          audioUrl = url;
          break;
        }
      }

      // Fallback to link with enclosure rel for Atom
      if (!audioUrl) {
        const links = item.getElementsByTagName('link');
        for (let i = 0; i < links.length; i++) {
          const link = links[i];
          if (link.getAttribute('rel') === 'enclosure') {
            audioUrl = link.getAttribute('href') || '';
            break;
          }
        }
      }

      const pubDate = parseRSSDate(
        getNodeText(item, 'pubDate') ||
        getNodeText(item, 'published') ||
        getNodeText(item, 'updated')
      );

      // Get duration from itunes:duration - try multiple approaches
      let durationStr = '';
      const durationEls = item.getElementsByTagName('itunes:duration');
      if (durationEls.length > 0) {
        durationStr = durationEls[0].textContent?.trim() || '';
      }
      if (!durationStr) {
        const durEls = item.getElementsByTagName('duration');
        if (durEls.length > 0) {
          durationStr = durEls[0].textContent?.trim() || '';
        }
      }
      const duration = parseDuration(durationStr);

      // Get description - try multiple fields, prefer content:encoded for full HTML
      let descHtml = '';
      let desc = '';
      // First try to get HTML content from content:encoded
      const contentEncoded = item.getElementsByTagName('content:encoded');
      if (contentEncoded.length > 0) {
        descHtml = contentEncoded[0].textContent?.trim() || '';
      }
      // Then try other fields for fallback
      const descFields = ['itunes:summary', 'description', 'summary', 'itunes:subtitle'];
      for (const field of descFields) {
        const els = item.getElementsByTagName(field);
        if (els.length > 0 && els[0].textContent?.trim()) {
          if (!descHtml) {
            descHtml = els[0].textContent.trim();
          }
          // Get plain text version for preview
          const tmp = document.createElement('div');
          tmp.innerHTML = els[0].textContent.trim();
          desc = tmp.textContent?.trim().slice(0, 300) || '';
          break;
        }
      }
      // If we have HTML but no plain text preview, create one
      if (descHtml && !desc) {
        const tmp = document.createElement('div');
        tmp.innerHTML = descHtml;
        desc = tmp.textContent?.trim().slice(0, 300) || '';
      }

      // Get episode image - try multiple approaches
      let image = getItunesImage(item);
      const itunesImg = image;
      if (!image) {
        image = extractImage(item);
      }
      const extractedImg = image;
      // Fallback to channel image
      if (!image) {
        image = channelImage;
      }
      // Debug logging for image extraction
      console.log(`[Image] Episode "${title.slice(0,30)}...": itunes=${itunesImg ? 'YES' : 'NO'}, extracted=${extractedImg ? 'YES' : 'NO'}, final=${image ? image.slice(0,50) + '...' : 'NONE'}`);

      // Create stable GUID using feed URL and audio URL/title
      // This ensures the same episode always has the same ID even after feed deletion/re-add
      const uniqueId = GUID.forEpisode(feedUrl, audioUrl, title, pubDate.toISOString());

      episodes.push({
        id: uniqueId,
        feedId,
        title,
        desc,
        descHtml, // Full HTML description for detail page
        duration: duration || 1800, // Default 30 min if no duration
        date: formatTimeAgo(pubDate),
        pubDate: pubDate.toISOString(),
        image,
        audioUrl,
        downloaded: false
      });
    });

    console.log('Parsed', episodes.length, 'episodes');
    return episodes;
  };

  const extractFeedMeta = xml => {
    const parser = new DOMParser();
    const doc = parser.parseFromString(xml, 'text/xml');

    const channel = doc.querySelector('channel') || doc.querySelector('feed');
    if (!channel) return {};

    // Get image - try multiple methods
    let image = getItunesImage(channel);

    if (!image) {
      // Try standard RSS image element with url child
      const imageEl = channel.querySelector('image');
      if (imageEl) {
        const urlEl = imageEl.querySelector('url');
        if (urlEl) {
          image = urlEl.textContent?.trim() || '';
        }
        if (!image) {
          image = imageEl.getAttribute('href') || '';
        }
      }
    }

    if (!image) {
      // Try Atom logo
      const logoEl = channel.querySelector('logo');
      if (logoEl) {
        image = logoEl.textContent?.trim() || logoEl.getAttribute('src') || '';
      }
    }

    // Get author - try multiple approaches
    let author = '';
    const authorFields = ['itunes:author', 'author', 'managingEditor', 'dc:creator'];
    for (const field of authorFields) {
      const els = channel.getElementsByTagName(field);
      if (els.length > 0 && els[0].textContent?.trim()) {
        author = els[0].textContent.trim();
        break;
      }
    }

    // Get itunes category for podcasts
    let itunesCategory = '';
    const categoryEls = channel.getElementsByTagName('itunes:category');
    if (categoryEls.length > 0) {
      itunesCategory = categoryEls[0].getAttribute('text') || '';
    }

    return {
      title: getNodeText(channel, 'title'),
      description: getNodeText(channel, 'description') || getNodeText(channel, 'subtitle'),
      author,
      image,
      itunesCategory
    };
  };

  // Normalize feed URL - convert podcast://, feed://, etc. to https://
  const normalizeFeedUrl = (url) => {
    // Replace common podcast URL schemes with https
    const schemes = ['podcast://', 'pcast://', 'feed://', 'podcasts://'];
    for (const scheme of schemes) {
      if (url.toLowerCase().startsWith(scheme)) {
        return 'https://' + url.slice(scheme.length);
      }
    }
    // Handle http:// -> https:// upgrade
    if (url.toLowerCase().startsWith('http://')) {
      return 'https://' + url.slice(7);
    }
    return url;
  };

  // Fetch feed metadata without adding it - for preview/auto-detect
  const fetchFeedMetadata = async (url) => {
    try {
      const normalizedUrl = normalizeFeedUrl(url);
      const xml = await fetchWithProxy(normalizedUrl);
      const meta = extractFeedMeta(xml);

      // Also try to detect feed type based on content
      const parser = new DOMParser();
      const doc = parser.parseFromString(xml, 'text/xml');
      const hasEnclosure = doc.querySelector('enclosure[type^="audio"], enclosure[type^="video"]');
      const hasItunesNs = xml.includes('xmlns:itunes') || xml.includes('itunes:');
      const suggestedType = (hasEnclosure || hasItunesNs) ? 'podcast' : 'news';

      return {
        success: true,
        title: meta.title || '',
        author: meta.author || '',
        description: meta.description || '',
        image: meta.image || '',
        suggestedType
      };
    } catch (e) {
      console.error('Failed to fetch feed metadata:', e);
      return {
        success: false,
        error: e.message
      };
    }
  };

  // Fetch and parse a single feed - returns result data without mutating state
  // This prevents race conditions when fetching multiple feeds in parallel
  const fetchAndParseFeed = async feed => {
    try {
      const normalizedUrl = normalizeFeedUrl(feed.url);
      const xml = await fetchWithProxy(normalizedUrl);
      const meta = extractFeedMeta(xml);

      // Build feed metadata updates (don't mutate feed directly during parallel fetch)
      const feedUpdates = {};
      if (meta.title && (!feed.name || feed.name === 'Loading...')) feedUpdates.name = meta.title;
      if (meta.image && !feed.image) feedUpdates.image = meta.image;
      if (meta.author && !feed.author) feedUpdates.author = meta.author;
      if (meta.description) feedUpdates.description = meta.description;

      // Auto-detect tags for the feed if not already set
      const feedContentSample = meta.description || meta.itunesCategory || '';
      if (!feed.tags || feed.tags.length === 0) {
        feedUpdates.tags = autoDetectFeedTags({ ...feed, ...feedUpdates }, feedContentSample);
        console.log(`Auto-detected tags for ${feedUpdates.name || feed.name}:`, feedUpdates.tags.map(t => getTagInfo(t).label));
      }

      feedUpdates.lastFetched = new Date().toISOString();
      feedUpdates.error = null;

      // Return result object instead of mutating state
      const result = {
        feedId: feed.id,
        feedUpdates,
        success: true
      };

      if (feed.type === 'news') {
        const articles = parseNewsFeed(xml, feed.id, feed.url);

        // Auto-tag each article
        articles.forEach(article => {
          article.tags = autoDetectItemTags(article, feed.tags || feedUpdates.tags || []);
        });

        result.type = 'news';
        result.items = articles;
      } else {
        const episodes = parsePodcastFeed(xml, feed.id, feed.url);

        // Auto-tag each episode
        episodes.forEach(episode => {
          episode.tags = autoDetectItemTags(episode, feed.tags || feedUpdates.tags || []);
        });

        result.type = 'podcast';
        result.items = episodes;
      }

      return result;
    } catch (e) {
      console.error(`Failed to fetch feed ${feed.name}:`, e);
      return {
        feedId: feed.id,
        feedUpdates: { error: e.message },
        success: false
      };
    }
  };

  // Apply feed results to state (called AFTER all parallel fetches complete)
  const applyFeedResults = (results) => {
    for (const result of results) {
      if (!result || result.status === 'rejected') continue;

      const { feedId, feedUpdates, success, type, items } = result.value || result;
      const feed = state.feeds.find(f => f.id === feedId);
      if (!feed) continue;

      // Apply feed metadata updates
      Object.assign(feed, feedUpdates);

      if (!success || !items) continue;

      if (type === 'news') {
        // Get all existing articles for this feed (including archived)
        const existingArticles = state.articles.filter(a => a.feedId === feedId);
        const archivedForFeed = state.archivedArticles.filter(a => a.feedId === feedId);

        // Create sets of existing titles (both active and archived)
        const existingTitles = new Set(existingArticles.map(a => a.title));
        const archivedTitles = new Set(archivedForFeed.map(a => a.title));

        // Find articles that are in current list but NOT in new feed (they're being archived)
        const currentTitlesInFeed = new Set(items.map(a => a.title));
        const toArchive = existingArticles.filter(a => !currentTitlesInFeed.has(a.title));

        // Archive items that fell off the feed (preserve history)
        if (toArchive.length > 0) {
          toArchive.forEach(a => a.archived = true);
          state.archivedArticles = [...state.archivedArticles, ...toArchive];
          // Limit archived items per feed to prevent unbounded growth (keep last 500)
          const feedArchived = state.archivedArticles.filter(a => a.feedId === feedId);
          if (feedArchived.length > 500) {
            const toRemove = feedArchived.slice(0, feedArchived.length - 500).map(a => a.id);
            state.archivedArticles = state.archivedArticles.filter(a => !toRemove.includes(a.id));
          }
        }

        // Update articles: preserve user state
        const updatedArticles = items.map(feedArticle => {
          const existing = existingArticles.find(a => a.title === feedArticle.title);
          if (existing) {
            return { ...feedArticle, unread: existing.unread, tags: existing.tags?.length ? existing.tags : feedArticle.tags };
          }
          return feedArticle;
        });

        // Replace only this feed's articles (atomic per-feed update)
        state.articles = [
          ...state.articles.filter(a => a.feedId !== feedId),
          ...updatedArticles
        ];

        // Update unread count
        feed.unread = updatedArticles.filter(a => a.unread).length;

      } else if (type === 'podcast') {
        // Get all existing episodes for this feed (including archived)
        const existingEpisodes = state.podcasts.filter(p => p.feedId === feedId);
        const archivedForFeed = state.archivedPodcasts.filter(p => p.feedId === feedId);

        // Find episodes to archive
        const currentTitlesInFeed = new Set(items.map(e => e.title));
        const toArchive = existingEpisodes.filter(p => !currentTitlesInFeed.has(p.title));

        // Archive episodes that fell off the feed
        if (toArchive.length > 0) {
          toArchive.forEach(p => p.archived = true);
          state.archivedPodcasts = [...state.archivedPodcasts, ...toArchive];
          // Limit archived per feed
          const feedArchived = state.archivedPodcasts.filter(p => p.feedId === feedId);
          if (feedArchived.length > 500) {
            const toRemove = feedArchived.slice(0, feedArchived.length - 500).map(p => p.id);
            state.archivedPodcasts = state.archivedPodcasts.filter(p => !toRemove.includes(p.id));
          }
        }

        // Update episodes: preserve user state (progress, downloaded, etc.)
        const updatedEpisodes = items.map(feedEp => {
          const existing = existingEpisodes.find(p => p.title === feedEp.title);
          if (existing) {
            return {
              ...feedEp,
              downloaded: existing.downloaded,
              tags: existing.tags?.length ? existing.tags : feedEp.tags
            };
          }
          return feedEp;
        });

        // Replace only this feed's episodes (atomic per-feed update)
        state.podcasts = [
          ...state.podcasts.filter(p => p.feedId !== feedId),
          ...updatedEpisodes
        ];
      }
    }

    // Sort all articles and podcasts once at the end
    state.articles.sort((a, b) => new Date(b.pubDate || 0) - new Date(a.pubDate || 0));
    state.podcasts.sort((a, b) => new Date(b.pubDate || 0) - new Date(a.pubDate || 0));
  };

  const refreshAllFeeds = async (silent = false) => {
    if (state.refreshing) return;
    state.refreshing = true;

    // Add spinning animation to refresh button
    const refreshBtn = $('refreshBtn');
    if (refreshBtn) {
      refreshBtn.style.animation = 'spin 1s linear infinite';
      refreshBtn.disabled = true;
    }

    if (!silent) toast('Refreshing feeds...');

    // Create snapshot before refresh (content may change)
    try {
      await SnapshotDB.createSnapshot('before_refresh');
    } catch (e) {
      console.warn('Failed to create pre-refresh snapshot:', e);
    }

    const results = await Promise.allSettled(
      state.feeds.map(feed => fetchAndParseFeed(feed))
    );

    // Apply all results atomically AFTER parallel fetches complete
    // This prevents race conditions where later-finishing fetches overwrite earlier ones
    applyFeedResults(results);

    const success = results.filter(r => r.status === 'fulfilled' && r.value?.success).length;
    const failed = results.length - success;

    state.refreshing = false;

    // Stop spinning animation
    if (refreshBtn) {
      refreshBtn.style.animation = '';
      refreshBtn.disabled = false;
    }

    save();
    renderNewsSources();
    renderCategories();
    renderTagFilters();
    renderNews();
    if (state.view === 'podcasts') renderPodcasts();
    if (state.view === 'all') renderAll();

    if (failed > 0) {
      toast(`Refreshed ${success} feeds, ${failed} failed`);
    } else if (success > 0 && !silent) {
      toast(`Refreshed ${success} feeds`);
    }
  };

  const addFeed = async (url, name, type, category, author) => {
    const id = GUID.forFeed(url);
    const feed = {
      id,
      url,
      name: name || 'Loading...',
      type,
      category: category || 'Uncategorized',
      image: '',
      author: author || '',
      unread: 0,
      tags: [], // Will be auto-detected during fetch
      description: '',
      addedAt: Date.now() // Track when feed was added locally for sync protection
    };

    console.log('[AddFeed] Adding new feed:', { url, name, type, category });
    state.feeds.push(feed);
    state.categories.add(feed.category);
    console.log('[AddFeed] Total feeds now:', state.feeds.length);

    // Track subscription for user behavior API
    state.userBehavior.subscriptions.push({
      feedId: id,
      timestamp: new Date().toISOString(),
      action: 'add',
      feedType: type
    });

    // Log feed subscription to Xano memory for cross-device tracking
    Mem.log('feed_added', id, {
      url: url,
      name: name || 'Loading...',
      type: type,
      category: category || 'Uncategorized',
      author: author || ''
    });

    // Sync feeding activity to activity-post endpoint
    FeedingActivity.log('feed_added', {
      feedId: id,
      url: url,
      name: name || 'Loading...',
      type: type,
      category: category || 'Uncategorized',
      author: author || ''
    });

    console.log('[AddFeed] Saving to localStorage and syncing to API...');
    save(true); // Immediate sync for feed addition

    toast('Adding feed...');
    const success = await fetchAndParseFeed(feed);

    if (success) {
      // Log tags that were auto-detected
      if (feed.tags.length > 0) {
        const tagLabels = feed.tags.map(t => getTagInfo(t).label).join(', ');
        console.log(`Feed ${feed.name} auto-tagged: ${tagLabels}`);
      }
      console.log('[AddFeed] Feed content loaded successfully. Saving again...');
      save(true); // Immediate sync after content loaded
      renderNewsSources();
      renderPodcastSources(); // Always update podcast sidebar too (for image/name updates)
      renderCategories();
      renderNews();
      renderTagFilters();
      if (state.view === 'podcasts') renderPodcastInbox();
      if (state.view === 'all') renderAll();
      toast(`Added: ${feed.name}`);
    } else {
      // Keep the feed but show error - still render to show the feed was added
      renderNewsSources();
      renderPodcastSources();
      if (state.view === 'podcasts') renderPodcastInbox();
      if (state.view === 'all') renderAll();
      toast(`Added ${feed.name} (fetch failed)`);
    }

    return success;
  };

  // Remove a feed from the app
  const removeFeed = async (feedId) => {
    const feed = state.feeds.find(f => f.id === feedId);
    if (!feed) return;

    const feedName = feed.name;
    const feedType = feed.type;
    const feedUrl = feed.url;

    // Confirm deletion
    if (!confirm(`Remove "${feedName}" from your feeds?\n\nThis will also remove all ${feedType === 'news' ? 'articles' : 'episodes'} from this feed.`)) {
      return;
    }

    // Create a snapshot before deletion (safety net for accidental deletions)
    try {
      await SnapshotDB.createSnapshot('before_delete');
    } catch (e) {
      console.warn('Failed to create pre-delete snapshot:', e);
      // Continue with deletion even if snapshot fails
    }

    // Remove the feed from state
    state.feeds = state.feeds.filter(f => f.id !== feedId);

    // Remove associated content
    if (feedType === 'news') {
      // Move articles to archived before removing (preserves history)
      const feedArticles = state.articles.filter(a => a.feedId === feedId);
      state.archivedArticles.push(...feedArticles);
      state.articles = state.articles.filter(a => a.feedId !== feedId);
    } else {
      // Move episodes to archived before removing (preserves history)
      const feedPodcasts = state.podcasts.filter(p => p.feedId === feedId);
      state.archivedPodcasts.push(...feedPodcasts);
      state.podcasts = state.podcasts.filter(p => p.feedId !== feedId);
    }

    // Track subscription removal for user behavior API
    state.userBehavior.subscriptions.push({
      feedId: feedId,
      timestamp: new Date().toISOString(),
      action: 'remove',
      feedType: feedType
    });

    // Log feed removal to Xano memory for cross-device tracking
    Mem.log('feed_removed', feedId, {
      url: feedUrl,
      name: feedName,
      type: feedType
    });

    // Sync feeding activity to activity-post endpoint
    FeedingActivity.log('feed_removed', {
      feedId: feedId,
      url: feedUrl,
      name: feedName,
      type: feedType
    });

    // Save state with immediate sync
    save(true);

    // Close detail page and re-render
    if (feedType === 'news') {
      closeSourcePage();
      renderNewsSources();
      renderNews();
      renderCategories();
      renderTagFilters();
    } else {
      closeShowPage();
      renderPodcastSources();
      renderPodcasts();
    }

    toast(`Removed: ${feedName}`);
  };

  // Placeholder SVG for lazy-loaded images
  const placeholderImg = 'data:image/svg+xml,' + encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><rect fill="#1a1a1a" width="100" height="100"/><path d="M50 20c-5.5 0-10 4.5-10 10v20c0 5.5 4.5 10 10 10s10-4.5 10-10V30c0-5.5-4.5-10-10-10zm20 30c0 11-9 20-20 20s-20-9-20-20h-5c0 13.3 10.1 24.2 23 25.7V85h4V75.7c12.9-1.5 23-12.4 23-25.7h-5z" fill="#666" transform="translate(0,5)"/></svg>');

  // === RENDER NEWS ===
  const renderNewsSources = () => {
    const news = state.feeds.filter(f => f.type === 'news');
    el.newsSources.innerHTML = `<div class="source-item ${!state.selectedSource && !state.currentSourcePage ? 'active' : ''}" data-id="all"><div class="source-icon"><i class="ph ph-books"></i></div><div class="source-name">All Sources</div></div>` +
      news.map(f => {
        const hasNew = feedHasNewContent(f.id);
        const newCount = getNewItemCount(f.id);
        const newestDate = getNewestContentDate(f.id);
        const updatedText = hasNew && newestDate ? formatUpdatedAgo(newestDate) : '';
        const subtitle = hasNew ? (newCount > 0 ? `${newCount} new` : updatedText) : '';

        return `<div class="source-item ${state.currentSourcePage === f.id ? 'active' : ''} ${hasNew ? 'has-new' : ''}" data-id="${f.id}">
          ${hasNew ? '<span class="new-indicator"></span>' : ''}
          <div class="source-icon">${f.image ? `<img src="${f.image}" onerror="this.parentElement.innerHTML='<i class=\\'ph ph-newspaper\\'></i>'">` : '<i class="ph ph-newspaper"></i>'}</div>
          <div class="source-info">
            <div class="source-name">${f.name}</div>
            ${subtitle ? `<div class="source-subtitle">${subtitle}</div>` : ''}
          </div>
          <span class="source-arrow">â†’</span>
        </div>`;
      }).join('');
  };
  
  const renderCategories = () => {
    const cats = ['All', ...Array.from(state.categories).filter(c => c !== 'All')];
    el.categoryChips.innerHTML = cats.map(c => `<button class="chip ${state.selectedCat === c ? 'active' : ''}" data-cat="${c}">${c}</button>`).join('');
  };

  // Render tag filter chips based on what tags exist in current content
  const renderTagFilters = () => {
    // Collect all tags from articles and count occurrences
    const tagCounts = {};
    state.articles.forEach(a => {
      if (a.tags) {
        a.tags.forEach(tag => {
          tagCounts[tag] = (tagCounts[tag] || 0) + 1;
        });
      }
    });

    // Also include tags from feeds
    state.feeds.filter(f => f.type === 'news').forEach(f => {
      if (f.tags) {
        f.tags.forEach(tag => {
          if (!tagCounts[tag]) tagCounts[tag] = 0;
        });
      }
    });

    // Sort tags by count descending
    const sortedTags = Object.entries(tagCounts)
      .filter(([_, count]) => count > 0)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 12); // Limit to top 12 tags

    if (sortedTags.length === 0) {
      el.tagFilterSection.style.display = 'none';
      return;
    }

    el.tagFilterSection.style.display = 'block';
    el.tagChips.innerHTML = `
      <button class="tag-chip ${state.selectedTag === 'all' ? 'active' : ''}" data-tag="all">
        <span class="tag-icon"><i class="ph ph-tag"></i></span>All
      </button>
      ${sortedTags.map(([tag, count]) => {
        const info = getTagInfo(tag);
        return `<button class="tag-chip ${state.selectedTag === tag ? 'active' : ''}" data-tag="${tag}">
          <span class="tag-icon">${info.icon}</span>${info.label}<span class="tag-count">${count}</span>
        </button>`;
      }).join('')}
    `;
  };

  // Helper to render item tags as badges
  const renderItemTags = (tags) => {
    if (!tags || tags.length === 0) return '';
    return `<div class="item-tags">${tags.slice(0, 2).map(tag => {
      const info = getTagInfo(tag);
      return `<span class="item-tag"><span class="item-tag-icon">${info.icon}</span>${info.label}</span>`;
    }).join('')}</div>`;
  };
  
  // Store filtered items for news pagination
  let newsInboxItems = [];

  const renderNews = (append = false) => {
    Perf.mark('renderNews');

    // Render mobile news header
    if (!append) {
      renderMobileNewsHeader();
    }

    // Only recalculate items on fresh render
    if (!append) {
      let items = state.articles.map(a => ({ ...a, feed: state.feeds.find(f => f.id === a.feedId) }));
      if (state.selectedSource) items = items.filter(i => i.feedId === state.selectedSource);
      if (state.selectedCat !== 'All') items = fuzzy(state.selectedCat, items, ['feed.category']);
      // Apply tag filter
      if (state.selectedTag && state.selectedTag !== 'all') {
        items = filterByTag(items, state.selectedTag);
      }
      // Apply search scope filter (search within specific feed)
      if (state.searchScope) {
        items = items.filter(i => i.feedId === state.searchScope);
      }
      // Apply search query
      if (state.query) items = fuzzy(state.query, items, ['title', 'summary', 'feed.name']);

      // Store for pagination
      newsInboxItems = items;
      VirtualList.news.rendered = 0;
      VirtualList.news.total = items.length;
    }

    const items = newsInboxItems;
    const q = state.query;

    // Build search results info
    let searchInfo = '';
    if (state.query && !append) {
      const scopeFeed = state.searchScope ? state.feeds.find(f => f.id === state.searchScope) : null;
      searchInfo = `<div class="search-results-info">
        <i class="ph ph-magnifying-glass"></i>
        <span><strong>${items.length}</strong> result${items.length !== 1 ? 's' : ''} for "<strong>${state.query}</strong>"</span>
        ${scopeFeed ? `<span class="search-scope-tag">in ${scopeFeed.name}</span>` : ''}
      </div>`;
    }

    if (!items.length) {
      const hasFeeds = state.feeds.filter(f => f.type === 'news').length > 0;
      const hasTagFilter = state.selectedTag && state.selectedTag !== 'all';
      const hasSearch = state.query;
      el.newsList.innerHTML = hasFeeds
        ? `${searchInfo}<div class="empty"><div class="empty-icon"><i class="ph ph-tray"></i></div><div class="empty-title">${hasSearch ? 'No matching articles' : 'No articles found'}</div><div style="color:var(--text3);margin-top:8px">${hasSearch ? 'Try different search terms' : hasTagFilter ? 'Try selecting a different topic' : 'Try refreshing your feeds'}</div></div>`
        : '<div class="empty"><div class="empty-icon"><i class="ph ph-broadcast"></i></div><div class="empty-title">No news feeds yet</div><div style="color:var(--text3);margin-top:8px">Click + to add your first RSS feed</div></div>';
      return;
    }

    // Calculate slice for current batch
    const start = VirtualList.news.rendered;
    const end = Math.min(start + VirtualList.news.batchSize, items.length);
    const batch = items.slice(start, end);
    VirtualList.news.rendered = end;

    const batchHtml = batch.map(i => {
      const title = q ? highlightSearch(i.title, q) : i.title;
      const summary = i.summary ? (q ? highlightSearch(i.summary, q) : i.summary) : '';
      const iconImg = i.feed?.image || i.image;
      return `<div class="article ${i.unread ? 'unread' : ''}" data-id="${i.id}"><div class="article-icon">${iconImg ? `<img data-src="${iconImg}" src="${placeholderImg}" class="lazy-img">` : '<i class="ph ph-article"></i>'}</div><div class="article-body"><div class="article-meta"><span class="article-source">${i.feed?.name || ''}</span><span class="article-time">Â· ${i.time}</span>${i.unread ? '<span class="article-new">NEW</span>' : ''}</div><div class="article-title">${title}</div>${summary ? `<div class="article-summary">${summary}</div>` : ''}${renderItemTags(i.tags)}</div>${i.image && i.image !== iconImg ? `<img class="article-image lazy-img" data-src="${i.image}" src="${placeholderImg}" onerror="this.style.display='none'">` : ''}</div>`;
    }).join('');

    // Add load more button if there are more items
    const hasMore = end < items.length;
    const loadMoreHtml = hasMore ? `
      <div class="load-more-container" id="newsLoadMore">
        <button class="load-more-btn" onclick="loadMoreNews()">
          Load More (${items.length - end} remaining)
        </button>
      </div>
    ` : '';

    if (append) {
      const oldLoadMore = el.newsList.querySelector('.load-more-container');
      if (oldLoadMore) oldLoadMore.remove();
      el.newsList.insertAdjacentHTML('beforeend', batchHtml + loadMoreHtml);
    } else {
      el.newsList.innerHTML = searchInfo + batchHtml + loadMoreHtml;
      Perf.trackScroll(el.newsList);
    }

    // Setup lazy loading for newly rendered images
    requestAnimationFrame(() => {
      el.newsList.querySelectorAll('img[data-src]:not(.loaded)').forEach(img => ImageLoader.loadImage(img, img.dataset.src));
    });

    // Set up IntersectionObserver for infinite scroll
    if (hasMore && !append) {
      setupNewsInfiniteScroll();
    }

    Perf.measure('renderNews', 'renderNews');
  };

  // Load more news
  window.loadMoreNews = () => {
    const btn = document.querySelector('#newsLoadMore .load-more-btn');
    if (btn) {
      btn.classList.add('loading');
      btn.disabled = true;
    }
    setTimeout(() => renderNews(true), 100);
  };

  // Infinite scroll observer for news
  let newsScrollObserver = null;
  const setupNewsInfiniteScroll = () => {
    if (newsScrollObserver) newsScrollObserver.disconnect();

    newsScrollObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && VirtualList.news.rendered < VirtualList.news.total) {
          loadMoreNews();
        }
      });
    }, {
      root: el.newsList,
      rootMargin: '200px',
      threshold: 0
    });

    const loadMoreEl = document.getElementById('newsLoadMore');
    if (loadMoreEl) newsScrollObserver.observe(loadMoreEl);
  };
  
// === RENDER PODCASTS (Inbox Style) ===
  const renderPodcastSources = () => {
    const podcasts = state.feeds.filter(f => f.type === 'podcast');
    el.podcastSources.innerHTML = `<div class="source-item ${!state.selectedPodcastSource && !state.currentShowPage ? 'active' : ''}" data-id="all"><div class="source-icon"><i class="ph ph-headphones"></i></div><div class="source-name">All Episodes</div></div>` +
      podcasts.map(f => {
        const hasNew = feedHasNewContent(f.id);
        const newCount = getNewItemCount(f.id);
        const newestDate = getNewestContentDate(f.id);
        const updatedText = hasNew && newestDate ? formatUpdatedAgo(newestDate) : '';
        const subtitle = hasNew ? (newCount > 0 ? `${newCount} new` : updatedText) : '';

        return `<div class="source-item ${state.currentShowPage === f.id ? 'active' : ''} ${hasNew ? 'has-new' : ''}" data-id="${f.id}">
          ${hasNew ? '<span class="new-indicator"></span>' : ''}
          <div class="source-icon">${f.image ? `<img src="${f.image}" onerror="this.parentElement.innerHTML='<i class=\\'ph ph-microphone-stage\\'></i>'">` : '<i class="ph ph-microphone-stage"></i>'}</div>
          <div class="source-info">
            <div class="source-name">${f.name}</div>
            ${subtitle ? `<div class="source-subtitle">${subtitle}</div>` : ''}
          </div>
          <span class="source-arrow">â†’</span>
        </div>`;
      }).join('');
  };

  // Mobile shows header browser (horizontal scroll)
  const renderMobileShowsHeader = () => {
    const podcasts = state.feeds.filter(f => f.type === 'podcast');

    if (!el.mobileShowsHeader) return;

    // Don't show if on show page or episode page
    if (state.currentShowPage || state.currentEpisodePage) {
      el.mobileShowsHeader.style.display = 'none';
      return;
    }

    el.mobileShowsHeader.style.display = '';

    const showsHtml = podcasts.map(f => {
      const hasNew = feedHasNewContent(f.id);
      const isActive = state.selectedPodcastSource === f.id;
      return `<div class="mobile-show-card ${isActive ? 'active' : ''} ${hasNew ? 'has-new' : ''}" data-show-id="${f.id}">
        <div class="show-art">
          ${f.image ? `<img src="${f.image}" onerror="this.style.display='none';this.nextElementSibling.style.display='flex'"><i class="ph ph-microphone-stage" style="display:none"></i>` : '<i class="ph ph-microphone-stage"></i>'}
        </div>
        <div class="show-name">${f.name}</div>
      </div>`;
    }).join('');

    el.mobileShowsHeader.innerHTML = `
      <div class="mobile-shows-title">
        <h3>Your Shows</h3>
        <div class="mobile-shows-actions">
          <button class="discover-show-btn" id="mobileDiscoverBtn" title="Discover Podcasts"><i class="ph ph-magnifying-glass"></i> Discover</button>
          <button class="add-show-btn" id="mobileAddShowBtn" title="Add by URL">+</button>
        </div>
      </div>
      <div class="mobile-shows-scroll">
        <div class="mobile-show-card all-shows ${!state.selectedPodcastSource ? 'active' : ''}" data-show-id="all">
          <div class="show-art">
            <i class="ph ph-headphones"></i>
          </div>
          <div class="show-name">All</div>
        </div>
        ${showsHtml}
      </div>
    `;

    // Add click handlers for mobile shows
    el.mobileShowsHeader.querySelectorAll('.mobile-show-card').forEach(card => {
      card.onclick = () => {
        const showId = card.dataset.showId;
        if (showId === 'all') {
          state.selectedPodcastSource = null;
          renderMobileShowsHeader();
          renderPodcastInbox();
        } else {
          // Navigate to show page on mobile
          renderShowPage(showId);
        }
      };
    });

    // Discover button - opens podcast search
    const discoverBtn = el.mobileShowsHeader.querySelector('#mobileDiscoverBtn');
    if (discoverBtn) {
      discoverBtn.onclick = () => {
        el.podcastSearchModal.classList.add('active');
        el.podcastSearchInput.focus();
      };
    }

    // Add show button - add by URL
    const addBtn = el.mobileShowsHeader.querySelector('#mobileAddShowBtn');
    if (addBtn) {
      addBtn.onclick = () => {
        document.getElementById('tPodcast').click();
        el.modal.classList.add('active');
      };
    }
  };

  // Mobile News Sources Header (similar to podcast shows)
  const renderMobileNewsHeader = () => {
    const newsSources = state.feeds.filter(f => f.type === 'news');

    if (!el.mobileNewsHeader) return;

    // Don't show if on source page
    if (state.currentSourcePage) {
      el.mobileNewsHeader.style.display = 'none';
      return;
    }

    el.mobileNewsHeader.style.display = '';

    const sourcesHtml = newsSources.map(f => {
      const hasNew = feedHasNewContent(f.id);
      const isActive = state.selectedSource === f.id;
      return `<div class="mobile-news-card ${isActive ? 'active' : ''} ${hasNew ? 'has-new' : ''}" data-source-id="${f.id}">
        <div class="source-art">
          ${f.image ? `<img src="${f.image}" onerror="this.style.display='none';this.nextElementSibling.style.display='flex'"><i class="ph ph-newspaper" style="display:none"></i>` : '<i class="ph ph-newspaper"></i>'}
        </div>
        <div class="source-name">${f.name}</div>
      </div>`;
    }).join('');

    el.mobileNewsHeader.innerHTML = `
      <div class="mobile-news-title">
        <h3>Your Sources</h3>
        <button class="add-news-btn" id="mobileAddNewsBtn">+</button>
      </div>
      <div class="mobile-news-scroll">
        <div class="mobile-news-card all-sources ${!state.selectedSource ? 'active' : ''}" data-source-id="all">
          <div class="source-art">
            <i class="ph ph-books"></i>
          </div>
          <div class="source-name">All</div>
        </div>
        ${sourcesHtml}
      </div>
    `;

    // Add click handlers for mobile news sources
    el.mobileNewsHeader.querySelectorAll('.mobile-news-card').forEach(card => {
      card.onclick = () => {
        const sourceId = card.dataset.sourceId;
        if (sourceId === 'all') {
          state.selectedSource = null;
          renderMobileNewsHeader();
          renderNews();
        } else {
          // Navigate to source page on mobile
          renderSourcePage(sourceId);
        }
      };
    });

    // Add source button
    const addBtn = el.mobileNewsHeader.querySelector('#mobileAddNewsBtn');
    if (addBtn) {
      addBtn.onclick = () => {
        openModal('news');
      };
    }
  };

  const renderPodcastEpisodeItem = (ep, searchQuery = null) => {
    const show = state.feeds.find(f => f.id === ep.feedId);
    const pr = state.progress[ep.id] || 0;
    const pct = ep.duration ? (pr / ep.duration) * 100 : 0;
    const done = pr >= ep.duration * 0.95;
    const inProgress = pr > 0 && !done;
    const imgSrc = ep.image || show?.image || placeholderImg;
    const isPlaying = state.currentEp?.id === ep.id && state.playing;
    const isCached = ImageCache.get(imgSrc);
    const inForLater = isInForLater(ep.id, 'episode');

    // Apply search highlighting if query provided
    const title = searchQuery ? highlightSearch(ep.title, searchQuery) : ep.title;
    const showName = show?.name || '';

    return `<div class="spotify-ep ${inProgress ? 'in-progress' : ''} ${done ? 'played' : ''} ${isPlaying ? 'now-playing' : ''}" data-ep="${ep.id}">
      <div class="spotify-ep-art">
        <i class="ph ph-microphone-stage img-fallback"></i>
        <img data-src="${imgSrc}" class="eager-img" onload="this.classList.add('loaded')" onerror="this.style.display='none'">
        <button class="spotify-ep-play-overlay" data-ep="${ep.id}">
          ${isPlaying ? '<i class="ph-fill ph-pause"></i>' : '<i class="ph-fill ph-play"></i>'}
        </button>
      </div>
      <div class="spotify-ep-info">
        <div class="spotify-ep-title">${title}</div>
        <div class="spotify-ep-meta">
          <span class="spotify-ep-show" data-show="${ep.feedId}">${showName}</span>
          <span class="spotify-ep-dot">Â·</span>
          <span class="spotify-ep-date">${ep.date}</span>
        </div>
        ${inProgress ? `<div class="spotify-ep-progress"><div class="spotify-ep-progress-fill" style="width:${pct}%"></div></div>` : ''}
        <div class="spotify-ep-duration">${done ? '<i class="ph ph-check-circle"></i> Played' : pr > 0 ? fmt(ep.duration - pr) + ' left' : fmt(ep.duration)}</div>
      </div>
      <button class="add-to-later-btn ${inForLater ? 'added' : ''}" data-content-id="${ep.id}" data-content-type="episode" title="Save">
        <i class="ph ${inForLater ? 'ph-check' : 'ph-clock'}"></i>
      </button>
    </div>`;
  };

  // Generate skeleton loading placeholders
  const renderSkeletonEpisodes = (count = 5) => {
    return Array(count).fill(0).map(() => `
      <div class="skeleton-ep">
        <div class="skeleton skeleton-ep-art"></div>
        <div class="skeleton-ep-info">
          <div class="skeleton skeleton-ep-title"></div>
          <div class="skeleton skeleton-ep-meta"></div>
          <div class="skeleton skeleton-ep-duration"></div>
        </div>
      </div>
    `).join('');
  };

  // Store filtered items for pagination
  let podcastInboxItems = [];

  const renderPodcastInbox = (append = false) => {
    Perf.mark('renderPodcastInbox');

    // Only recalculate items on fresh render
    if (!append) {
      let items = state.podcasts.map(p => ({ ...p, feed: state.feeds.find(f => f.id === p.feedId) }));

      // Apply source filter
      if (state.selectedPodcastSource) {
        items = items.filter(i => i.feedId === state.selectedPodcastSource);
      }

      // Apply category filter
      if (state.selectedPodcastCat !== 'All') {
        items = fuzzy(state.selectedPodcastCat, items, ['feed.category']);
      }

      // Apply tag filter
      if (state.selectedPodcastTag && state.selectedPodcastTag !== 'all') {
        items = filterByTag(items, state.selectedPodcastTag);
      }

      // Apply search scope filter (search within specific feed)
      if (state.searchScope) {
        items = items.filter(i => i.feedId === state.searchScope);
      }

      // Apply search query
      if (state.query) {
        items = fuzzy(state.query, items, ['title', 'desc', 'feed.name']);
      }

      // Store for pagination
      podcastInboxItems = items;
      VirtualList.podcast.rendered = 0;
      VirtualList.podcast.total = items.length;
    }

    const items = podcastInboxItems;
    const q = state.query;

    // Build search results info
    let searchInfo = '';
    if (state.query && !append) {
      const scopeFeed = state.searchScope ? state.feeds.find(f => f.id === state.searchScope) : null;
      searchInfo = `<div class="search-results-info">
        <i class="ph ph-magnifying-glass"></i>
        <span><strong>${items.length}</strong> result${items.length !== 1 ? 's' : ''} for "<strong>${state.query}</strong>"</span>
        ${scopeFeed ? `<span class="search-scope-tag">in ${scopeFeed.name}</span>` : ''}
      </div>`;
    }

    if (!items.length) {
      const hasFeeds = state.feeds.filter(f => f.type === 'podcast').length > 0;
      const hasTagFilter = state.selectedPodcastTag && state.selectedPodcastTag !== 'all';
      const hasSearch = state.query;
      el.podcastInboxList.innerHTML = hasFeeds
        ? `${searchInfo}<div class="empty"><div class="empty-icon"><i class="ph ph-tray"></i></div><div class="empty-title">${hasSearch ? 'No matching episodes' : 'No episodes found'}</div><div style="color:var(--text3);margin-top:8px">${hasSearch ? 'Try different search terms' : hasTagFilter ? 'Try selecting a different topic' : 'Try refreshing your feeds'}</div></div>`
        : '<div class="empty"><div class="empty-icon"><i class="ph ph-microphone-stage"></i></div><div class="empty-title">No podcasts yet</div><div style="color:var(--text3);margin-top:8px">Click + to add your first podcast</div></div>';
      return;
    }

    // Calculate slice for current batch
    const start = VirtualList.podcast.rendered;
    const end = Math.min(start + VirtualList.podcast.batchSize, items.length);
    const batch = items.slice(start, end);
    VirtualList.podcast.rendered = end;

    // Render using compact Spotify-style renderer
    const batchHtml = batch.map(ep => renderPodcastEpisodeItem(ep, q)).join('');

    // Add load more button if there are more items
    const hasMore = end < items.length;
    const loadMoreHtml = hasMore ? `
      <div class="load-more-container" id="podcastLoadMore">
        <button class="load-more-btn" onclick="loadMorePodcasts()">
          Load More (${items.length - end} remaining)
        </button>
      </div>
    ` : '';

    if (append) {
      // Remove old load more button and append new content
      const oldLoadMore = el.podcastInboxList.querySelector('.load-more-container');
      if (oldLoadMore) oldLoadMore.remove();
      el.podcastInboxList.insertAdjacentHTML('beforeend', batchHtml + loadMoreHtml);
    } else {
      el.podcastInboxList.innerHTML = searchInfo + batchHtml + loadMoreHtml;
      // Set up scroll tracking
      Perf.trackScroll(el.podcastInboxList);
    }

    // Load images immediately
    requestAnimationFrame(() => {
      el.podcastInboxList.querySelectorAll('img[data-src]:not(.loaded)').forEach(img => {
        ImageLoader.loadImage(img, img.dataset.src);
      });
    });

    // Set up IntersectionObserver for infinite scroll
    if (hasMore && !append) {
      setupPodcastInfiniteScroll();
    }

    Perf.measure('renderPodcastInbox', 'renderPodcastInbox');
  };

  // Load more podcasts
  window.loadMorePodcasts = () => {
    const btn = document.querySelector('#podcastLoadMore .load-more-btn');
    if (btn) {
      btn.classList.add('loading');
      btn.disabled = true;
    }
    // Small delay for visual feedback
    setTimeout(() => {
      renderPodcastInbox(true);
    }, 100);
  };

  // Infinite scroll observer
  let podcastScrollObserver = null;
  const setupPodcastInfiniteScroll = () => {
    if (podcastScrollObserver) {
      podcastScrollObserver.disconnect();
    }

    podcastScrollObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && VirtualList.podcast.rendered < VirtualList.podcast.total) {
          loadMorePodcasts();
        }
      });
    }, {
      root: el.podcastInboxList,
      rootMargin: '200px', // Start loading 200px before reaching bottom
      threshold: 0
    });

    // Observe the load more container
    const loadMoreEl = document.getElementById('podcastLoadMore');
    if (loadMoreEl) {
      podcastScrollObserver.observe(loadMoreEl);
    }
  };

  const renderPodcasts = () => {
    el.showPage.classList.remove('active');
    el.episodePage.classList.remove('active');
    el.podcastInboxContent.style.display = 'flex';

    renderPodcastSources();
    renderMobileShowsHeader();
    renderPodcastInbox();
  };

  const renderEpisode = ep => {
    const show = state.feeds.find(f => f.id === ep.feedId);
    const pr = state.progress[ep.id] || 0;
    const pct = ep.duration ? (pr / ep.duration) * 100 : 0;
    const rem = ep.duration - pr;
    const done = pr >= ep.duration * 0.95;
    const imgSrc = ep.image || show?.image || placeholderImg;

    // Download status
    const dlStatus = downloadProgress[ep.id];
    const isDownloading = dlStatus?.status === 'downloading';
    const dlPct = dlStatus?.progress || 0;

    // Download button content
    let dlBtnContent;
    if (isDownloading) {
      dlBtnContent = `<span style="font-size:10px;font-weight:600">${dlPct}%</span>`;
    } else if (ep.downloaded) {
      dlBtnContent = `<svg width="16" height="16" fill="currentColor" stroke="none" viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>`;
    } else {
      dlBtnContent = `<svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M7 10l5 5 5-5M12 15V3"/></svg>`;
    }

    return `<div class="episode" data-ep="${ep.id}"><div class="episode-art-wrap"><i class="ph ph-microphone-stage img-fallback"></i><img class="episode-art eager-img" data-src="${imgSrc}" onload="this.classList.add('loaded')" onerror="this.style.display='none'"></div><div class="episode-body"><div class="episode-show">${show?.name || ''}</div><div class="episode-title">${ep.title}</div><div class="episode-footer"><button class="ep-play" data-ep="${ep.id}"><svg width="10" height="10" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg></button><div class="ep-progress"><div class="ep-bar"><div class="ep-fill" style="width:${pct}%"></div></div><span class="ep-time">${done ? 'Played' : pr > 0 ? fmt(rem) + ' left' : fmt(ep.duration)}</span></div><button class="ep-dl ${ep.downloaded ? 'active' : ''} ${isDownloading ? 'downloading' : ''}" data-dl="${ep.id}" ${isDownloading ? 'disabled' : ''}>${dlBtnContent}</button></div></div></div>`;
  };
  
  // View options HTML generator
  const renderViewOptions = (sourceId, currentView, views = ['list', 'table', 'cards', 'masonry']) => {
    const icons = {
      list: '<svg width="14" height="14" fill="currentColor" viewBox="0 0 24 24"><path d="M3 13h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2V7H3v2zm4 4h14v-2H7v2zm0 4h14v-2H7v2zM7 7v2h14V7H7z"/></svg>',
      table: '<svg width="14" height="14" fill="currentColor" viewBox="0 0 24 24"><path d="M3 3v18h18V3H3zm8 16H5v-6h6v6zm0-8H5V5h6v6zm8 8h-6v-6h6v6zm0-8h-6V5h6v6z"/></svg>',
      cards: '<svg width="14" height="14" fill="currentColor" viewBox="0 0 24 24"><path d="M4 11h5V5H4v6zm0 7h5v-6H4v6zm6 0h5v-6h-5v6zm6 0h5v-6h-5v6zm-6-7h5V5h-5v6zm6-6v6h5V5h-5z"/></svg>',
      masonry: '<svg width="14" height="14" fill="currentColor" viewBox="0 0 24 24"><path d="M3 3v8h8V3H3zm6 6H5V5h4v4zm-6 4v8h8v-8H3zm6 6H5v-4h4v4zm4-16v12h8V3h-8zm6 10h-4V5h4v8zm-6 2v8h8v-8h-8zm6 6h-4v-4h4v4z"/></svg>'
    };
    const labels = { list: 'List', table: 'Table', cards: 'Cards', masonry: 'Masonry' };
    return `<div class="view-options" data-source="${sourceId}">${views.map(v =>
      `<button class="view-btn ${currentView === v ? 'active' : ''}" data-view="${v}" title="${labels[v]}">${icons[v]}</button>`
    ).join('')}</div>`;
  };

  // Render article in different view modes
  const renderArticleCard = (article, feed) => `
    <div class="article-card ${article.unread ? 'unread' : ''}" data-id="${article.id}">
      ${article.image ? `<img class="article-card-image" src="${article.image}" onerror="this.style.display='none'">` : '<div class="article-card-image" style="background:var(--bg3);display:flex;align-items:center;justify-content:center;font-size:32px"><i class="ph ph-article"></i></div>'}
      <div class="article-card-body">
        <div class="article-card-meta">
          <span class="article-card-source">${feed?.name || ''}</span>
          <span class="article-card-time">Â· ${article.time}</span>
        </div>
        <div class="article-card-title">${article.title}</div>
        ${article.summary ? `<div class="article-card-summary">${article.summary}</div>` : ''}
      </div>
    </div>`;

  const renderArticleMasonry = (article, feed) => `
    <div class="article-masonry ${article.unread ? 'unread' : ''}" data-id="${article.id}">
      ${article.image ? `<img class="article-masonry-image" src="${article.image}" onerror="this.style.display='none'">` : ''}
      <div class="article-masonry-body">
        <div class="article-masonry-meta">
          <span class="article-masonry-source">${feed?.name || ''}</span>
          <span class="article-masonry-time">Â· ${article.time}</span>
        </div>
        <div class="article-masonry-title">${article.title}</div>
        ${article.summary ? `<div class="article-masonry-summary">${article.summary}</div>` : ''}
      </div>
    </div>`;

  const renderArticleTable = (article, feed) => `
    <tr class="${article.unread ? 'unread' : ''}" data-id="${article.id}">
      <td class="table-title">${article.title}</td>
      <td class="table-source">${feed?.name || ''}</td>
      <td class="table-time">${article.time}</td>
      <td class="table-new">${article.unread ? 'NEW' : ''}</td>
    </tr>`;

  // Render episodes in different view modes
  const renderEpisodeCard = ep => {
    const show = state.feeds.find(f => f.id === ep.feedId);
    const imgSrc = ep.image || show?.image || placeholderImg;
    const pr = state.progress[ep.id] || 0;
    return `<div class="episode-card" data-ep="${ep.id}">
      <div class="episode-card-art-wrap"><i class="ph ph-microphone-stage img-fallback"></i><img class="episode-card-art eager-img" data-src="${imgSrc}" onload="this.classList.add('loaded')" onerror="this.style.display='none'"></div>
      <div class="episode-card-body">
        <div class="episode-card-title">${ep.title}</div>
        <div class="episode-card-meta">
          <span>${fmt(ep.duration)}</span>
          ${pr > 0 ? `<span>Â· ${Math.round((pr / ep.duration) * 100)}% played</span>` : ''}
        </div>
      </div>
    </div>`;
  };

  const renderEpisodeMasonry = ep => {
    const show = state.feeds.find(f => f.id === ep.feedId);
    const imgSrc = ep.image || show?.image || placeholderImg;
    return `<div class="episode-masonry" data-ep="${ep.id}">
      <div class="episode-masonry-art-wrap"><i class="ph ph-microphone-stage img-fallback"></i><img class="episode-masonry-art eager-img" data-src="${imgSrc}" onload="this.classList.add('loaded')" onerror="this.style.display='none'"></div>
      <div class="episode-masonry-body">
        <div class="episode-masonry-title">${ep.title}</div>
        ${ep.desc ? `<div class="episode-masonry-desc">${ep.desc}</div>` : ''}
        <div class="episode-masonry-meta">${fmt(ep.duration)} Â· ${ep.date}</div>
      </div>
    </div>`;
  };

  const renderEpisodeTable = ep => {
    const show = state.feeds.find(f => f.id === ep.feedId);
    return `<tr data-ep="${ep.id}">
      <td class="table-play"><button class="table-play-btn" data-ep="${ep.id}"><svg width="10" height="10" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg></button></td>
      <td class="table-title">${ep.title}</td>
      <td class="table-duration">${fmt(ep.duration)}</td>
      <td class="table-date">${ep.date}</td>
    </tr>`;
  };

  // Render articles content based on view mode
  const renderArticlesContent = (articles, viewMode, sourceId) => {
    if (!articles.length) return '<div class="empty"><div class="empty-icon"><i class="ph ph-tray"></i></div><div class="empty-title">No articles found</div></div>';

    switch (viewMode) {
      case 'cards':
        return `<div class="articles-cards">${articles.map(a => renderArticleCard(a, state.feeds.find(f => f.id === a.feedId))).join('')}</div>`;
      case 'masonry':
        return `<div class="articles-masonry">${articles.map(a => renderArticleMasonry(a, state.feeds.find(f => f.id === a.feedId))).join('')}</div>`;
      case 'table':
        return `<table class="articles-table"><thead><tr><th>Title</th><th>Source</th><th>Time</th><th></th></tr></thead><tbody>${articles.map(a => renderArticleTable(a, state.feeds.find(f => f.id === a.feedId))).join('')}</tbody></table>`;
      default: // list
        return `<div class="news-list-view">${articles.map(a => {
          const feed = state.feeds.find(f => f.id === a.feedId);
          const iconImg = feed?.image || a.image;
          return `<div class="article ${a.unread ? 'unread' : ''}" data-id="${a.id}"><div class="article-icon">${iconImg ? `<img src="${iconImg}">` : '<i class="ph ph-article"></i>'}</div><div class="article-body"><div class="article-meta"><span class="article-source">${feed?.name || ''}</span><span class="article-time">Â· ${a.time}</span>${a.unread ? '<span class="article-new">NEW</span>' : ''}</div><div class="article-title">${a.title}</div>${a.summary ? `<div class="article-summary">${a.summary}</div>` : ''}</div>${a.image && a.image !== iconImg ? `<img class="article-image" src="${a.image}">` : ''}</div>`;
        }).join('')}</div>`;
    }
  };

  // Render episodes content based on view mode
  const renderEpisodesContent = (episodes, viewMode) => {
    if (!episodes.length) return '<div class="empty"><div class="empty-icon"><i class="ph ph-headphones"></i></div><div class="empty-title">No episodes found</div></div>';

    switch (viewMode) {
      case 'cards':
        return `<div class="episodes-cards">${episodes.map(renderEpisodeCard).join('')}</div>`;
      case 'masonry':
        return `<div class="episodes-masonry">${episodes.map(renderEpisodeMasonry).join('')}</div>`;
      case 'table':
        return `<table class="episodes-table"><thead><tr><th class="table-play"></th><th>Title</th><th>Duration</th><th>Date</th></tr></thead><tbody>${episodes.map(renderEpisodeTable).join('')}</tbody></table>`;
      default: // list
        return `<div class="episode-list">${episodes.map(renderEpisode).join('')}</div>`;
    }
  };

  // Render source page for news feeds
  const renderSourcePage = id => {
    const source = state.feeds.find(f => f.id === id);
    if (!source) return;
    Mem.log('feed_opened', id);
    state.currentSourcePage = id;
    markFeedViewed(id); // Mark feed as viewed to clear new content indicator

    const articles = state.articles.filter(a => a.feedId === id);
    const viewMode = getViewPref('news_' + id, 'list');

    el.newsContent.style.display = 'none';
    el.sourcePage.classList.add('active');
    renderNewsSources(); // Update active state in sidebar
    el.sourcePage.innerHTML = `
      <div class="source-hero">
        <button class="back-btn" id="sourceBackBtn"><svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 18l-6-6 6-6"/></svg> Back</button>
        <img class="source-hero-art" src="${source.image || placeholderImg}" onerror="this.src='${placeholderImg}'">
        <div class="source-hero-info">
          <div class="source-hero-type">News Feed</div>
          <div class="source-hero-title">${source.name}</div>
          <div class="source-hero-author">${source.author || source.category || ''}</div>
        </div>
      </div>
      <div class="source-actions">
        <span style="font-size:14px;color:var(--text2)">${articles.length} articles</span>
        ${renderViewOptions('news_' + id, viewMode)}
        <button class="edit-feed-btn" data-feed-id="${id}"><svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 013 3L12 15l-4 1 1-4 9.5-9.5z"/></svg> Edit</button>
        <button class="remove-feed-btn" data-feed-id="${id}"><svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/></svg> Remove</button>
      </div>
      <div class="source-articles">
        <div class="source-articles-content">${renderArticlesContent(articles, viewMode, id)}</div>
      </div>`;
  };

  const closeSourcePage = () => {
    state.currentSourcePage = null;
    el.sourcePage.classList.remove('active');
    el.newsContent.style.display = 'flex';
    renderNewsSources(); // Update active state in sidebar
  };

  const renderShowPage = id => {
    const show = state.feeds.find(f => f.id === id);
    if (!show) return;
    Mem.log('feed_opened', id);
    state.currentShowPage = id;
    markFeedViewed(id); // Mark feed as viewed to clear new content indicator

    const eps = state.podcasts.filter(p => p.feedId === id);
    const viewMode = getViewPref('podcast_' + id, 'list');

    el.podcastInboxContent.style.display = 'none';
    el.showPage.classList.add('active');
    renderPodcastSources(); // Update active state in sidebar
    el.showPage.innerHTML = `
      <div class="show-hero">
        <button class="back-btn" id="showBackBtn"><svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 18l-6-6 6-6"/></svg> Back</button>
        <img class="show-hero-art" src="${show.image || placeholderImg}" onerror="this.src='${placeholderImg}'">
        <div class="show-hero-info">
          <div class="show-hero-type">Podcast</div>
          <div class="show-hero-title">${show.name}</div>
          <div class="show-hero-author">${show.author || ''}</div>
        </div>
      </div>
      <div class="show-actions">
        <button class="show-play" data-show="${id}"><svg width="22" height="22" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg></button>
        ${renderViewOptions('podcast_' + id, viewMode)}
        <button class="edit-feed-btn" data-feed-id="${id}"><svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 013 3L12 15l-4 1 1-4 9.5-9.5z"/></svg> Edit</button>
        <button class="remove-feed-btn" data-feed-id="${id}"><svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/></svg> Remove</button>
      </div>
      <div class="show-episodes">
        <div class="show-episodes-title">Episodes</div>
        <div class="show-episodes-content">${renderEpisodesContent(eps, viewMode)}</div>
      </div>`;

    // Setup lazy loading for newly rendered images
    requestAnimationFrame(() => {
      el.showPage.querySelectorAll('img[data-src]:not(.loaded)').forEach(img => ImageLoader.loadImage(img, img.dataset.src));
    });
  };

  const closeShowPage = () => {
    state.currentShowPage = null;
    el.showPage.classList.remove('active');
    el.podcastInboxContent.style.display = 'flex';
    renderPodcastSources(); // Update active state in sidebar
    renderMobileShowsHeader(); // Show mobile shows browser again
  };

  // === EPISODE PAGE ===
  const renderEpisodePage = (episodeId) => {
    const ep = state.podcasts.find(p => p.id === episodeId);
    if (!ep) return;

    const show = state.feeds.find(f => f.id === ep.feedId);
    const pr = state.progress[ep.id] || 0;
    const pct = ep.duration ? (pr / ep.duration) * 100 : 0;
    const done = pr >= ep.duration * 0.95;
    const bookmarks = state.bookmarks[ep.id] || [];
    const isPlaying = state.currentEp?.id === ep.id && state.playing;
    const isDownloaded = ep.downloaded;
    const inForLater = isInForLater(ep.id, 'episode');

    state.currentEpisodePage = episodeId;

    // Hide inbox content and show page, show episode page
    el.podcastInboxContent.style.display = 'none';
    el.showPage.classList.remove('active');
    el.episodePage.classList.add('active');

    // Generate tags HTML
    const tagsHtml = ep.tags && ep.tags.length > 0
      ? `<div class="episode-tags">${ep.tags.map(tag => {
          const tagInfo = getTagInfo(tag);
          return `<span class="episode-tag">#${tagInfo.label.toLowerCase().replace(/\s+/g, '')}</span>`;
        }).join('')}</div>`
      : '';

    // Generate bookmarks HTML
    const bookmarksHtml = bookmarks.length > 0
      ? `<div class="episode-bookmarks">
          <div class="episode-bookmarks-title">
            <svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M19 21l-7-5-7 5V5a2 2 0 012-2h10a2 2 0 012 2z"/></svg>
            Bookmarks (${bookmarks.length})
          </div>
          <div class="episode-bookmarks-list">
            ${bookmarks.map(b => `
              <div class="episode-bookmark-item" data-time="${b.time}">
                <span class="episode-bookmark-time">${fmtLong(b.time)}</span>
                <span class="episode-bookmark-note">${b.note || 'No note'}</span>
              </div>
            `).join('')}
          </div>
        </div>`
      : '';

    el.episodePage.innerHTML = `
      <div class="episode-hero">
        <button class="back-btn" id="episodeBackBtn">
          <svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 18l-6-6 6-6"/></svg>
          Back
        </button>
        <img class="episode-hero-art" src="${ep.image || show?.image || placeholderImg}" onerror="this.src='${placeholderImg}'">
        <div class="episode-hero-info">
          <div class="episode-hero-show" data-show="${ep.feedId}">
            <svg width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M19 21l-7-5-7 5V5a2 2 0 012-2h10a2 2 0 012 2z"/></svg>
            ${show?.name || 'Unknown Show'}
          </div>
          <div class="episode-hero-title">${ep.title}</div>
          <div class="episode-hero-meta">
            <span>
              <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
              ${ep.date}
            </span>
            <span>
              <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/></svg>
              ${fmtLong(ep.duration)}
            </span>
            ${done ? '<span style="color: var(--green);"><svg fill="currentColor" viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg> Played</span>' : ''}
          </div>
          ${tagsHtml}
        </div>
      </div>
      ${pr > 0 ? `
        <div class="episode-progress-section">
          <div class="episode-progress-bar">
            <div class="episode-progress-fill" style="width: ${pct}%"></div>
          </div>
          <div class="episode-progress-text">
            <span>${fmtLong(pr)} listened</span>
            <span>${done ? 'Completed' : fmtLong(ep.duration - pr) + ' remaining'}</span>
          </div>
        </div>
      ` : ''}
      <div class="episode-actions">
        <button class="episode-play-btn" data-ep="${ep.id}">
          ${isPlaying
            ? '<svg fill="currentColor" viewBox="0 0 24 24"><path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/></svg> Pause'
            : '<svg fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg> Play'}
        </button>
        <button class="episode-action-btn ${isDownloaded ? 'active' : ''}" data-dl="${ep.id}">
          ${isDownloaded
            ? '<svg fill="currentColor" viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg> Downloaded'
            : '<svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="7,10 12,15 17,10"/><line x1="12" y1="15" x2="12" y2="3"/></svg> Download'}
        </button>
        <button class="episode-action-btn" id="episodeBookmarkBtn" data-ep="${ep.id}">
          <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M19 21l-7-5-7 5V5a2 2 0 012-2h10a2 2 0 012 2z"/></svg>
          Add Bookmark
        </button>
        <button class="episode-action-btn ${inForLater ? 'active' : ''}" id="episodeSaveForLaterBtn" data-content-id="${ep.id}" data-content-type="episode">
          ${inForLater
            ? '<svg fill="currentColor" viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg> Saved'
            : '<svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/></svg> Save'}
        </button>
      </div>
      ${(ep.descHtml || ep.desc) ? `
        <div class="episode-description">
          <div class="episode-description-title">About this episode</div>
          <div class="episode-description-content">${ep.descHtml ? sanitizeHtml(ep.descHtml) : linkifyText(ep.desc)}</div>
        </div>
      ` : ''}
      ${bookmarksHtml}
    `;

    // Setup lazy loading for images
    requestAnimationFrame(() => {
      el.episodePage.querySelectorAll('img[data-src]:not(.loaded)').forEach(img => ImageLoader.loadImage(img, img.dataset.src));
    });
  };

  const closeEpisodePage = () => {
    state.currentEpisodePage = null;
    el.episodePage.classList.remove('active');
    // If we came from show page, show it again, otherwise show inbox
    if (state.currentShowPage) {
      el.showPage.classList.add('active');
    } else {
      el.podcastInboxContent.style.display = 'flex';
      renderMobileShowsHeader(); // Show mobile shows browser again
    }
  };

  // Helper to convert URLs in text to clickable links
  const linkifyText = (text) => {
    if (!text) return '';
    const urlRegex = /(https?:\/\/[^\s<]+)/g;
    return text.replace(urlRegex, '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>');
  };

  // Helper to sanitize HTML content for safe rendering
  const sanitizeHtml = (html) => {
    if (!html) return '';
    const tmp = document.createElement('div');
    tmp.innerHTML = html;

    // Remove potentially dangerous elements
    const dangerousTags = ['script', 'style', 'iframe', 'object', 'embed', 'form', 'input', 'button'];
    dangerousTags.forEach(tag => {
      tmp.querySelectorAll(tag).forEach(el => el.remove());
    });

    // Clean attributes on remaining elements
    tmp.querySelectorAll('*').forEach(el => {
      // Remove event handlers and dangerous attributes
      const attrs = [...el.attributes];
      attrs.forEach(attr => {
        if (attr.name.startsWith('on') || attr.name === 'srcdoc' || attr.name === 'formaction') {
          el.removeAttribute(attr.name);
        }
        // Sanitize href/src attributes
        if ((attr.name === 'href' || attr.name === 'src') &&
            (attr.value.startsWith('javascript:') || attr.value.startsWith('data:'))) {
          el.removeAttribute(attr.name);
        }
      });
      // Make links open in new tab
      if (el.tagName === 'A') {
        el.setAttribute('target', '_blank');
        el.setAttribute('rel', 'noopener noreferrer');
      }
    });

    return tmp.innerHTML;
  };

  // === RENDER ALL - Social Media Feed Style ===

  // Render a single feed post in social media style
  const renderFeedPost = (item, type, searchQuery = null) => {
    const feed = state.feeds.find(f => f.id === item.feedId);
    const feedName = feed?.name || 'Unknown Source';
    const feedImage = feed?.image;
    const rawSummary = type === 'podcast' ? item.desc : item.summary;
    const image = item.image || feed?.image;
    const isUnread = type === 'news' && item.unread;
    const duration = type === 'podcast' && item.duration ? fmtLong(item.duration) : '';
    const contentType = type === 'podcast' ? 'episode' : 'article';
    const inForLater = isInForLater(item.id, contentType);

    // Apply search highlighting
    const title = searchQuery ? highlightSearch(item.title, searchQuery) : item.title;
    const summary = rawSummary ? (searchQuery ? highlightSearch(rawSummary, searchQuery) : rawSummary) : '';

    // Check cache status for images
    const avatarCached = feedImage && ImageCache.get(feedImage);
    const mediaCached = image && ImageCache.get(image);

    // Generate avatar with lazy loading - fall back to item image if no feed image
    const podcastIcon = '<i class="ph ph-headphones"></i>';
    const newsIcon = '<i class="ph ph-newspaper"></i>';
    const avatarImg = feedImage || item.image;
    const avatar = avatarImg
      ? `<img data-src="${avatarImg}" src="${placeholderImg}" class="lazy-img" onerror="this.parentElement.innerHTML=\`${type === 'podcast' ? podcastIcon : newsIcon}\`">`
      : (type === 'podcast' ? podcastIcon : newsIcon);

    // Generate tags HTML
    const tagsHtml = item.tags && item.tags.length > 0
      ? `<div class="feed-post-tags">${item.tags.slice(0, 3).map(tag => {
          const tagInfo = getTagInfo(tag);
          return `<span class="feed-post-tag">#${tagInfo.label.toLowerCase().replace(/\s+/g, '')}</span>`;
        }).join('')}</div>`
      : '';

    // Podcast-specific elements
    const podcastMeta = type === 'podcast' ? `
      <div class="feed-post-duration">
        <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/></svg>
        ${duration}
      </div>
      <div class="feed-post-play" data-action="play">
        <svg fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
        Play Episode
      </div>
    ` : '';

    // Action buttons for news
    const newsActions = type === 'news' ? `
      <div class="feed-post-actions">
        <span class="feed-post-action" data-action="open" title="Open article">
          <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6M15 3h6v6M10 14L21 3"/></svg>
          Read
        </span>
      </div>
    ` : '';

    return `<article class="feed-post${isUnread ? ' unread' : ''}" data-type="${type}" data-id="${item.id}" data-source="${feedName}" data-time="${item.time || item.date}">
      <div class="feed-post-inner">
        <div class="feed-post-header">
          <div class="feed-post-avatar">${avatar}</div>
          <div class="feed-post-meta">
            <div class="feed-post-source">
              <span class="feed-post-source-name">${feedName}</span>
              <span class="feed-post-type-badge ${type}">${type === 'podcast' ? 'Podcast' : 'News'}</span>
            </div>
            <div class="feed-post-handle">
              <span>${feed?.author || ''}</span>
              <span class="feed-post-dot">Â·</span>
              <span class="feed-post-time">${item.time || item.date}</span>
            </div>
          </div>
        </div>
        <div class="feed-post-body">
          <div class="feed-post-title">${title}</div>
          ${summary ? `<div class="feed-post-summary">${summary}</div>` : ''}
          ${image ? `<div class="feed-post-media"><img data-src="${image}" src="${placeholderImg}" class="lazy-img" onerror="this.parentElement.style.display='none'" alt=""></div>` : ''}
          ${tagsHtml}
          ${podcastMeta}
          ${newsActions}
        </div>
        <button class="add-to-later-btn ${inForLater ? 'added' : ''}" data-content-id="${item.id}" data-content-type="${contentType}" title="Save">
          <i class="ph ${inForLater ? 'ph-check' : 'ph-clock'}"></i>
        </button>
      </div>
    </article>`;
  };

  // Update feed filter nav buttons
  const updateFeedNav = (newsCount, podcastCount) => {
    const totalCount = newsCount + podcastCount;
    el.feedCountAll.textContent = totalCount;
    el.feedCountNews.textContent = newsCount;
    el.feedCountPodcast.textContent = podcastCount;

    // Update active state
    el.feedNav.querySelectorAll('.feed-nav-btn').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.filter === state.feedFilter);
    });
  };

  // Store filtered items for feed pagination
  let feedAllItems = [];

  const renderAll = (append = false) => {
    Perf.mark('renderAll');

    // Only recalculate items on fresh render
    if (!append) {
      const articles = state.articles.map(a => ({ ...a, sortDate: new Date(a.pubDate), type: 'news' }));
      const episodes = state.podcasts.map(p => ({ ...p, sortDate: new Date(p.pubDate), type: 'podcast' }));

      // Count new/unread items for nav
      const newsCount = state.articles.filter(a => a.unread).length;
      const podcastCount = state.podcasts.filter(p => !state.progress[p.id]).length;
      updateFeedNav(newsCount, podcastCount);

      // Combine and sort by date
      let allItems = [...articles, ...episodes].sort((a, b) => b.sortDate - a.sortDate);

      // Apply content type filter
      if (state.feedFilter === 'news') {
        allItems = allItems.filter(item => item.type === 'news');
      } else if (state.feedFilter === 'podcast') {
        allItems = allItems.filter(item => item.type === 'podcast');
      }

      // Apply search scope filter (search within specific feed)
      if (state.searchScope) {
        allItems = allItems.filter(item => item.feedId === state.searchScope);
      }

      // Apply search filter if present
      if (state.query) {
        allItems = fuzzy(state.query, allItems, ['title', 'summary', 'desc']);
      }

      // Store for pagination
      feedAllItems = allItems;
      VirtualList.feed.rendered = 0;
      VirtualList.feed.total = allItems.length;
    }

    const allItems = feedAllItems;
    const q = state.query;

    // Build search results info
    let searchInfo = '';
    if (state.query && !append) {
      const scopeFeed = state.searchScope ? state.feeds.find(f => f.id === state.searchScope) : null;
      searchInfo = `<div class="search-results-info" style="margin: 16px;">
        <i class="ph ph-magnifying-glass"></i>
        <span><strong>${allItems.length}</strong> result${allItems.length !== 1 ? 's' : ''} for "<strong>${state.query}</strong>"</span>
        ${scopeFeed ? `<span class="search-scope-tag">in ${scopeFeed.name}</span>` : ''}
      </div>`;
    }

    if (!allItems.length) {
      const hasFeeds = state.feeds.length > 0;
      const hasSearch = state.query;
      const filterLabel = state.feedFilter === 'news' ? 'news articles' :
                          state.feedFilter === 'podcast' ? 'podcasts' : 'content';
      const emptyIcon = state.feedFilter === 'podcast' ? '<i class="ph ph-headphones"></i>' : state.feedFilter === 'news' ? '<i class="ph ph-newspaper"></i>' : '<i class="ph ph-tray"></i>';
      el.feedScroll.innerHTML = hasFeeds
        ? `${searchInfo}<div class="feed-empty">
            <div class="feed-empty-icon">${emptyIcon}</div>
            <div class="feed-empty-title">${hasSearch ? 'No matching ' + filterLabel : 'No ' + filterLabel + ' found'}</div>
            <div class="feed-empty-desc">${hasSearch ? 'Try different search terms' : 'Try refreshing your feeds or changing the filter'}</div>
          </div>`
        : `<div class="feed-empty">
            <div class="feed-empty-icon"><i class="ph ph-broadcast"></i></div>
            <div class="feed-empty-title">No feeds yet</div>
            <div class="feed-empty-desc">Click + to add your first feed</div>
          </div>`;
      return;
    }

    // Calculate slice for current batch
    const start = VirtualList.feed.rendered;
    const end = Math.min(start + VirtualList.feed.batchSize, allItems.length);
    const batch = allItems.slice(start, end);
    VirtualList.feed.rendered = end;

    // Render social media style feed with search highlighting
    const batchHtml = batch.map(item => renderFeedPost(item, item.type, q)).join('');

    // Add load more button if there are more items
    const hasMore = end < allItems.length;
    const loadMoreHtml = hasMore ? `
      <div class="load-more-container" id="feedLoadMore">
        <button class="load-more-btn" onclick="loadMoreFeed()">
          Load More (${allItems.length - end} remaining)
        </button>
      </div>
    ` : '';

    if (append) {
      const oldLoadMore = el.feedScroll.querySelector('.load-more-container');
      if (oldLoadMore) oldLoadMore.remove();
      el.feedScroll.insertAdjacentHTML('beforeend', batchHtml + loadMoreHtml);
    } else {
      el.feedScroll.innerHTML = searchInfo + batchHtml + loadMoreHtml;
      Perf.trackScroll(el.feedScroll);
    }

    // Setup lazy loading for newly rendered images
    requestAnimationFrame(() => {
      el.feedScroll.querySelectorAll('img[data-src]:not(.loaded)').forEach(img => ImageLoader.loadImage(img, img.dataset.src));
    });

    // Set up IntersectionObserver for infinite scroll
    if (hasMore && !append) {
      setupFeedInfiniteScroll();
    }

    Perf.measure('renderAll', 'renderAll');
  };

  // Load more feed items
  window.loadMoreFeed = () => {
    const btn = document.querySelector('#feedLoadMore .load-more-btn');
    if (btn) {
      btn.classList.add('loading');
      btn.disabled = true;
    }
    setTimeout(() => renderAll(true), 100);
  };

  // Infinite scroll observer for feed
  let feedScrollObserver = null;
  const setupFeedInfiniteScroll = () => {
    if (feedScrollObserver) feedScrollObserver.disconnect();

    feedScrollObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && VirtualList.feed.rendered < VirtualList.feed.total) {
          loadMoreFeed();
        }
      });
    }, {
      root: el.feedScroll,
      rootMargin: '200px',
      threshold: 0
    });

    const loadMoreEl = document.getElementById('feedLoadMore');
    if (loadMoreEl) feedScrollObserver.observe(loadMoreEl);
  };

  // === FOR LATER VIEW ===
  const renderForLater = () => {
    if (!state.forLater || state.forLater.length === 0) {
      el.forLaterList.innerHTML = `
        <div class="for-later-empty">
          <div class="for-later-empty-icon"><i class="ph ph-bookmark-simple"></i></div>
          <div class="for-later-empty-title">Save items for later</div>
          <div class="for-later-empty-desc">Build your personal queue of articles and podcast episodes to enjoy when you have time.</div>
          <div class="for-later-empty-hint">
            <div class="for-later-empty-hint-icon"><i class="ph ph-clock"></i></div>
            <div class="for-later-empty-hint-text">Tap the <strong>clock icon</strong> on any article or episode to save it here</div>
          </div>
          <button class="for-later-browse-btn" id="forLaterBrowseBtn">Browse Podcasts</button>
        </div>
      `;
      // Add click handler for browse button
      const browseBtn = document.getElementById('forLaterBrowseBtn');
      if (browseBtn) {
        browseBtn.onclick = () => setView('podcasts');
      }
      return;
    }

    const items = state.forLater.map(item => {
      let content = null;
      let feed = null;

      if (item.contentType === 'article') {
        content = state.articles.find(a => a.id === item.contentId);
        if (!content) content = state.archivedArticles.find(a => a.id === item.contentId);
        if (content) feed = state.feeds.find(f => f.id === content.feedId);
      } else if (item.contentType === 'episode') {
        content = state.podcasts.find(p => p.id === item.contentId);
        if (!content) content = state.archivedPodcasts.find(p => p.id === item.contentId);
        if (content) feed = state.feeds.find(f => f.id === content.feedId);
      }

      if (!content) return null;

      const timeAgo = (() => {
        const diff = Date.now() - item.addedAt;
        const minutes = Math.floor(diff / 60000);
        const hours = Math.floor(minutes / 60);
        const days = Math.floor(hours / 24);
        if (days > 0) return `${days}d ago`;
        if (hours > 0) return `${hours}h ago`;
        if (minutes > 0) return `${minutes}m ago`;
        return 'Just now';
      })();

      const icon = feed?.image || (item.contentType === 'podcast' ? 'ðŸŽ§' : 'ðŸ“°');
      const iconHtml = feed?.image ? `<img src="${icon}" alt="">` : icon;

      return `
        <div class="for-later-item ${item.completed ? 'completed' : ''}" data-item-id="${item.id}" data-content-id="${content.id}" data-content-type="${item.contentType}">
          <div class="for-later-checkbox ${item.completed ? 'checked' : ''}" data-item-id="${item.id}"></div>
          <div class="for-later-item-icon">${iconHtml}</div>
          <div class="for-later-item-body">
            <div class="for-later-item-meta">
              <span class="for-later-item-type">${item.contentType}</span>
              <span class="for-later-item-source">${feed?.name || 'Unknown'}</span>
              <span class="for-later-item-time">${timeAgo}</span>
            </div>
            <div class="for-later-item-title">${content.title}</div>
            ${content.summary || content.desc ? `<div class="for-later-item-desc">${content.summary || content.desc}</div>` : ''}
          </div>
          <button class="for-later-item-remove" data-item-id="${item.id}" title="Remove from For Later">
            <i class="ph ph-x"></i>
          </button>
        </div>
      `;
    }).filter(Boolean).join('');

    el.forLaterList.innerHTML = items || `
      <div class="for-later-empty">
        <div class="for-later-empty-icon"><i class="ph ph-clock"></i></div>
        <div class="for-later-empty-title">Items no longer available</div>
        <div class="for-later-empty-desc">The saved items may have been removed from your feeds</div>
      </div>
    `;
  };

  // For Later list click handler
  el.forLaterList.onclick = e => {
    const checkbox = e.target.closest('.for-later-checkbox');
    if (checkbox) {
      const itemId = parseInt(checkbox.dataset.itemId);
      toggleForLaterComplete(itemId);
      return;
    }

    const removeBtn = e.target.closest('.for-later-item-remove');
    if (removeBtn) {
      const itemId = parseInt(removeBtn.dataset.itemId);
      removeFromForLater(itemId);
      return;
    }

    const item = e.target.closest('.for-later-item');
    if (item && !e.target.closest('.for-later-checkbox') && !e.target.closest('.for-later-item-remove')) {
      const contentId = item.dataset.contentId;
      const contentType = item.dataset.contentType;

      if (contentType === 'article') {
        const article = state.articles.find(a => a.id === contentId);
        if (article) openArticleLink(article.link);
      } else if (contentType === 'episode') {
        const episode = state.podcasts.find(p => p.id === contentId);
        if (episode) playEpisode(episode.id);
      }
    }
  };

  // Handle feed nav filter clicks
  el.feedNav.onclick = e => {
    const btn = e.target.closest('.feed-nav-btn');
    if (!btn) return;
    const filter = btn.dataset.filter;
    if (filter && filter !== state.feedFilter) {
      state.feedFilter = filter;
      Mem.log('feed_filter_changed', 'filter_' + filter);
      renderAll();
    }
  };

  // Mobile card view toggle (cycles through: default -> compact -> dense -> list -> default)
  const mobileViewModes = ['default', 'compact', 'dense', 'list'];
  const mobileViewIcons = {
    default: 'ph-rows',
    compact: 'ph-squares-four',
    dense: 'ph-list-bullets',
    list: 'ph-list'
  };

  const applyMobileCardView = () => {
    const mode = state.mobileCardView;
    el.feedScroll.classList.remove('mobile-compact', 'mobile-dense', 'mobile-list');
    if (mode !== 'default') {
      el.feedScroll.classList.add('mobile-' + mode);
    }
    // Update icon
    if (el.mobileViewIcon) {
      el.mobileViewIcon.className = 'ph ' + mobileViewIcons[mode];
    }
    // Save preference
    try { localStorage.setItem('mobileCardView', mode); } catch (e) {}
  };

  // Load saved preference
  try {
    const savedView = localStorage.getItem('mobileCardView');
    if (savedView && mobileViewModes.includes(savedView)) {
      state.mobileCardView = savedView;
    }
  } catch (e) {}

  // Load saved inbox view preferences
  try {
    const savedNewsView = localStorage.getItem('newsInboxView');
    if (savedNewsView && ['list', 'cards', 'table', 'masonry'].includes(savedNewsView)) {
      state.newsInboxView = savedNewsView;
    }
    const savedPodcastView = localStorage.getItem('podcastInboxView');
    if (savedPodcastView && ['list', 'cards'].includes(savedPodcastView)) {
      state.podcastInboxView = savedPodcastView;
    }
    const savedAllView = localStorage.getItem('allView');
    if (savedAllView && ['list', 'cards'].includes(savedAllView)) {
      state.allView = savedAllView;
    }
  } catch (e) {}

  // Toggle handler
  if (el.mobileViewToggle) {
    el.mobileViewToggle.onclick = () => {
      const currentIdx = mobileViewModes.indexOf(state.mobileCardView);
      const nextIdx = (currentIdx + 1) % mobileViewModes.length;
      state.mobileCardView = mobileViewModes[nextIdx];
      applyMobileCardView();
      showToast(`View: ${state.mobileCardView.charAt(0).toUpperCase() + state.mobileCardView.slice(1)}`);
    };
    // Apply initial view
    applyMobileCardView();
  }

  // Handle clicks in feed scroll
  el.feedScroll.onclick = e => {
    // Check for add to later button first
    const laterBtn = e.target.closest('.add-to-later-btn');
    if (laterBtn) {
      e.stopPropagation();
      const contentId = laterBtn.dataset.contentId;
      const contentType = laterBtn.dataset.contentType;
      addToForLater(contentId, contentType);
      renderAll(); // Re-render to update button state
      return;
    }

    const post = e.target.closest('.feed-post');
    if (!post) return;

    const type = post.dataset.type;
    const id = post.dataset.id;

    // Check for specific action buttons
    const playBtn = e.target.closest('.feed-post-play');
    const openBtn = e.target.closest('.feed-post-action[data-action="open"]');

    if (type === 'podcast') {
      // If play button clicked, play directly
      if (playBtn) {
        playEp(id);
      } else {
        // Otherwise navigate to episode page
        renderEpisodePage(id);
      }
    } else if (type === 'news') {
      // For news, open the article
      const art = state.articles.find(a => a.id === id);
      if (art) {
        art.unread = false;
        save();
        Mem.log('article_opened', id, { source: art.feedId, link: art.link });
        openArticleLink(art.link);
        renderAll();
      }
    }
  };

  // === PLAYER ===
  const updatePlayer = () => {
    if (!state.currentEp) { el.player.classList.remove('active'); return; }
    const ep = state.currentEp, show = state.feeds.find(f => f.id === ep.feedId);
    const pr = state.progress[ep.id] || 0, pct = ep.duration ? (pr / ep.duration) * 100 : 0;
    el.player.classList.add('active');
    const artSrc = ep.image || show?.image || placeholderImg;
    el.playerArt.src = artSrc;
    el.playerArt.onerror = () => { el.playerArt.src = placeholderImg; };
    el.expArt.src = artSrc;
    el.expArt.onerror = () => { el.expArt.src = placeholderImg; };
    el.playerTitle.textContent = ep.title;
    el.playerShow.textContent = show?.name || '';
    el.expTitle.textContent = ep.title;
    el.expShow.textContent = show?.name || '';
    el.pCur.textContent = fmt(pr);
    el.pDur.textContent = fmt(ep.duration);
    el.expCur.textContent = fmt(pr);
    el.expDur.textContent = fmt(ep.duration);
    el.pFill.style.width = pct + '%';
    el.expFill.style.width = pct + '%';
    const icon = state.playing ? '<rect x="6" y="4" width="4" height="16" rx="1"/><rect x="14" y="4" width="4" height="16" rx="1"/>' : '<path d="M8 5v14l11-7z"/>';
    el.pPlayIcon.innerHTML = icon;
    el.expPlayIcon.innerHTML = icon;
    el.pSpeed.textContent = state.speed + 'x';
    // Update expanded player speed label
    const expSpeedLabel = $('expSpeedLabel');
    if (expSpeedLabel) expSpeedLabel.textContent = state.speed + 'x';
    // Update track navigation buttons
    updateTrackButtons();
  };

  let progStart = 0;

  // Audio event handlers
  el.audio.addEventListener('timeupdate', () => {
    if (!state.currentEp) return;
    const cur = el.audio.currentTime;
    state.progress[state.currentEp.id] = cur;

    // Log progress every 30 seconds
    if (cur - progStart >= 30) {
      Mem.log('playback_progress', state.currentEp.id, { from: progStart, to: cur, audioUrl: state.currentEp.audioUrl });
      progStart = cur;
    }
    updatePlayer();
    updatePositionState();
    sleepTimer.checkEpisodeEnd();
  });

  el.audio.addEventListener('ended', () => {
    if (state.currentEp) {
      Mem.log('episode_completed', state.currentEp.id, { audioUrl: state.currentEp.audioUrl });
      state.progress[state.currentEp.id] = state.currentEp.duration;
    }
    state.playing = false;
    save();
    updatePlayer();

    // Auto-play next episode in queue
    if (state.queue.length > 0) {
      setTimeout(() => {
        playNextInQueue();
      }, 500); // Small delay for smooth transition
    }
  });

  el.audio.addEventListener('pause', () => {
    state.playing = false;
    updatePlayer();
  });

  el.audio.addEventListener('play', () => {
    state.playing = true;
    updatePlayer();
  });

  el.audio.addEventListener('loadedmetadata', () => {
    if (state.currentEp) {
      // Update duration from audio if available
      if (el.audio.duration && !isNaN(el.audio.duration)) {
        state.currentEp.duration = el.audio.duration;
      }
      // Seek to saved position
      const savedPos = state.progress[state.currentEp.id] || 0;
      if (savedPos > 0 && savedPos < el.audio.duration) {
        el.audio.currentTime = savedPos;
      }
    }
    updatePlayer();
    updateMediaSession();
    renderBookmarkMarkers();
  });

  el.audio.addEventListener('error', (e) => {
    console.error('Audio error:', e);
    toast('Error loading audio. Try again.');
    state.playing = false;
    updatePlayer();
  });

  // Save progress periodically
  setInterval(() => {
    if (state.currentEp && state.playing) {
      save();
    }
  }, 10000);

  // Track current blob URL for cleanup
  let currentBlobUrl = null;

  const playEp = async id => {
    const ep = state.podcasts.find(p => p.id === id);
    if (!ep) return;
    if (!ep.audioUrl) {
      toast('No audio URL for this episode');
      return;
    }

    if (state.currentEp && state.currentEp.id !== id) {
      Mem.log('episode_exited', state.currentEp.id, { pos: state.progress[state.currentEp.id] || 0, audioUrl: state.currentEp.audioUrl });
    }

    state.currentEp = ep;
    const pr = state.progress[id] || 0;
    if (pr > 0) Mem.log('returned_to_episode', id, { prev_pos: pr, audioUrl: ep.audioUrl });
    Mem.log('play_pressed', id, { pos: pr, audioUrl: ep.audioUrl });

    progStart = pr;

    // Clean up previous blob URL
    if (currentBlobUrl) {
      URL.revokeObjectURL(currentBlobUrl);
      currentBlobUrl = null;
    }

    // Check if episode is downloaded and use local content
    let audioSrc = ep.audioUrl;
    if (ep.downloaded) {
      try {
        const downloaded = await DownloadDB.get(id);
        if (downloaded && downloaded.blob) {
          currentBlobUrl = URL.createObjectURL(downloaded.blob);
          audioSrc = currentBlobUrl;
          console.log('Playing from downloaded content');
        }
      } catch (e) {
        console.warn('Failed to load downloaded content, falling back to stream:', e);
      }
    }

    // Set audio source and play
    if (el.audio.src !== audioSrc) {
      el.audio.src = audioSrc;
      el.audio.load();
    }
    el.audio.playbackRate = state.speed;
    el.audio.play().catch(e => {
      console.error('Playback failed:', e);
      toast('Playback failed. Check audio source.');
    });

    state.playing = true;
    updatePlayer();
    updateMediaSession();
    renderBookmarkMarkers();
  };

  const togglePlay = () => {
    if (!state.currentEp) return;
    const pr = state.progress[state.currentEp.id] || 0;

    if (state.playing) {
      el.audio.pause();
      Mem.log('pause_pressed', state.currentEp.id, { pos: pr, audioUrl: state.currentEp.audioUrl });
    } else {
      el.audio.play().catch(e => {
        console.error('Playback failed:', e);
        toast('Playback failed');
      });
      Mem.log('play_pressed', state.currentEp.id, { pos: pr, audioUrl: state.currentEp.audioUrl });
    }
  };

  const seekTo = pos => {
    if (!state.currentEp) return;
    const prev = state.progress[state.currentEp.id] || 0;
    const duration = el.audio.duration || state.currentEp.duration;
    const p = Math.max(0, Math.min(duration, pos));
    Mem.log('seek', state.currentEp.id, { from: prev, to: p, audioUrl: state.currentEp.audioUrl });
    el.audio.currentTime = p;
    state.progress[state.currentEp.id] = p;
    save();
    updatePlayer();
  };

  const skip = s => {
    if (state.currentEp) {
      seekTo(el.audio.currentTime + s);
    }
  };

  const cycleSpeed = () => {
    const sp = [0.5, 0.75, 1, 1.25, 1.5, 1.75, 2];
    const i = sp.indexOf(state.speed);
    const prev = state.speed;
    state.speed = sp[(i + 1) % sp.length];
    el.audio.playbackRate = state.speed;
    Mem.log('speed_changed', 'settings', { speed: state.speed, prev });
    updatePlayer();
  };

  // === VOLUME CONTROLS ===
  const updateVolumeIcon = () => {
    const volume = el.audio.volume * 100;
    let iconPath;
    if (volume === 0) {
      iconPath = '<path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/>';
    } else if (volume < 30) {
      iconPath = '<path d="M7 9v6h4l5 5V4l-5 5H7z"/>';
    } else if (volume < 70) {
      iconPath = '<path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02z"/>';
    } else {
      iconPath = '<path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>';
    }
    el.volumeIcon.innerHTML = iconPath;
  };

  const toggleMute = () => {
    if (el.audio.volume > 0) {
      el.audio.dataset.prevVolume = el.audio.volume;
      el.audio.volume = 0;
      el.volumeSlider.value = 0;
    } else {
      const prevVol = parseFloat(el.audio.dataset.prevVolume || '1');
      el.audio.volume = prevVol;
      el.volumeSlider.value = prevVol * 100;
    }
    updateVolumeIcon();
  };

  const updateTrackButtons = () => {
    if (!state.currentEp) {
      el.pPrev.disabled = true;
      el.pNext.disabled = true;
      el.expPrev.disabled = true;
      el.expNext.disabled = true;
      return;
    }
    const eps = state.podcasts.filter(p => p.feedId === state.currentEp.feedId);
    const idx = eps.findIndex(p => p.id === state.currentEp.id);
    el.pPrev.disabled = idx >= eps.length - 1;
    el.pNext.disabled = idx <= 0;
    el.expPrev.disabled = idx >= eps.length - 1;
    el.expNext.disabled = idx <= 0;
  };

  // === SWIPE SEEKING ===
  // Swipe on cover art to seek: right = rewind, left = forward
  // Short swipe = 5s, medium = 15s, long = 30s, very long = 60s
  const swipeState = {
    active: false,
    startX: 0,
    startY: 0,
    currentX: 0,
    seekAmount: 0
  };

  const getSeekAmount = (distance) => {
    const absDistance = Math.abs(distance);
    if (absDistance < 30) return 0;      // Dead zone
    if (absDistance < 80) return 5;      // Short swipe: 5s
    if (absDistance < 150) return 15;    // Medium swipe: 15s
    if (absDistance < 250) return 30;    // Long swipe: 30s
    return 60;                            // Very long swipe: 60s
  };

  const updateSwipeIndicator = (distance, seekAmount) => {
    if (!el.swipeIndicator) return;

    const isRewind = distance > 0;  // Right swipe = rewind

    el.swipeIndicator.classList.toggle('active', seekAmount > 0);
    el.swipeIndicator.classList.toggle('rewind', isRewind);
    el.swipeIndicator.classList.toggle('forward', !isRewind);

    if (seekAmount > 0) {
      el.swipeIcon.innerHTML = isRewind ? '<i class="ph ph-rewind"></i>' : '<i class="ph ph-fast-forward"></i>';
      el.swipeText.textContent = (isRewind ? '-' : '+') + seekAmount + 's';
      el.swipeLabel.textContent = isRewind ? 'Rewind' : 'Forward';
    }
  };

  const handleSwipeStart = (e) => {
    if (!state.currentEp) return;

    const touch = e.touches ? e.touches[0] : e;
    swipeState.active = true;
    swipeState.startX = touch.clientX;
    swipeState.startY = touch.clientY;
    swipeState.currentX = touch.clientX;
    swipeState.seekAmount = 0;
  };

  const handleSwipeMove = (e) => {
    if (!swipeState.active || !state.currentEp) return;

    const touch = e.touches ? e.touches[0] : e;
    const deltaX = touch.clientX - swipeState.startX;
    const deltaY = touch.clientY - swipeState.startY;

    // Ignore if vertical swipe is dominant (allow scrolling)
    if (Math.abs(deltaY) > Math.abs(deltaX) * 1.5) return;

    // Prevent default to stop scrolling during horizontal swipe
    if (Math.abs(deltaX) > 20) {
      e.preventDefault();
    }

    swipeState.currentX = touch.clientX;
    const newSeekAmount = getSeekAmount(deltaX);

    swipeState.seekAmount = newSeekAmount;
    updateSwipeIndicator(deltaX, newSeekAmount);
  };

  const handleSwipeEnd = (e) => {
    if (!swipeState.active) return;

    const deltaX = swipeState.currentX - swipeState.startX;
    const seekAmount = swipeState.seekAmount;

    if (seekAmount > 0 && state.currentEp) {
      const direction = deltaX > 0 ? -1 : 1;  // Right = rewind (negative), Left = forward (positive)
      const seekSeconds = direction * seekAmount;

      skip(seekSeconds);
      Mem.log('swipe_seek', state.currentEp.id, {
        direction: deltaX > 0 ? 'rewind' : 'forward',
        amount: seekAmount,
        swipeDistance: Math.abs(deltaX),
        audioUrl: state.currentEp.audioUrl
      });
    }

    // Reset state
    swipeState.active = false;
    swipeState.seekAmount = 0;
    updateSwipeIndicator(0, 0);
  };

  // Attach swipe handlers to the artwork container
  if (el.swipeContainer) {
    el.swipeContainer.addEventListener('touchstart', handleSwipeStart, { passive: true });
    el.swipeContainer.addEventListener('touchmove', handleSwipeMove, { passive: false });
    el.swipeContainer.addEventListener('touchend', handleSwipeEnd, { passive: true });
    el.swipeContainer.addEventListener('touchcancel', handleSwipeEnd, { passive: true });

    // Mouse support for desktop testing
    el.swipeContainer.addEventListener('mousedown', handleSwipeStart);
    el.swipeContainer.addEventListener('mousemove', (e) => {
      if (swipeState.active) handleSwipeMove(e);
    });
    el.swipeContainer.addEventListener('mouseup', handleSwipeEnd);
    el.swipeContainer.addEventListener('mouseleave', handleSwipeEnd);
  }

  // === SLEEP TIMER ===
  const sleepTimer = {
    endTime: null,
    intervalId: null,
    fadeIntervalId: null,
    endOfEpisode: false,

    start(minutes) {
      this.cancel();
      if (minutes === 'episode') {
        this.endOfEpisode = true;
        this.updateUI();
        toast('Sleep timer: end of episode');
        return;
      }
      this.endOfEpisode = false;
      this.endTime = Date.now() + minutes * 60 * 1000;
      this.intervalId = setInterval(() => this.tick(), 1000);
      this.updateUI();
      toast(`Sleep timer: ${minutes} minutes`);
    },

    tick() {
      const remaining = this.endTime - Date.now();
      if (remaining <= 0) {
        this.stop();
        return;
      }
      // Start fade out 15 seconds before end
      if (remaining <= 15000 && !this.fadeIntervalId) {
        this.startFade();
      }
      this.updateUI();
    },

    startFade() {
      const originalVolume = el.audio.volume;
      let fadeStep = originalVolume / 15;
      this.fadeIntervalId = setInterval(() => {
        if (el.audio.volume > fadeStep) {
          el.audio.volume = Math.max(0, el.audio.volume - fadeStep);
        }
      }, 1000);
    },

    stop() {
      el.audio.pause();
      el.audio.volume = 1;
      this.cancel();
      toast('Sleep timer: stopped playback');
    },

    cancel() {
      if (this.intervalId) clearInterval(this.intervalId);
      if (this.fadeIntervalId) clearInterval(this.fadeIntervalId);
      this.intervalId = null;
      this.fadeIntervalId = null;
      this.endTime = null;
      this.endOfEpisode = false;
      el.audio.volume = 1;
      this.updateUI();
    },

    updateUI() {
      const isActive = this.endTime || this.endOfEpisode;
      el.sleepTimerContent.style.display = isActive ? 'none' : 'block';
      el.sleepTimerActive.style.display = isActive ? 'flex' : 'none';
      el.sleepBadge.style.display = isActive ? 'block' : 'none';
      el.pSleep.classList.toggle('active', isActive);

      if (this.endOfEpisode) {
        el.sleepCountdown.textContent = 'End of Episode';
        el.sleepBadge.textContent = 'EP';
      } else if (this.endTime) {
        const remaining = Math.max(0, Math.floor((this.endTime - Date.now()) / 1000));
        el.sleepCountdown.textContent = fmtLong(remaining);
        el.sleepBadge.textContent = Math.ceil(remaining / 60);
      }
    },

    checkEpisodeEnd() {
      if (this.endOfEpisode && state.currentEp) {
        const current = el.audio.currentTime;
        const duration = el.audio.duration || state.currentEp.duration;
        if (duration - current <= 15 && !this.fadeIntervalId) {
          this.startFade();
        }
      }
    }
  };

  // === BOOKMARKS ===
  const addBookmark = () => {
    if (!state.currentEp) return;
    const time = el.audio.currentTime;
    const epId = state.currentEp.id;
    if (!state.bookmarks[epId]) state.bookmarks[epId] = [];
    state.bookmarks[epId].push({ time, note: 'Bookmark', created: Date.now() });
    state.bookmarks[epId].sort((a, b) => a.time - b.time);
    save();
    renderBookmarks();
    toast('Bookmark added at ' + fmt(time));
    Mem.log('bookmark_added', epId, { time, audioUrl: state.currentEp.audioUrl });
  };

  const deleteBookmark = (epId, index) => {
    if (state.bookmarks[epId]) {
      state.bookmarks[epId].splice(index, 1);
      if (state.bookmarks[epId].length === 0) delete state.bookmarks[epId];
      save();
      renderBookmarks();
    }
  };

  const jumpToBookmark = (time) => {
    seekTo(time);
    closeAllPanels();
  };

  const renderBookmarks = () => {
    if (!state.currentEp) {
      el.bookmarksList.innerHTML = '<div class="bookmarks-empty">No episode playing</div>';
      return;
    }
    const epId = state.currentEp.id;
    const bookmarks = state.bookmarks[epId] || [];
    if (bookmarks.length === 0) {
      el.bookmarksList.innerHTML = '<div class="bookmarks-empty">No bookmarks yet. Click + to add one.</div>';
      return;
    }
    el.bookmarksList.innerHTML = bookmarks.map((b, i) => `
      <div class="bookmark-item" data-time="${b.time}">
        <span class="bookmark-time">${fmt(b.time)}</span>
        <span class="bookmark-note">${b.note}</span>
        <button class="bookmark-delete" data-index="${i}"><svg width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 5L5 15M5 5l10 10"/></svg></button>
      </div>
    `).join('');
  };

  const renderBookmarkMarkers = () => {
    // Remove existing markers
    document.querySelectorAll('.bookmark-marker').forEach(m => m.remove());
    if (!state.currentEp) return;
    const epId = state.currentEp.id;
    const bookmarks = state.bookmarks[epId] || [];
    const duration = el.audio.duration || state.currentEp.duration;

    bookmarks.forEach(b => {
      const pct = (b.time / duration) * 100;
      const marker = document.createElement('div');
      marker.className = 'bookmark-marker';
      marker.style.left = pct + '%';
      marker.title = fmt(b.time);
      marker.onclick = (e) => { e.stopPropagation(); jumpToBookmark(b.time); };
      el.pBar.appendChild(marker);
    });
  };

  // === EPISODE QUEUE ===
  const addToQueue = (episode, playNext = false) => {
    if (!episode) return;
    // Don't add if already in queue or currently playing
    if (state.queue.find(e => e.id === episode.id)) {
      toast('Already in queue');
      return;
    }
    if (state.currentEp && state.currentEp.id === episode.id) {
      toast('Already playing');
      return;
    }

    if (playNext) {
      state.queue.unshift(episode);
      toast('Playing next');
    } else {
      state.queue.push(episode);
      toast('Added to queue');
    }
    updateQueueBadge();
    renderQueue();
    save();
  };

  const removeFromQueue = (episodeId) => {
    state.queue = state.queue.filter(e => e.id !== episodeId);
    updateQueueBadge();
    renderQueue();
    save();
    toast('Removed from queue');
  };

  const clearQueue = () => {
    state.queue = [];
    updateQueueBadge();
    renderQueue();
    save();
    toast('Queue cleared');
  };

  const playNextInQueue = () => {
    if (state.queue.length === 0) return false;
    const next = state.queue.shift();
    updateQueueBadge();
    renderQueue();
    playEpisode(next);
    return true;
  };

  const updateQueueBadge = () => {
    if (el.queueBadge) {
      if (state.queue.length > 0) {
        el.queueBadge.textContent = state.queue.length;
        el.queueBadge.style.display = '';
      } else {
        el.queueBadge.style.display = 'none';
      }
    }
  };

  const renderQueue = () => {
    if (!el.queueList) return;

    if (state.queue.length === 0) {
      el.queueList.innerHTML = `
        <div class="queue-empty">
          <i class="ph ph-queue"></i>
          <div>Your queue is empty</div>
          <div style="font-size: 12px; margin-top: 4px; opacity: 0.7;">Long press an episode to add it</div>
        </div>
      `;
      return;
    }

    el.queueList.innerHTML = state.queue.map((ep, i) => {
      const feed = state.feeds.find(f => f.id === ep.feedId);
      return `
        <div class="queue-item" data-ep-id="${ep.id}" data-index="${i}">
          <div class="queue-item-art">
            ${ep.image || feed?.image ? `<img src="${ep.image || feed.image}" alt="">` : '<i class="ph ph-microphone-stage" style="padding:10px;color:var(--text3)"></i>'}
          </div>
          <div class="queue-item-info">
            <div class="queue-item-title">${ep.title}</div>
            <div class="queue-item-show">${feed?.name || 'Unknown'}</div>
          </div>
          <button class="queue-item-remove" data-ep-id="${ep.id}" title="Remove"><i class="ph ph-x"></i></button>
        </div>
      `;
    }).join('');
  };

  // === FOR LATER ===
  const addToForLater = (contentId, contentType) => {
    // Check if already in list
    const existing = state.forLater.find(item => item.contentId === contentId && item.contentType === contentType);
    if (existing) {
      toast('Already in For Later list');
      return;
    }

    const item = {
      id: Date.now(),
      contentId: contentId,
      contentType: contentType,
      addedAt: Date.now(),
      completed: false
    };

    state.forLater.unshift(item);
    save();
    toast('Added to For Later');
    if (state.view === 'forLater') renderForLater();
  };

  const removeFromForLater = (itemId) => {
    state.forLater = state.forLater.filter(item => item.id !== itemId);
    save();
    renderForLater();
    toast('Removed from For Later');
  };

  const toggleForLaterComplete = (itemId) => {
    const item = state.forLater.find(i => i.id === itemId);
    if (item) {
      item.completed = !item.completed;
      save();
      renderForLater();
    }
  };

  const isInForLater = (contentId, contentType) => {
    return state.forLater.some(item => item.contentId === contentId && item.contentType === contentType);
  };

  // === SPEED PANEL ===
  const setSpeed = (speed) => {
    const prev = state.speed;
    state.speed = Math.round(speed * 100) / 100;
    el.audio.playbackRate = state.speed;
    el.pSpeed.textContent = state.speed + 'x';
    el.speedValue.textContent = state.speed.toFixed(2) + 'x';
    el.speedSlider.value = state.speed;
    // Update preset buttons
    document.querySelectorAll('.speed-preset-btn').forEach(btn => {
      btn.classList.toggle('active', parseFloat(btn.dataset.speed) === state.speed);
    });
    if (prev !== state.speed) {
      Mem.log('speed_changed', 'settings', { speed: state.speed, prev });
    }
  };

  // === ADAPTIVE BACKGROUND ===
  const extractColor = (img) => {
    try {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = 50;
      canvas.height = 50;
      ctx.drawImage(img, 0, 0, 50, 50);
      const data = ctx.getImageData(0, 0, 50, 50).data;
      let r = 0, g = 0, b = 0, count = 0;
      for (let i = 0; i < data.length; i += 4) {
        r += data[i];
        g += data[i + 1];
        b += data[i + 2];
        count++;
      }
      r = Math.floor(r / count);
      g = Math.floor(g / count);
      b = Math.floor(b / count);
      // Make color darker for better contrast
      r = Math.floor(r * 0.4);
      g = Math.floor(g * 0.4);
      b = Math.floor(b * 0.4);
      return `rgb(${r}, ${g}, ${b})`;
    } catch (e) {
      return null;
    }
  };

  const updateAdaptiveBackground = () => {
    if (!el.expArt.complete || !el.expArt.src) return;
    // Use a separate image with CORS for color extraction
    // This way if CORS fails, the main image still displays
    const corsImg = new Image();
    corsImg.crossOrigin = 'anonymous';
    corsImg.onload = () => {
      const color = extractColor(corsImg);
      if (color) {
        el.expanded.style.setProperty('--adaptive-color', color);
        el.expanded.classList.add('adaptive-bg');
      }
    };
    corsImg.onerror = () => {
      // CORS failed, just skip adaptive background
      el.expanded.classList.remove('adaptive-bg');
    };
    corsImg.src = el.expArt.src;
  };

  el.expArt.onload = updateAdaptiveBackground;

  // === MEDIA SESSION API ===
  const updateMediaSession = () => {
    if (!('mediaSession' in navigator) || !state.currentEp) return;
    const show = state.feeds.find(f => f.id === state.currentEp.feedId);
    navigator.mediaSession.metadata = new MediaMetadata({
      title: state.currentEp.title,
      artist: show?.name || 'Unknown Show',
      album: show?.name || 'Podcast',
      artwork: [{ src: state.currentEp.image || show?.image || '', sizes: '512x512', type: 'image/jpeg' }]
    });
    navigator.mediaSession.setActionHandler('play', () => { el.audio.play(); });
    navigator.mediaSession.setActionHandler('pause', () => { el.audio.pause(); });
    navigator.mediaSession.setActionHandler('seekbackward', () => skip(-15));
    navigator.mediaSession.setActionHandler('seekforward', () => skip(30));
    navigator.mediaSession.setActionHandler('previoustrack', () => playPreviousEpisode());
    navigator.mediaSession.setActionHandler('nexttrack', () => playNextEpisode());
    navigator.mediaSession.setActionHandler('seekto', (e) => { if (e.seekTime != null) seekTo(e.seekTime); });
  };

  const updatePositionState = () => {
    if (!('mediaSession' in navigator) || !state.currentEp) return;
    try {
      navigator.mediaSession.setPositionState({
        duration: el.audio.duration || state.currentEp.duration,
        playbackRate: state.speed,
        position: el.audio.currentTime
      });
    } catch (e) {}
  };

  const playNextEpisode = () => {
    if (!state.currentEp) return;
    const eps = state.podcasts.filter(p => p.feedId === state.currentEp.feedId);
    const idx = eps.findIndex(p => p.id === state.currentEp.id);
    if (idx > 0) playEp(eps[idx - 1].id);
  };

  const playPreviousEpisode = () => {
    if (!state.currentEp) return;
    const eps = state.podcasts.filter(p => p.feedId === state.currentEp.feedId);
    const idx = eps.findIndex(p => p.id === state.currentEp.id);
    if (idx < eps.length - 1) playEp(eps[idx + 1].id);
  };

  // === DRAWER ===
  const openDrawer = () => {
    renderDrawerContent();
    el.drawer.classList.add('active');
    el.drawerOverlay.classList.add('active');
  };

  const closeDrawer = () => {
    el.drawer.classList.remove('active');
    el.drawerOverlay.classList.remove('active');
  };

  const renderDrawerContent = () => {
    const podcasts = state.feeds.filter(f => f.type === 'podcast');
    const news = state.feeds.filter(f => f.type === 'news');
    el.drawerContent.innerHTML = `
      ${podcasts.length ? `
        <div class="drawer-section">
          <div class="drawer-section-title">Podcasts</div>
          ${podcasts.map(f => `
            <div class="drawer-item" data-type="podcast" data-id="${f.id}">
              <div class="drawer-item-icon">${f.image ? `<img src="${f.image}">` : '<i class="ph ph-microphone-stage"></i>'}</div>
              <span class="drawer-item-name">${f.name}</span>
            </div>
          `).join('')}
        </div>
      ` : ''}
      ${news.length ? `
        <div class="drawer-section">
          <div class="drawer-section-title">News Sources</div>
          ${news.map(f => `
            <div class="drawer-item" data-type="news" data-id="${f.id}">
              <div class="drawer-item-icon">${f.image ? `<img src="${f.image}">` : '<i class="ph ph-newspaper"></i>'}</div>
              <span class="drawer-item-name">${f.name}</span>
              ${f.unread ? `<span class="drawer-item-badge">${f.unread}</span>` : ''}
            </div>
          `).join('')}
        </div>
      ` : ''}
      <div class="drawer-section">
        <div class="drawer-section-title">Quick Actions</div>
        <div class="drawer-item" id="drawerAddFeed">
          <div class="drawer-item-icon"><i class="ph ph-plus"></i></div>
          <span class="drawer-item-name">Add Feed</span>
        </div>
        <div class="drawer-item" id="drawerDiscoverPodcasts">
          <div class="drawer-item-icon"><i class="ph ph-magnifying-glass"></i></div>
          <span class="drawer-item-name">Discover Podcasts</span>
        </div>
        <div class="drawer-item" id="drawerRefresh">
          <div class="drawer-item-icon"><i class="ph ph-arrows-clockwise"></i></div>
          <span class="drawer-item-name">Refresh All</span>
        </div>
        <div class="drawer-item" id="drawerHistory">
          <div class="drawer-item-icon"><i class="ph ph-clock-counter-clockwise"></i></div>
          <span class="drawer-item-name">History Snapshots</span>
        </div>
      </div>
    `;
  };

  // === PANEL MANAGEMENT ===
  const closeAllPanels = () => {
    el.speedPanel.classList.remove('active');
    el.bookmarksPanel.classList.remove('active');
    if (el.queuePanel) el.queuePanel.classList.remove('active');
    state.speedPanelOpen = false;
    state.bookmarksPanelOpen = false;
    state.queuePanelOpen = false;
  };

  const toggleSpeedPanel = () => {
    const wasOpen = state.speedPanelOpen;
    closeAllPanels();
    if (!wasOpen) {
      el.speedPanel.classList.add('active');
      state.speedPanelOpen = true;
    }
  };

  const toggleBookmarksPanel = () => {
    const wasOpen = state.bookmarksPanelOpen;
    closeAllPanels();
    if (!wasOpen) {
      renderBookmarks();
      el.bookmarksPanel.classList.add('active');
      state.bookmarksPanelOpen = true;
    }
  };

  // Close panels when clicking outside
  document.addEventListener('click', (e) => {
    if (!e.target.closest('.player-right') && !e.target.closest('.speed-panel') && !e.target.closest('.bookmarks-panel')) {
      closeAllPanels();
    }
  });

  // === VIEW SWITCHING ===
  const setView = (viewName) => {
    const prev = state.view;
    state.view = viewName;
    Mem.log('view_changed', 'view_' + state.view, { prev });

    // Update view containers
    el.newsView.classList.toggle('active', state.view === 'news');
    el.podcastView.classList.toggle('active', state.view === 'podcasts');
    el.allView.classList.toggle('active', state.view === 'all');
    el.forLaterView.classList.toggle('active', state.view === 'forLater');

    // Reset search scope when changing views (keep query)
    state.searchScope = null;
    updateSearchUI();

    // Close any open detail pages when switching views
    if (state.currentEpisodePage) closeEpisodePage();
    if (state.currentShowPage) closeShowPage();
    if (state.currentSourcePage) closeSourcePage();

    // Render the appropriate view
    if (state.view === 'news') renderNews();
    if (state.view === 'podcasts') renderPodcasts();
    if (state.view === 'all') renderAll();
    if (state.view === 'forLater') renderForLater();

    // Update mobile tab bar
    if (typeof updateMobileTabBar === 'function') updateMobileTabBar();

    save();
  };

  // === EVENTS ===
  el.newsSources.onclick = e => {
    const src = e.target.closest('.source-item');
    if (!src) return;
    const id = src.dataset.id;
    if (id === 'all') {
      state.selectedSource = null;
      el.newsTitle.textContent = 'All Articles';
      renderNewsSources(); renderNews();
    } else {
      // Open source page for individual sources
      renderSourcePage(id);
    }
  };
  
  el.categoryChips.onclick = e => {
    const chip = e.target.closest('.chip');
    if (!chip) return;
    const prev = state.selectedCat;
    state.selectedCat = chip.dataset.cat;
    Mem.log('category_changed', 'cat_' + state.selectedCat, { prev });
    renderCategories(); renderNews();
  };

  // Tag filter click handler
  el.tagChips.onclick = e => {
    const chip = e.target.closest('.tag-chip');
    if (!chip) return;
    const prev = state.selectedTag;
    state.selectedTag = chip.dataset.tag;
    Mem.log('tag_filter_changed', 'tag_' + state.selectedTag, { prev });
    renderTagFilters();
    renderNews();
  };

  el.newsList.onclick = e => {
    // Source name click - navigate to source page
    const sourceEl = e.target.closest('.article-source');
    if (sourceEl) {
      const item = e.target.closest('.article');
      if (item) {
        const id = item.dataset.id;
        const art = state.articles.find(a => a.id === id);
        if (art && art.feedId) {
          renderSourcePage(art.feedId);
          return;
        }
      }
    }

    const item = e.target.closest('.article');
    if (!item) return;
    const id = item.dataset.id;
    const art = state.articles.find(a => a.id === id);
    if (art) {
      Mem.log('article_opened', id, { source: art.feedId, link: art.link });
      art.unread = false;
      save();
      openArticleLink(art.link);
      renderNews();
    }
  };

  // Source page event handlers
  el.sourcePage.onclick = e => {
    // Back button
    const backBtn = e.target.closest('#sourceBackBtn');
    if (backBtn) {
      closeSourcePage();
      return;
    }

    // View options for individual source pages
    const viewBtn = e.target.closest('.view-btn');
    if (viewBtn) {
      const sourceKey = viewBtn.closest('.view-options').dataset.source;
      const newView = viewBtn.dataset.view;

      // Source-specific view options
      setViewPref(sourceKey, newView);
      if (state.currentSourcePage) renderSourcePage(state.currentSourcePage);
      return;
    }

    // Edit feed button
    const editBtn = e.target.closest('.edit-feed-btn');
    if (editBtn) {
      const feedId = editBtn.dataset.feedId;
      if (feedId) openEditFeedModal(feedId);
      return;
    }

    // Remove feed button
    const removeBtn = e.target.closest('.remove-feed-btn');
    if (removeBtn) {
      const feedId = removeBtn.dataset.feedId;
      if (feedId) removeFeed(feedId);
      return;
    }

    // Article clicks (all view modes)
    const articleEl = e.target.closest('.article, .article-card, .article-masonry, [data-id]');
    if (articleEl && articleEl.dataset.id) {
      const id = articleEl.dataset.id;
      const art = state.articles.find(a => a.id === id);
      if (art) {
        Mem.log('article_opened', id, { source: art.feedId, link: art.link });
        art.unread = false;
        save();
        showArticleModal(art);
        if (state.currentSourcePage) renderSourcePage(state.currentSourcePage);
        else renderNews();
      }
      return;
    }

    // Table row clicks
    const tableRow = e.target.closest('tr[data-id]');
    if (tableRow) {
      const id = tableRow.dataset.id;
      const art = state.articles.find(a => a.id === id);
      if (art) {
        Mem.log('article_opened', id, { source: art.feedId, link: art.link });
        art.unread = false;
        save();
        showArticleModal(art);
        if (state.currentSourcePage) renderSourcePage(state.currentSourcePage);
        else renderNews();
      }
    }
  };

  // === PODCAST INBOX EVENT HANDLERS ===
  el.podcastSources.onclick = e => {
    const src = e.target.closest('.source-item');
    if (!src) return;
    const id = src.dataset.id;
    if (id === 'all') {
      state.selectedPodcastSource = null;
      el.podcastInboxTitle.textContent = 'All Episodes';
      renderPodcastSources();
      renderPodcastInbox();
    } else {
      // Open show page for individual sources
      renderShowPage(id);
    }
  };

  el.podcastInboxList.onclick = e => {
    // Check for add to later button first
    const laterBtn = e.target.closest('.add-to-later-btn');
    if (laterBtn) {
      e.stopPropagation();
      const contentId = laterBtn.dataset.contentId;
      const contentType = laterBtn.dataset.contentType;
      addToForLater(contentId, contentType);
      renderPodcastInbox(); // Re-render to update button state
      return;
    }

    // Play button overlay click - directly plays the episode
    const playBtn = e.target.closest('.spotify-ep-play-overlay');
    if (playBtn) {
      e.stopPropagation();
      const epId = playBtn.dataset.ep;
      // If already playing this episode, toggle play/pause
      if (state.currentEp?.id === epId) {
        togglePlay();
      } else {
        playEp(epId);
      }
      renderPodcastInbox(); // Re-render to update play states
      return;
    }

    // Episode item click - navigate to episode page
    const item = e.target.closest('.spotify-ep');
    if (item) {
      const epId = item.dataset.ep;
      renderEpisodePage(epId);
    }
  };

  // Add podcast button in sidebar
  document.getElementById('addPodcastBtn').onclick = () => {
    document.getElementById('tPodcast').click();
    el.modal.classList.add('active');
  };

  // Discover podcasts button in sidebar
  document.getElementById('discoverPodcastBtn').onclick = () => {
    openPodcastSearch();
  };

  // Legacy podcastContent handler for show page elements (still needed for show page)
  const podcastContentEl = document.getElementById('podcastContent');
  if (podcastContentEl) podcastContentEl.onclick = e => {
    // Show card click
    const card = e.target.closest('.show-card');
    if (card) { renderShowPage(card.dataset.show); return; }

    // Show name click in episode - navigate to show page
    const showNameEl = e.target.closest('.episode-show');
    if (showNameEl) {
      const epEl = e.target.closest('.episode, .episode-card, .episode-masonry, tr[data-ep]');
      if (epEl && epEl.dataset.ep) {
        const ep = state.podcasts.find(p => p.id === epEl.dataset.ep);
        if (ep && ep.feedId) {
          renderShowPage(ep.feedId);
          return;
        }
      }
    }

    // Play button (list/table view)
    const playBtn = e.target.closest('.ep-play, .table-play-btn');
    if (playBtn) { playEp(playBtn.dataset.ep); return; }

    // Download button
    const dl = e.target.closest('.ep-dl');
    if (dl) {
      const id = dl.dataset.dl;
      const p = state.podcasts.find(x => x.id === id);
      if (p) {
        if (p.downloaded) {
          removeDownload(id);
        } else {
          startDownload(id);
        }
      }
      return;
    }

    // Episode clicks (all view modes - list, card, masonry, table row) - navigate to episode page
    const epEl = e.target.closest('.episode, .episode-card, .episode-masonry, tr[data-ep]');
    if (epEl && epEl.dataset.ep) {
      renderEpisodePage(epEl.dataset.ep);
    }
  };

  el.showPage.onclick = e => {
    // Back button
    const backBtn = e.target.closest('#showBackBtn');
    if (backBtn) {
      closeShowPage();
      return;
    }

    // View options
    const viewBtn = e.target.closest('.view-btn');
    if (viewBtn) {
      const sourceKey = viewBtn.closest('.view-options').dataset.source;
      const newView = viewBtn.dataset.view;
      setViewPref(sourceKey, newView);
      if (state.currentShowPage) renderShowPage(state.currentShowPage);
      return;
    }

    // Edit feed button
    const editBtn = e.target.closest('.edit-feed-btn');
    if (editBtn) {
      const feedId = editBtn.dataset.feedId;
      if (feedId) openEditFeedModal(feedId);
      return;
    }

    // Remove feed button
    const removeBtn = e.target.closest('.remove-feed-btn');
    if (removeBtn) {
      const feedId = removeBtn.dataset.feedId;
      if (feedId) removeFeed(feedId);
      return;
    }

    // Play button (list view)
    const playBtn = e.target.closest('.ep-play, .table-play-btn');
    if (playBtn) { playEp(playBtn.dataset.ep); return; }

    // Show play button
    const showPlay = e.target.closest('.show-play');
    if (showPlay) { const eps = state.podcasts.filter(p => p.feedId === showPlay.dataset.show); if (eps.length) playEp(eps[0].id); return; }

    // Download button
    const dl = e.target.closest('.ep-dl');
    if (dl) {
      const id = dl.dataset.dl;
      const p = state.podcasts.find(x => x.id === id);
      if (p) {
        if (p.downloaded) {
          removeDownload(id);
        } else {
          startDownload(id);
        }
      }
      return;
    }

    // Episode clicks (all view modes - list, card, masonry, table row) - navigate to episode page
    const epEl = e.target.closest('.episode, .episode-card, .episode-masonry, tr[data-ep]');
    if (epEl && epEl.dataset.ep) {
      renderEpisodePage(epEl.dataset.ep);
    }
  };

  // Episode page event handlers
  el.episodePage.onclick = e => {
    // Back button
    const backBtn = e.target.closest('#episodeBackBtn');
    if (backBtn) {
      closeEpisodePage();
      return;
    }

    // Show name click - navigate to show page
    const showNameEl = e.target.closest('.episode-hero-show');
    if (showNameEl) {
      const showId = showNameEl.dataset.show;
      if (showId) {
        closeEpisodePage();
        renderShowPage(showId);
      }
      return;
    }

    // Play button
    const playBtn = e.target.closest('.episode-play-btn');
    if (playBtn) {
      const epId = playBtn.dataset.ep;
      if (state.currentEp?.id === epId) {
        togglePlay();
      } else {
        playEp(epId);
      }
      // Re-render to update play/pause button state
      renderEpisodePage(epId);
      return;
    }

    // Download button
    const dlBtn = e.target.closest('.episode-action-btn[data-dl]');
    if (dlBtn) {
      const id = dlBtn.dataset.dl;
      const p = state.podcasts.find(x => x.id === id);
      if (p) {
        if (p.downloaded) {
          removeDownload(id);
        } else {
          startDownload(id);
        }
        // Re-render to update download button state
        setTimeout(() => renderEpisodePage(id), 100);
      }
      return;
    }

    // Add bookmark button
    const bookmarkBtn = e.target.closest('#episodeBookmarkBtn');
    if (bookmarkBtn) {
      const epId = bookmarkBtn.dataset.ep;
      // If the episode is playing, add bookmark at current time
      if (state.currentEp?.id === epId) {
        addBookmark();
        toast('Bookmark saved');
        renderEpisodePage(epId);
      } else {
        // If not playing, start playing first then user can add bookmark
        toast('Start playing to add a bookmark');
      }
      return;
    }

    // Save for Later button
    const saveForLaterBtn = e.target.closest('#episodeSaveForLaterBtn');
    if (saveForLaterBtn) {
      const contentId = saveForLaterBtn.dataset.contentId;
      const contentType = saveForLaterBtn.dataset.contentType;
      addToForLater(contentId, contentType);
      renderEpisodePage(state.currentEpisodePage); // Re-render to update button state
      return;
    }

    // Bookmark item click - seek to that time
    const bookmarkItem = e.target.closest('.episode-bookmark-item');
    if (bookmarkItem) {
      const time = parseFloat(bookmarkItem.dataset.time);
      const epId = state.currentEpisodePage;
      // If this episode is currently loaded, seek to time
      if (state.currentEp?.id === epId) {
        seekTo(time);
      } else {
        // Play the episode first
        playEp(epId);
        // Seek after a short delay to allow audio to load
        setTimeout(() => seekTo(time), 500);
      }
      return;
    }
  };

  el.pPlay.onclick = togglePlay;
  el.expPlay.onclick = togglePlay;
  el.pSpeed.onclick = cycleSpeed;
  $('pSkipBack').onclick = () => skip(-15);
  $('pSkipFwd').onclick = () => skip(30);
  $('expBack').onclick = () => skip(-15);
  $('expFwd').onclick = () => skip(30);
  el.pPrev.onclick = playPreviousEpisode;
  el.pNext.onclick = playNextEpisode;
  el.volumeSlider.oninput = e => { el.audio.volume = e.target.value / 100; updateVolumeIcon(); };
  el.pVolumeBtn.onclick = toggleMute;
  el.pBar.onclick = e => { if (!state.currentEp) return; const r = el.pBar.getBoundingClientRect(); seekTo((e.clientX - r.left) / r.width * (el.audio.duration || state.currentEp.duration)); };
  el.pBar.onmousemove = e => {
    if (!state.currentEp) return;
    const r = el.pBar.getBoundingClientRect();
    const pct = Math.max(0, Math.min(1, (e.clientX - r.left) / r.width));
    const duration = el.audio.duration || state.currentEp.duration;
    const time = pct * duration;
    el.scrubTooltip.textContent = fmt(time);
    el.scrubTooltip.style.left = (pct * 100) + '%';
  };
  el.expBar.onclick = e => { if (!state.currentEp) return; const r = el.expBar.getBoundingClientRect(); seekTo((e.clientX - r.left) / r.width * state.currentEp.duration); };
  $('pExpand').onclick = () => el.expanded.classList.add('active');
  $('expClose').onclick = () => el.expanded.classList.remove('active');
  el.playerArt.onclick = () => el.expanded.classList.add('active');

  // Expanded player track navigation
  el.expPrev.onclick = playPreviousEpisode;
  el.expNext.onclick = playNextEpisode;

  // Expanded player extra controls
  $('expSpeed').onclick = () => {
    cycleSpeed();
    $('expSpeedLabel').textContent = state.speed + 'x';
  };
  $('expSleep').onclick = () => {
    el.expanded.classList.remove('active');
    el.sleepTimerModal.classList.add('active');
  };
  $('expBookmark').onclick = () => {
    addBookmark();
    toast('Bookmark saved');
  };

  // Tapping the player opens expanded player on mobile
  document.querySelector('.player-left').onclick = () => el.expanded.classList.add('active');

  // On mobile, make entire player clickable to expand (except play button)
  el.player.addEventListener('click', e => {
    // Check if we're on mobile (640px breakpoint)
    if (window.innerWidth > 640) return;
    // Don't expand if clicking play button
    if (e.target.closest('.player-play') || e.target.closest('#pPlay')) return;
    el.expanded.classList.add('active');
  });

  $('refreshBtn').onclick = () => refreshAllFeeds();
  $('addBtn').onclick = () => el.modal.classList.add('active');
  $('addNewsBtn').onclick = () => { $('tNews').click(); el.modal.classList.add('active'); };
  $('modalClose').onclick = () => el.modal.classList.remove('active');
  el.modal.onclick = e => { if (e.target === el.modal) el.modal.classList.remove('active'); };
  $('tNews').onclick = () => { state.feedType = 'news'; $('tNews').classList.add('active'); $('tPodcast').classList.remove('active'); };
  $('tPodcast').onclick = () => { state.feedType = 'podcast'; $('tPodcast').classList.add('active'); $('tNews').classList.remove('active'); };

  // Edit feed modal handlers
  const openEditFeedModal = feedId => {
    const feed = state.feeds.find(f => f.id === feedId);
    if (!feed) return;
    el.editFeedId.value = feedId;
    el.editName.value = feed.name || '';
    el.editAuthor.value = feed.author || '';
    el.editCat.value = feed.category || '';
    el.editImage.value = feed.image || '';
    el.editStatus.textContent = '';
    el.editStatus.className = 'fetch-status';
    el.editModal.classList.add('active');
  };

  el.editModalClose.onclick = () => el.editModal.classList.remove('active');
  el.editModal.onclick = e => { if (e.target === el.editModal) el.editModal.classList.remove('active'); };

  // Article modal handlers
  el.articleModalClose.onclick = () => closeArticleModal();
  el.articleModal.onclick = e => {
    if (e.target === el.articleModal) closeArticleModal();
    // Handle image click to open external link
    if (e.target.classList.contains('article-modal-image')) {
      const link = e.target.dataset.link;
      if (link) openArticleLink(link);
    }
  };

  el.editSubmit.onclick = () => {
    const feedId = el.editFeedId.value;
    const feed = state.feeds.find(f => f.id === feedId);
    if (!feed) return;

    // Capture new values
    const newName = el.editName.value.trim() || feed.name;
    const newAuthor = el.editAuthor.value.trim();
    const newCategory = el.editCat.value.trim() || 'Uncategorized';
    const newImage = el.editImage.value.trim();

    // Check if anything actually changed
    const hasChanges = feed.name !== newName ||
                       feed.author !== newAuthor ||
                       feed.category !== newCategory ||
                       feed.image !== newImage;

    // Update feed properties
    feed.name = newName;
    feed.author = newAuthor;
    feed.category = newCategory;
    feed.image = newImage;

    // Update categories set
    state.categories = new Set(state.feeds.map(f => f.category || 'Uncategorized'));

    // Log feed update to Xano for cross-device tracking
    if (hasChanges) {
      Mem.log('feed_updated', feedId, {
        url: feed.url,
        name: feed.name,
        category: feed.category,
        tags: feed.tags,
        description: feed.description,
        image: feed.image
      });

      // Sync feeding activity to activity-post endpoint
      FeedingActivity.log('feed_updated', {
        feedId: feedId,
        url: feed.url,
        name: feed.name,
        type: feed.type,
        category: feed.category,
        author: feed.author,
        image: feed.image,
        tags: feed.tags,
        description: feed.description
      });
    }

    save(hasChanges); // Immediate sync if changes made
    el.editModal.classList.remove('active');
    toast('Feed updated');

    // Re-render the current page to show changes
    if (state.currentSourcePage === feedId) renderSourcePage(feedId);
    if (state.currentShowPage === feedId) renderShowPage(feedId);
    renderNewsSources();
    renderPodcastSources();
  };

  // Settings modal handlers
  el.settingsBtn.onclick = () => {
    el.openLinksToggle.checked = state.openLinksInNewTab;
    el.settingsModal.classList.add('active');
  };
  el.settingsClose.onclick = () => el.settingsModal.classList.remove('active');
  el.settingsModal.onclick = e => { if (e.target === el.settingsModal) el.settingsModal.classList.remove('active'); };
  el.openLinksToggle.onchange = () => {
    state.openLinksInNewTab = el.openLinksToggle.checked;
    save();
    toast(state.openLinksInNewTab ? 'Links will open in new tab' : 'Links will open in same tab');
  };

  // Activity cleanup handlers
  const refreshActivityStats = async () => {
    el.activityStatTotal.textContent = '...';
    el.activityStatSnapshots.textContent = '...';
    el.activityStatSavings.textContent = '...';

    try {
      const stats = await ActivityCleanup.getStats();
      el.activityStatTotal.textContent = stats.total.toLocaleString();
      el.activityStatSnapshots.textContent = stats.snapshots;
      const totalSavings =
        stats.potentialSavings.duplicateProgress +
        stats.potentialSavings.oldEphemeral +
        stats.potentialSavings.redundantPairs +
        stats.potentialSavings.beforeSnapshot;
      el.activityStatSavings.textContent = totalSavings > 0 ? `~${totalSavings} activities` : 'None';
    } catch (e) {
      el.activityStatTotal.textContent = 'Error';
      console.error('Failed to fetch activity stats:', e);
    }
  };

  el.refreshActivityStats.onclick = refreshActivityStats;

  el.runActivityCleanup.onclick = async () => {
    if (!confirm('Run activity cleanup? This will delete old/redundant activities from the server.')) return;

    el.runActivityCleanup.disabled = true;
    el.cleanupStatus.style.display = 'block';
    el.cleanupStatus.textContent = 'Running cleanup...';
    el.cleanupStatus.style.color = 'var(--text2)';

    try {
      const results = await ActivityCleanup.runFullCleanup();
      el.cleanupStatus.textContent = `Done! Deleted ${results.totalDeleted} activities in ${(results.duration / 1000).toFixed(1)}s`;
      el.cleanupStatus.style.color = 'var(--accent)';
      toast(`Cleanup complete: ${results.totalDeleted} activities removed`);
      refreshActivityStats();
    } catch (e) {
      el.cleanupStatus.textContent = 'Cleanup failed: ' + e.message;
      el.cleanupStatus.style.color = '#e74c3c';
      console.error('Cleanup failed:', e);
    }

    el.runActivityCleanup.disabled = false;
    setTimeout(() => { el.cleanupStatus.style.display = 'none'; }, 5000);
  };

  // Load stats when settings modal opens
  const originalSettingsOpen = el.settingsBtn.onclick;
  el.settingsBtn.onclick = () => {
    originalSettingsOpen();
    refreshActivityStats();
  };

  // Form validation and state
  let metadataFetched = false;
  const validateForm = () => {
    const hasUrl = el.fUrl.value.trim().length > 0;
    el.fFetch.disabled = !hasUrl;
    el.fSubmit.disabled = !hasUrl;
  };

  const setFetchStatus = (message, type) => {
    el.fStatus.textContent = message;
    el.fStatus.className = 'fetch-status ' + (type || '');
  };

  const setFormDisabled = (disabled) => {
    el.fUrl.disabled = disabled;
    el.fName.disabled = disabled;
    el.fAuthor.disabled = disabled;
    el.fCat.disabled = disabled;
    el.fFetch.disabled = disabled;
  };

  // Fetch metadata when button is clicked
  el.fFetch.onclick = async () => {
    const url = el.fUrl.value.trim();
    if (!url) return;

    // Show loading state
    el.fFetch.disabled = true;
    el.fFetch.textContent = 'Fetching...';
    el.fFetch.classList.add('loading');
    setFetchStatus('Fetching feed metadata...', 'loading');

    const result = await fetchFeedMetadata(url);

    el.fFetch.textContent = 'Fetch';
    el.fFetch.classList.remove('loading');
    el.fFetch.disabled = false;

    if (result.success) {
      // Pre-populate form fields with fetched metadata
      if (result.title && !el.fName.value.trim()) {
        el.fName.value = result.title;
      }
      if (result.author && !el.fAuthor.value.trim()) {
        el.fAuthor.value = result.author;
      }

      // Auto-select feed type based on content
      if (result.suggestedType === 'podcast') {
        state.feedType = 'podcast';
        $('tPodcast').classList.add('active');
        $('tNews').classList.remove('active');
      } else {
        state.feedType = 'news';
        $('tNews').classList.add('active');
        $('tPodcast').classList.remove('active');
      }

      metadataFetched = true;
      // Show appropriate message based on what was found
      if (result.title || result.author) {
        setFetchStatus('Metadata loaded! You can edit the fields below.', 'success');
      } else {
        setFetchStatus('Feed found but no metadata detected. Please enter name manually.', 'success');
      }
    } else {
      setFetchStatus('Failed to fetch: ' + (result.error || 'Unknown error'), 'error');
    }
  };

  // Also fetch on URL blur if we haven't fetched yet
  el.fUrl.onblur = () => {
    const url = el.fUrl.value.trim();
    // Support http, https, podcast://, feed://, pcast://, podcasts:// schemes
    const validSchemes = ['http://', 'https://', 'podcast://', 'feed://', 'pcast://', 'podcasts://'];
    const hasValidScheme = validSchemes.some(s => url.toLowerCase().startsWith(s));
    if (url && !metadataFetched && hasValidScheme) {
      el.fFetch.click();
    }
  };

  el.fUrl.oninput = () => {
    metadataFetched = false; // Reset when URL changes
    setFetchStatus('', '');
    validateForm();
  };
  el.fName.oninput = validateForm;
  el.fAuthor.oninput = validateForm;

  el.fSubmit.onclick = async () => {
    const rawUrl = el.fUrl.value.trim();
    const url = normalizeFeedUrl(rawUrl); // Convert podcast://, feed://, etc. to https://
    const name = el.fName.value.trim();
    const author = el.fAuthor.value.trim();
    const cat = el.fCat.value.trim() || 'Uncategorized';
    if (!url) return;

    // Disable form while adding
    el.fSubmit.disabled = true;
    el.fSubmit.textContent = 'Adding...';
    setFormDisabled(true);

    await addFeed(url, name, state.feedType, cat, author);

    // Reset form
    el.fUrl.value = '';
    el.fName.value = '';
    el.fAuthor.value = '';
    el.fCat.value = '';
    el.fSubmit.textContent = 'Add Feed';
    el.fSubmit.disabled = true;
    setFormDisabled(false);
    setFetchStatus('', '');
    metadataFetched = false;
    el.modal.classList.remove('active');
  };
  
  // === SEARCH FUNCTIONALITY ===
  let searchTO;

  // Update search box UI state
  const updateSearchUI = () => {
    const hasQuery = state.query.length > 0;
    el.searchBox.classList.toggle('has-query', hasQuery);

    // Update placeholder based on search scope
    if (state.searchScope) {
      const feed = state.feeds.find(f => f.id === state.searchScope);
      el.searchInput.placeholder = feed ? `Search in "${feed.name}"...` : 'Search...';
    } else {
      el.searchInput.placeholder = 'Search all content...';
    }
  };

  // Render search scope dropdown
  const renderSearchScope = () => {
    const currentView = state.view;
    let feeds = [];

    if (currentView === 'news') {
      feeds = state.feeds.filter(f => f.type === 'news');
    } else if (currentView === 'podcasts') {
      feeds = state.feeds.filter(f => f.type === 'podcast');
    } else {
      feeds = state.feeds;
    }

    const typeLabel = currentView === 'news' ? 'news feeds' : currentView === 'podcasts' ? 'podcasts' : 'all feeds';

    el.searchScope.innerHTML = `
      <div class="search-scope-header">Search in</div>
      <div class="search-scope-item ${!state.searchScope ? 'active' : ''}" data-scope="">
        <div class="scope-icon"><i class="ph ph-globe"></i></div>
        <span class="scope-name">All ${typeLabel}</span>
      </div>
      ${feeds.map(f => `
        <div class="search-scope-item ${state.searchScope === f.id ? 'active' : ''}" data-scope="${f.id}">
          <div class="scope-icon">${f.image ? `<img src="${f.image}">` : `<i class="ph ph-${f.type === 'podcast' ? 'microphone-stage' : 'newspaper'}"></i>`}</div>
          <span class="scope-name">${f.name}</span>
        </div>
      `).join('')}
    `;
  };

  // Show/hide search scope dropdown
  const toggleSearchScope = (show) => {
    if (show) {
      renderSearchScope();
      el.searchScope.classList.add('active');
    } else {
      el.searchScope.classList.remove('active');
    }
  };

  // Handle search scope selection
  el.searchScope.onclick = e => {
    const item = e.target.closest('.search-scope-item');
    if (!item) return;

    const scopeId = item.dataset.scope;
    state.searchScope = scopeId ? parseInt(scopeId) : null;
    toggleSearchScope(false);
    updateSearchUI();
    triggerSearch();
  };

  // Trigger search in current view
  const triggerSearch = () => {
    if (state.view === 'news') renderNews();
    else if (state.view === 'podcasts') renderPodcastInbox();
    else if (state.view === 'all') renderAll();
  };

  // Search input handler
  el.searchInput.oninput = e => {
    clearTimeout(searchTO);
    searchTO = setTimeout(() => {
      state.query = e.target.value;
      updateSearchUI();
      triggerSearch();
      // Log search for analytics
      if (state.query.length >= 2) {
        Mem.log('search', state.query, { scope: state.searchScope, view: state.view });
      }
    }, 200);
  };

  // Focus search input to show scope dropdown
  el.searchInput.onfocus = () => {
    if (state.feeds.length > 0) {
      toggleSearchScope(true);
    }
  };

  // Handle Escape key in search input to clear search
  el.searchInput.onkeydown = e => {
    if (e.key === 'Escape') {
      if (state.query || state.searchScope) {
        e.preventDefault();
        state.query = '';
        state.searchScope = null;
        el.searchInput.value = '';
        updateSearchUI();
        triggerSearch();
      }
      el.searchInput.blur();
      toggleSearchScope(false);
    }
  };

  // Clear search
  el.searchClear.onclick = () => {
    state.query = '';
    state.searchScope = null;
    el.searchInput.value = '';
    updateSearchUI();
    triggerSearch();
    el.searchInput.focus();
  };

  // Close search scope on click outside
  document.addEventListener('click', e => {
    if (!el.searchBox.contains(e.target)) {
      toggleSearchScope(false);
    }
  });

  // === KEYBOARD SHORTCUTS ===
  document.onkeydown = e => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

    // Close article modal with Escape
    if (e.key === 'Escape' && el.articleModal.classList.contains('active')) {
      closeArticleModal();
      return;
    }

    // Basic playback
    if (e.code === 'Space') { e.preventDefault(); togglePlay(); return; }
    if (e.code === 'ArrowLeft' && !e.shiftKey) { skip(-15); return; }
    if (e.code === 'ArrowRight' && !e.shiftKey) { skip(30); return; }

    // Volume control with Shift+Arrow keys
    if (e.shiftKey && e.code === 'ArrowUp') {
      e.preventDefault();
      el.audio.volume = Math.min(1, el.audio.volume + 0.05);
      el.volumeSlider.value = el.audio.volume * 100;
      updateVolumeIcon();
      return;
    }
    if (e.shiftKey && e.code === 'ArrowDown') {
      e.preventDefault();
      el.audio.volume = Math.max(0, el.audio.volume - 0.05);
      el.volumeSlider.value = el.audio.volume * 100;
      updateVolumeIcon();
      return;
    }

    // Fullscreen toggle
    if (e.key === 'f' || e.key === 'F') {
      e.preventDefault();
      el.expanded.classList.toggle('active');
      return;
    }
    if (e.key === 'Escape') {
      el.expanded.classList.remove('active');
      el.sleepTimerModal.classList.remove('active');
      el.snapshotModal.classList.remove('active');
      toggleSearchScope(false);
      closeAllPanels();
      closeDrawer();
      return;
    }

    // Bookmarks
    if (e.key === 'b' || e.key === 'B') {
      if (!e.shiftKey) { e.preventDefault(); addBookmark(); }
      return;
    }

    // Speed panel
    if (e.key === 's' || e.key === 'S') {
      if (!e.ctrlKey && !e.metaKey) { e.preventDefault(); toggleSpeedPanel(); }
      return;
    }

    // Mute toggle with M
    if ((e.key === 'm' || e.key === 'M') && !e.ctrlKey && !e.metaKey && !e.shiftKey) {
      e.preventDefault();
      toggleMute();
      return;
    }

    // Sleep timer with Ctrl+M
    if ((e.key === 'm' || e.key === 'M') && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      el.sleepTimerModal.classList.toggle('active');
      return;
    }

    // Speed adjust with brackets
    if (e.key === '[') { e.preventDefault(); setSpeed(Math.max(0.5, state.speed - 0.05)); return; }
    if (e.key === ']') { e.preventDefault(); setSpeed(Math.min(3, state.speed + 0.05)); return; }

    // Speed presets with Ctrl+1-5
    if (e.ctrlKey || e.metaKey) {
      const presets = { '1': 0.75, '2': 1, '3': 1.25, '4': 1.5, '5': 2 };
      if (presets[e.key]) { e.preventDefault(); setSpeed(presets[e.key]); return; }
    }

    // Next/Previous episode with Shift+N/P
    if (e.shiftKey) {
      if (e.key === 'N' || e.key === 'n') { e.preventDefault(); playNextEpisode(); return; }
      if (e.key === 'P' || e.key === 'p') { e.preventDefault(); playPreviousEpisode(); return; }
    }

    // Focus search with / or Ctrl+K
    if (e.key === '/' || ((e.ctrlKey || e.metaKey) && e.key === 'k')) {
      e.preventDefault();
      el.searchInput.focus();
      el.searchInput.select();
      return;
    }
  };

  // === NEW FEATURE EVENT HANDLERS ===

  // Hamburger & Drawer
  el.hamburgerBtn.onclick = openDrawer;
  el.drawerClose.onclick = closeDrawer;
  el.drawerOverlay.onclick = closeDrawer;
  el.drawerContent.onclick = e => {
    const item = e.target.closest('.drawer-item');
    if (!item) return;
    if (item.id === 'drawerAddFeed') {
      closeDrawer();
      el.modal.classList.add('active');
      return;
    }
    if (item.id === 'drawerDiscoverPodcasts') {
      closeDrawer();
      openPodcastSearch();
      return;
    }
    if (item.id === 'drawerRefresh') {
      closeDrawer();
      refreshAllFeeds();
      return;
    }
    if (item.id === 'drawerHistory') {
      closeDrawer();
      openSnapshotModal();
      return;
    }
    const type = item.dataset.type;
    const id = item.dataset.id;
    closeDrawer();
    if (type === 'podcast') {
      state.view = 'podcasts';
      el.newsView.classList.remove('active');
      el.podcastView.classList.add('active');
      el.allView.classList.remove('active');
      renderShowPage(id);
    } else if (type === 'news') {
      state.view = 'news';
      el.newsView.classList.add('active');
      el.podcastView.classList.remove('active');
      el.allView.classList.remove('active');
      renderSourcePage(id);
    }
  };

  // Mobile Tab Bar
  const updateMobileTabBar = () => {
    if (!el.mobileTabBar) return;
    el.mobileTabBar.querySelectorAll('.mobile-tab').forEach(tab => {
      const tabName = tab.dataset.tab;
      // Map tab names to view names
      const isActive = (tabName === 'podcasts' && state.view === 'podcasts') ||
                       (tabName === 'news' && state.view === 'news') ||
                       (tabName === 'forLater' && state.view === 'forLater') ||
                       (tabName === 'library' && state.view === 'all');
      tab.classList.toggle('active', isActive);
    });
  };

  if (el.mobileTabBar) {
    el.mobileTabBar.onclick = e => {
      const tab = e.target.closest('.mobile-tab');
      if (!tab) return;
      const tabName = tab.dataset.tab;

      // Close any open detail pages
      if (state.currentEpisodePage) closeEpisodePage();
      if (state.currentShowPage) closeShowPage();
      if (state.currentSourcePage) closeSourcePage();

      switch (tabName) {
        case 'podcasts':
          setView('podcasts');
          break;
        case 'news':
          setView('news');
          break;
        case 'discover':
          openPodcastSearch();
          break;
        case 'forLater':
          setView('forLater');
          break;
        case 'library':
          // Open drawer for library/settings
          openDrawer();
          break;
      }
      updateMobileTabBar();
    };
  }

  // Sleep Timer
  el.pSleep.onclick = () => el.sleepTimerModal.classList.add('active');
  el.sleepTimerModal.onclick = e => { if (e.target === el.sleepTimerModal) el.sleepTimerModal.classList.remove('active'); };
  el.sleepPresets.onclick = e => {
    const btn = e.target.closest('.sleep-preset');
    if (!btn) return;
    const minutes = btn.dataset.minutes;
    sleepTimer.start(minutes === 'episode' ? 'episode' : parseInt(minutes));
    el.sleepTimerModal.classList.remove('active');
  };
  el.sleepCustomBtn.onclick = () => {
    const val = parseInt(el.sleepCustomInput.value);
    if (val > 0 && val <= 999) {
      sleepTimer.start(val);
      el.sleepCustomInput.value = '';
      el.sleepTimerModal.classList.remove('active');
    }
  };
  el.sleepCancelBtn.onclick = () => {
    sleepTimer.cancel();
    toast('Sleep timer cancelled');
  };

  // === SNAPSHOT MODAL ===
  const renderSnapshotList = async () => {
    try {
      const snapshots = await SnapshotDB.listSnapshots();
      if (!snapshots.length) {
        el.snapshotList.innerHTML = `
          <div class="snapshot-empty" style="text-align:center;padding:32px;color:var(--text2)">
            <i class="ph ph-clock-counter-clockwise" style="font-size:48px;opacity:0.3"></i>
            <p style="margin-top:12px">No snapshots yet</p>
            <p style="font-size:13px">Create a snapshot to save your current state</p>
          </div>`;
        return;
      }
      el.snapshotList.innerHTML = snapshots.map(snap => {
        // Support both old (articleCount/podcastCount) and new (archivedArticleCount/archivedPodcastCount) formats
        const archivedArticles = snap.stats.archivedArticleCount ?? snap.stats.articleCount ?? 0;
        const archivedPodcasts = snap.stats.archivedPodcastCount ?? snap.stats.podcastCount ?? 0;
        return `
        <div class="snapshot-item" data-id="${snap.id}">
          <div class="snapshot-icon"><i class="ph ph-clock-counter-clockwise"></i></div>
          <div class="snapshot-info">
            <div class="snapshot-date">${snap.date}</div>
            <div class="snapshot-reason">${snap.reason.replace(/_/g, ' ')}</div>
            <div class="snapshot-stats">${snap.stats.feedCount} feeds, ${archivedArticles} archived articles, ${archivedPodcasts} archived episodes</div>
          </div>
          <div class="snapshot-actions-row">
            <button class="snapshot-btn restore" data-action="restore" data-id="${snap.id}">Restore</button>
            <button class="snapshot-btn delete" data-action="delete" data-id="${snap.id}"><i class="ph ph-trash"></i></button>
          </div>
        </div>
      `}).join('');
    } catch (e) {
      console.error('Failed to render snapshots:', e);
      el.snapshotList.innerHTML = '<div style="color:var(--text2);text-align:center;padding:20px">Failed to load snapshots</div>';
    }
  };

  const openSnapshotModal = async () => {
    el.snapshotModal.classList.add('active');
    await renderSnapshotList();
  };

  const closeSnapshotModal = () => {
    el.snapshotModal.classList.remove('active');
  };

  el.snapshotModalClose.onclick = closeSnapshotModal;
  el.snapshotModal.onclick = e => { if (e.target === el.snapshotModal) closeSnapshotModal(); };

  el.createSnapshotBtn.onclick = async () => {
    try {
      await SnapshotDB.createSnapshot('manual');
      toast('Snapshot created');
      await renderSnapshotList();
    } catch (e) {
      toast('Failed to create snapshot');
      console.error(e);
    }
  };

  el.snapshotList.onclick = async e => {
    const btn = e.target.closest('.snapshot-btn');
    if (!btn) return;

    const action = btn.dataset.action;
    const id = btn.dataset.id;

    if (action === 'restore') {
      if (!confirm('Restore this snapshot? Your current state will be saved first.')) return;
      try {
        const snap = await SnapshotDB.restoreSnapshot(id);
        toast(`Restored to ${new Date(snap.timestamp).toLocaleString()}`);
        closeSnapshotModal();
        // Re-render everything
        renderNewsSources();
        renderCategories();
        renderTagFilters();
        renderNews();
        renderPodcasts();
        renderAll();
      } catch (e) {
        toast('Failed to restore snapshot');
        console.error(e);
      }
    } else if (action === 'delete') {
      if (!confirm('Delete this snapshot?')) return;
      try {
        await SnapshotDB.deleteSnapshot(id);
        toast('Snapshot deleted');
        await renderSnapshotList();
      } catch (e) {
        toast('Failed to delete snapshot');
        console.error(e);
      }
    }
  };

  // Expose snapshot modal opener globally
  window.openSnapshotModal = openSnapshotModal;

  // === PODCAST SEARCH MODAL ===
  let podcastSearchResults = []; // Store current search results

  const renderPodcastSearchResults = (podcasts) => {
    if (!podcasts || podcasts.length === 0) {
      el.podcastSearchResults.innerHTML = `
        <div class="podcast-search-empty">
          <i class="ph ph-microphone-stage"></i>
          <p>No podcasts found. Try a different search term.</p>
        </div>`;
      return;
    }

    // Check which podcasts are already subscribed
    const subscribedUrls = new Set(state.feeds.map(f => f.url.toLowerCase()));

    el.podcastSearchResults.innerHTML = podcasts.map((podcast, index) => {
      const isSubscribed = subscribedUrls.has(podcast.url?.toLowerCase()) ||
                          subscribedUrls.has(podcast.originalUrl?.toLowerCase());
      const episodeCount = podcast.episodeCount || 0;
      const lastUpdate = podcast.lastUpdateTime ? new Date(podcast.lastUpdateTime * 1000).toLocaleDateString() : '';

      return `
        <div class="podcast-result-item" data-index="${index}">
          <div class="podcast-result-art">
            <img src="${podcast.image || podcast.artwork || placeholderImg}" alt="${podcast.title}" onerror="this.src='${placeholderImg}'">
          </div>
          <div class="podcast-result-info">
            <div class="podcast-result-title" title="${podcast.title}">${podcast.title}</div>
            <div class="podcast-result-author" title="${podcast.author || podcast.ownerName || ''}">${podcast.author || podcast.ownerName || 'Unknown'}</div>
            <div class="podcast-result-meta">
              ${episodeCount ? `<span>${episodeCount} episodes</span>` : ''}
              ${lastUpdate ? `<span>Updated ${lastUpdate}</span>` : ''}
            </div>
          </div>
          <div class="podcast-result-actions">
            <button class="podcast-add-btn ${isSubscribed ? 'added' : ''}" data-index="${index}" ${isSubscribed ? 'disabled' : ''}>
              <i class="ph ph-${isSubscribed ? 'check' : 'plus'}"></i>
              ${isSubscribed ? 'Added' : 'Add'}
            </button>
          </div>
        </div>
      `;
    }).join('');
  };

  const searchPodcasts = async (query) => {
    if (!query.trim()) return;

    el.podcastSearchBtn.disabled = true;
    el.podcastSearchStatus.style.display = 'block';
    el.podcastSearchStatus.textContent = 'Searching...';
    el.podcastSearchResults.innerHTML = `
      <div class="podcast-search-loading">
        <i class="ph ph-spinner"></i>
        <p>Searching for podcasts...</p>
      </div>`;

    try {
      const result = await PodcastIndex.searchByTerm(query);
      podcastSearchResults = result.feeds || [];

      el.podcastSearchStatus.textContent = `Found ${podcastSearchResults.length} podcast${podcastSearchResults.length === 1 ? '' : 's'}`;
      renderPodcastSearchResults(podcastSearchResults);
    } catch (error) {
      console.error('[PodcastSearch] Error:', error);
      el.podcastSearchStatus.textContent = 'Search failed. Please try again.';
      el.podcastSearchResults.innerHTML = `
        <div class="podcast-search-empty">
          <i class="ph ph-warning-circle"></i>
          <p>Failed to search. Please check your connection and try again.</p>
        </div>`;
    } finally {
      el.podcastSearchBtn.disabled = false;
    }
  };

  const addPodcastFromSearch = async (index) => {
    const podcast = podcastSearchResults[index];
    if (!podcast) return;

    const feedUrl = podcast.url || podcast.originalUrl;
    if (!feedUrl) {
      toast('No feed URL available');
      return;
    }

    // Check if already subscribed
    const existingFeed = state.feeds.find(f =>
      f.url.toLowerCase() === feedUrl.toLowerCase()
    );
    if (existingFeed) {
      toast('Already subscribed to this podcast');
      return;
    }

    // Update button state immediately
    const btn = el.podcastSearchResults.querySelector(`button[data-index="${index}"]`);
    if (btn) {
      btn.disabled = true;
      btn.innerHTML = '<i class="ph ph-spinner"></i> Adding...';
    }

    try {
      // Add the feed using existing addFeed function
      await addFeed(
        feedUrl,
        podcast.title,
        'podcast',
        podcast.categories?.[0]?.name || 'Podcasts',
        podcast.author || podcast.ownerName || ''
      );

      // Update button to show success
      if (btn) {
        btn.classList.add('added');
        btn.innerHTML = '<i class="ph ph-check"></i> Added';
      }
    } catch (error) {
      console.error('[PodcastSearch] Failed to add podcast:', error);
      toast('Failed to add podcast');
      if (btn) {
        btn.disabled = false;
        btn.innerHTML = '<i class="ph ph-plus"></i> Add';
      }
    }
  };

  const openPodcastSearch = () => {
    el.podcastSearchModal.classList.add('active');
    el.podcastSearchInput.focus();
  };

  const closePodcastSearch = () => {
    el.podcastSearchModal.classList.remove('active');
  };

  // Podcast search modal event handlers
  el.podcastSearchClose.onclick = closePodcastSearch;
  el.podcastSearchModal.onclick = e => { if (e.target === el.podcastSearchModal) closePodcastSearch(); };

  el.podcastSearchBtn.onclick = () => searchPodcasts(el.podcastSearchInput.value);
  el.podcastSearchInput.onkeydown = e => {
    if (e.key === 'Enter') {
      e.preventDefault();
      searchPodcasts(el.podcastSearchInput.value);
    }
  };

  // Handle clicks on add buttons in search results
  el.podcastSearchResults.onclick = e => {
    const btn = e.target.closest('.podcast-add-btn');
    if (btn && !btn.disabled) {
      const index = parseInt(btn.dataset.index);
      addPodcastFromSearch(index);
    }
  };

  // Expose podcast search modal opener globally
  window.openPodcastSearch = openPodcastSearch;

  // Speed Panel
  el.pSpeed.onclick = (e) => { e.stopPropagation(); toggleSpeedPanel(); };
  el.speedSlider.oninput = () => setSpeed(parseFloat(el.speedSlider.value));
  el.speedPanel.onclick = e => {
    e.stopPropagation();
    const btn = e.target.closest('.speed-preset-btn');
    if (btn) setSpeed(parseFloat(btn.dataset.speed));
  };

  // Bookmarks Panel
  el.pBookmark.onclick = (e) => { e.stopPropagation(); toggleBookmarksPanel(); };
  el.addBookmarkBtn.onclick = (e) => { e.stopPropagation(); addBookmark(); };
  el.bookmarksList.onclick = e => {
    e.stopPropagation();
    const del = e.target.closest('.bookmark-delete');
    if (del) {
      const epId = state.currentEp?.id;
      const idx = parseInt(del.dataset.index);
      if (epId !== undefined) deleteBookmark(epId, idx);
      return;
    }
    const item = e.target.closest('.bookmark-item');
    if (item) {
      jumpToBookmark(parseFloat(item.dataset.time));
    }
  };

  // Queue Panel
  const toggleQueuePanel = () => {
    const wasOpen = state.queuePanelOpen;
    closeAllPanels();
    if (!wasOpen) {
      state.queuePanelOpen = true;
      el.queuePanel.classList.add('active');
      renderQueue();
    }
  };

  if (el.pQueue) {
    el.pQueue.onclick = (e) => { e.stopPropagation(); toggleQueuePanel(); };
  }
  if (el.queueClearBtn) {
    el.queueClearBtn.onclick = (e) => { e.stopPropagation(); clearQueue(); };
  }
  if (el.queueList) {
    el.queueList.onclick = e => {
      e.stopPropagation();
      const removeBtn = e.target.closest('.queue-item-remove');
      if (removeBtn) {
        const epId = removeBtn.dataset.epId;
        removeFromQueue(epId);
        return;
      }
      const item = e.target.closest('.queue-item');
      if (item) {
        const epId = item.dataset.epId;
        const ep = state.queue.find(e => e.id === epId);
        if (ep) {
          removeFromQueue(epId);
          playEpisode(ep);
          closeAllPanels();
        }
      }
    };
  }

  // ==========================================
  // MOBILE TOUCH ENHANCEMENTS
  // ==========================================

  /**
   * Enhanced Touch Feedback System
   * Provides visual feedback for all interactions
   */
  const TouchFeedback = {
    /**
     * Visual press feedback for elements
     * @param {HTMLElement} element - Element to apply feedback to
     */
    press(element) {
      if (!element) return;

      element.style.transform = 'scale(0.96)';
      element.style.opacity = '0.8';
      element.style.transition = 'transform 0.1s ease-out, opacity 0.1s ease-out';

      setTimeout(() => {
        element.style.transform = '';
        element.style.opacity = '';
      }, 100);
    },

    /**
     * Ripple effect on tap
     * @param {Event} e - Touch/click event
     */
    ripple(e) {
      const button = e.currentTarget;
      const ripple = document.createElement('span');
      const rect = button.getBoundingClientRect();
      const size = Math.max(rect.width, rect.height);
      const x = e.clientX - rect.left - size / 2;
      const y = e.clientY - rect.top - size / 2;

      ripple.style.cssText = `
        position: absolute;
        width: ${size}px;
        height: ${size}px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.3);
        left: ${x}px;
        top: ${y}px;
        transform: scale(0);
        pointer-events: none;
        animation: ripple 0.6s ease-out;
      `;

      button.style.position = 'relative';
      button.style.overflow = 'hidden';
      button.appendChild(ripple);

      setTimeout(() => ripple.remove(), 600);
    }
  };

  /**
   * Apply touch feedback to all interactive elements
   */
  const initTouchFeedback = () => {
    // Primary buttons get visual feedback
    const primaryButtons = document.querySelectorAll(`
      .toggle-btn,
      .ep-play,
      .player-play,
      .expanded-play,
      .show-play,
      .add-btn,
      .submit-btn
    `);

    primaryButtons.forEach(btn => {
      btn.addEventListener('touchstart', (e) => {
        TouchFeedback.press(e.currentTarget);
      }, { passive: true });

      btn.addEventListener('click', (e) => {
        TouchFeedback.ripple(e);
      });
    });

  };

  /**
   * Pull-to-Refresh Implementation
   */
  const PullToRefresh = {
    enabled: false,
    pulling: false,
    startY: 0,
    currentY: 0,
    threshold: 100,
    maxPull: 150,
    indicator: null,

    init() {
      // Only enable on mobile
      if (window.innerWidth > 640) return;

      this.enabled = true;
      this.createIndicator();
      this.attachListeners();
    },

    createIndicator() {
      this.indicator = document.createElement('div');
      this.indicator.className = 'pull-to-refresh-indicator';
      this.indicator.innerHTML = `
        <div class="pull-spinner">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0118.8-4.3M22 12.5a10 10 0 01-18.8 4.2"/>
          </svg>
        </div>
        <div class="pull-text">Pull to refresh</div>
      `;

      document.body.appendChild(this.indicator);
    },

    attachListeners() {
      let scrollable;

      document.addEventListener('touchstart', (e) => {
        // Only activate at top of scroll
        scrollable = e.target.closest('.news-list, .podcast-content, .all-content, .feed-scroll');
        if (!scrollable || scrollable.scrollTop > 5) return;

        this.startY = e.touches[0].clientY;
        this.pulling = false;
      }, { passive: true });

      document.addEventListener('touchmove', (e) => {
        if (!scrollable || scrollable.scrollTop > 5) return;

        this.currentY = e.touches[0].clientY;
        const pullDistance = this.currentY - this.startY;

        if (pullDistance > 0 && this.indicator) {
          const pull = Math.min(pullDistance * 0.5, this.maxPull);
          this.indicator.style.transform = `translateY(${pull}px)`;

          if (pull >= this.threshold && !this.pulling) {
            this.pulling = true;
            this.indicator.querySelector('.pull-spinner').classList.add('ready');
            this.indicator.querySelector('.pull-text').textContent = 'Release to refresh';
          } else if (pull < this.threshold && this.pulling) {
            this.pulling = false;
            this.indicator.querySelector('.pull-spinner').classList.remove('ready');
            this.indicator.querySelector('.pull-text').textContent = 'Pull to refresh';
          }
        }
      }, { passive: true });

      document.addEventListener('touchend', async () => {
        if (this.pulling && this.indicator) {
          this.indicator.querySelector('.pull-text').textContent = 'Refreshing...';

          // Perform refresh
          await refreshAllFeeds();

          // Reset
          setTimeout(() => {
            if (this.indicator) {
              this.indicator.style.transform = '';
              this.pulling = false;
              this.indicator.querySelector('.pull-spinner').classList.remove('ready');
              this.indicator.querySelector('.pull-text').textContent = 'Pull to refresh';
            }
          }, 300);
        } else if (this.indicator) {
          this.indicator.style.transform = '';
        }

        scrollable = null;
      }, { passive: true });
    }
  };

  /**
   * Bottom Sheet Panel Behavior
   * Makes speed panel and bookmarks panel slide up from bottom
   */
  const BottomSheet = {
    backdrop: null,

    init() {
      if (window.innerWidth > 640) return;

      // Add backdrop
      this.backdrop = document.createElement('div');
      this.backdrop.className = 'bottom-sheet-backdrop';
      document.body.appendChild(this.backdrop);

      // Override panel open/close
      const originalToggleSpeed = window.toggleSpeedPanel;
      if (originalToggleSpeed) {
        window.toggleSpeedPanel = () => {
          originalToggleSpeed();
          this.updateBackdrop(el.speedPanel?.classList.contains('active'));
        };
      }

      const originalToggleBookmarks = window.toggleBookmarksPanel;
      if (originalToggleBookmarks) {
        window.toggleBookmarksPanel = () => {
          originalToggleBookmarks();
          this.updateBackdrop(el.bookmarksPanel?.classList.contains('active'));
        };
      }

      // Close on swipe down
      [el.speedPanel, el.bookmarksPanel].forEach(panel => {
        if (!panel) return;

        let startY = 0;
        panel.addEventListener('touchstart', (e) => {
          if (panel.scrollTop === 0) {
            startY = e.touches[0].clientY;
          }
        }, { passive: true });

        panel.addEventListener('touchmove', (e) => {
          if (panel.scrollTop === 0) {
            const currentY = e.touches[0].clientY;
            const diff = currentY - startY;

            if (diff > 0) {
              panel.style.transform = `translateY(${diff}px)`;
            }
          }
        }, { passive: true });

        panel.addEventListener('touchend', (e) => {
          const currentY = e.changedTouches[0].clientY;
          const diff = currentY - startY;

          if (diff > 100) {
            closeAllPanels();
            this.updateBackdrop(false);
          }

          panel.style.transform = '';
        }, { passive: true });
      });
    },

    updateBackdrop(isOpen) {
      if (!this.backdrop) return;

      if (isOpen) {
        this.backdrop.style.opacity = '1';
        this.backdrop.style.pointerEvents = 'auto';
        this.backdrop.onclick = () => {
          closeAllPanels();
          this.updateBackdrop(false);
        };
      } else {
        this.backdrop.style.opacity = '0';
        this.backdrop.style.pointerEvents = 'none';
      }
    }
  };

  /**
   * Smart Scroll Behavior
   * Hide header on scroll down, show on scroll up
   */
  const SmartScroll = {
    lastScroll: 0,
    scrollThreshold: 10,

    init() {
      if (window.innerWidth > 640) return;

      let ticking = false;

      window.addEventListener('scroll', () => {
        if (!ticking) {
          window.requestAnimationFrame(() => {
            this.handleScroll();
            ticking = false;
          });
          ticking = true;
        }
      }, { passive: true });
    },

    handleScroll() {
      const currentScroll = window.pageYOffset;

      if (Math.abs(currentScroll - this.lastScroll) < this.scrollThreshold) {
        return;
      }

      const header = document.querySelector('.header');
      if (!header) return;

      if (currentScroll > this.lastScroll && currentScroll > 100) {
        // Scrolling down & past threshold
        header.style.transform = 'translateY(-100%)';
      } else {
        // Scrolling up or at top
        header.style.transform = 'translateY(0)';
      }

      this.lastScroll = currentScroll;
    }
  };

  /**
   * Viewport Height Fix for Mobile Browsers
   * Fixes vh units on mobile (address bar hiding)
   */
  const ViewportFix = {
    init() {
      const setVH = () => {
        const vh = window.innerHeight * 0.01;
        document.documentElement.style.setProperty('--vh', `${vh}px`);
      };

      setVH();
      window.addEventListener('resize', setVH);
      window.addEventListener('orientationchange', setVH);
    }
  };

  /**
   * Prevent Overscroll Bounce (iOS)
   */
  const PreventOverscroll = {
    init() {
      document.body.style.overscrollBehavior = 'none';

      // Allow scrolling only within designated scroll containers
      const scrollContainers = document.querySelectorAll(`
        .news-list,
        .podcast-content,
        .all-content,
        .speed-panel,
        .bookmarks-panel,
        .drawer-content,
        .feed-scroll
      `);

      scrollContainers.forEach(container => {
        container.style.overscrollBehavior = 'contain';
      });
    }
  };

  /**
   * iOS Input Focus Fix
   * Prevents page zoom on input focus
   */
  const IOSInputFix = {
    init() {
      const inputs = document.querySelectorAll('input, textarea');

      inputs.forEach(input => {
        // Ensure font-size is at least 16px to prevent zoom
        const fontSize = window.getComputedStyle(input).fontSize;
        if (parseInt(fontSize) < 16) {
          input.style.fontSize = '16px';
        }

        // Scroll into view on focus
        input.addEventListener('focus', (e) => {
          setTimeout(() => {
            e.target.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }, 300);
        });
      });
    }
  };

  /**
   * Enhanced Loading States
   */
  const LoadingStates = {
    createSkeleton(type) {
      const skeletons = {
        article: `
          <div class="article skeleton-wrapper" style="pointer-events:none">
            <div class="skeleton" style="width:48px;height:48px;border-radius:12px"></div>
            <div style="flex:1">
              <div class="skeleton" style="width:60%;height:14px;margin-bottom:8px"></div>
              <div class="skeleton" style="width:100%;height:18px;margin-bottom:6px"></div>
              <div class="skeleton" style="width:90%;height:14px"></div>
            </div>
          </div>
        `,
        episode: `
          <div class="episode skeleton-wrapper" style="pointer-events:none">
            <div class="skeleton" style="width:64px;height:64px;border-radius:12px"></div>
            <div style="flex:1">
              <div class="skeleton" style="width:40%;height:13px;margin-bottom:6px"></div>
              <div class="skeleton" style="width:80%;height:15px;margin-bottom:8px"></div>
              <div class="skeleton" style="width:100%;height:8px;border-radius:4px"></div>
            </div>
          </div>
        `,
        card: `
          <div class="article-card skeleton-wrapper" style="pointer-events:none">
            <div class="skeleton" style="width:100%;height:200px;border-radius:16px 16px 0 0"></div>
            <div style="padding:18px">
              <div class="skeleton" style="width:60%;height:13px;margin-bottom:10px"></div>
              <div class="skeleton" style="width:100%;height:16px;margin-bottom:6px"></div>
              <div class="skeleton" style="width:90%;height:14px"></div>
            </div>
          </div>
        `
      };

      return skeletons[type] || skeletons.article;
    },

    show(container, type, count = 5) {
      if (container) {
        container.innerHTML = Array(count).fill(this.createSkeleton(type)).join('');
      }
    }
  };

  /**
   * Initialize all mobile enhancements
   * Call this in the main init() function
   */
  const initMobileEnhancements = () => {
    // Always use mobile mode - desktop version hidden for now
    const isMobile = true;

    console.log('ðŸ“± Initializing mobile enhancements (forced mobile mode)...');

    ViewportFix.init();
    initTouchFeedback();
    PullToRefresh.init();
    BottomSheet.init();
    SmartScroll.init();
    PreventOverscroll.init();
    IOSInputFix.init();

    console.log('âœ… Mobile enhancements initialized');
  };

  // === INIT ===
  const init = async () => {
    const initStart = performance.now();
    console.log('[Performance] Init started...');

    // Initialize content cache FIRST for fast loading
    try {
      await ContentCache.init();
      console.log('[Cache] Content cache initialized');
      // Cleanup old cache entries in background
      setTimeout(() => ContentCache.cleanup(), 5000);
    } catch (e) {
      console.warn('[Cache] Failed to initialize content cache:', e);
    }

    // Initialize image loader for lazy loading
    ImageLoader.init();
    console.log('[Performance] Image lazy loading enabled');

    // Await load to ensure server state is fetched first for cross-device consistency
    await load();

    // Initialize download database
    try {
      await DownloadDB.init();
      console.log('Download database initialized');

      // Sync download state with actual IndexedDB content
      const downloadedIds = await DownloadDB.getAll();
      const downloadedSet = new Set(downloadedIds);

      // Update podcast downloaded flags based on what's actually in IndexedDB
      let syncNeeded = false;
      state.podcasts.forEach(p => {
        const actuallyDownloaded = downloadedSet.has(p.id);
        if (p.downloaded !== actuallyDownloaded) {
          p.downloaded = actuallyDownloaded;
          syncNeeded = true;
        }
      });
      if (syncNeeded) save();
    } catch (e) {
      console.error('Failed to initialize download database:', e);
    }

    // Initialize snapshot database for state history/restoration
    try {
      await SnapshotDB.init();
      console.log('Snapshot database initialized');
    } catch (e) {
      console.error('Failed to initialize snapshot database:', e);
    }

    // Apply saved view state
    const applyView = () => {
      // Update view visibility
      el.newsView.classList.toggle('active', state.view === 'news');
      el.podcastView.classList.toggle('active', state.view === 'podcasts');
      el.allView.classList.toggle('active', state.view === 'all');
      // Update mobile tab bar
      if (typeof updateMobileTabBar === 'function') updateMobileTabBar();
    };

    applyView();

    // Show loading skeletons while rendering (mobile only)
    if (window.innerWidth <= 640) {
      if (state.view === 'news') {
        LoadingStates.show(el.newsList, 'article', 5);
      } else if (state.view === 'podcasts') {
        LoadingStates.show(el.podcastInboxList, 'episode', 5);
      }
    }

    renderNewsSources();
    renderCategories();
    renderTagFilters();
    renderNews();
    if (state.view === 'podcasts') renderPodcasts();
    if (state.view === 'all') renderAll();

    // Initialize mobile enhancements AFTER initial render
    initMobileEnhancements();

    // Initialize activity tracking (syncs to Xano)
    Mem.init();

    // Initialize feeding activity sync to activity-post endpoint
    FeedingActivity.init();

    // Start feed scanner to detect new feeds from other devices
    FeedScanner.start();

    // Sync state to server when page is hidden or closed (cross-device consistency)
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden') {
        StateSync.flushSync();
      }
    });
    window.addEventListener('beforeunload', () => {
      StateSync.flushSync();
    });

    console.log('BRSST loaded');
    console.log('[StateSync] Cross-device sync enabled:', StateSync.endpoint);
    console.log('[FeedScanner] Scanning for new feeds every', FeedScanner.scanInterval / 1000, 'seconds');
    console.log('[Mobile] Mobile optimizations active:', window.innerWidth <= 640);
    console.log('[Activity] Syncing to Xano:', Mem.endpoint);
    console.log('[FeedingActivity] Syncing feeding actions to:', FeedingActivity.endpoint);
    console.log('[API] User Behavior API:');
    console.log('  Memory.getLocal() - Get all local behavior logs');
    console.log('  Memory.getStats() - Get aggregated behavior statistics');
    console.log('  Memory.exportForSync() - Export all data for API sync');
    console.log('  Memory.clear() - Clear local behavior logs');
    console.log('[Tags] Content Tags:', Object.keys(CONTENT_TAGS).length, 'categories available for auto-tagging');
    console.log('[Archive] Archived:', state.archivedArticles.length, 'articles,', state.archivedPodcasts.length, 'episodes preserved');

    // Performance logging
    const initDuration = performance.now() - initStart;
    console.log(`[Performance] Init completed in ${initDuration.toFixed(0)}ms`);
    console.log('[Cache] Content caching:', ContentCache.db ? 'enabled' : 'disabled');

    // Auto-refresh feeds on startup if we have feeds but limited cached content
    const podcastFeeds = state.feeds.filter(f => f.type === 'podcast');
    const newsFeeds = state.feeds.filter(f => f.type !== 'podcast');
    const hasPodcastFeeds = podcastFeeds.length > 0;
    const hasNewsFeeds = newsFeeds.length > 0;
    const hasCachedPodcasts = state.podcasts.length > 0;
    const hasCachedArticles = state.articles.length > 0;

    // Show loading state if we have feeds but no cached content
    if (hasPodcastFeeds && !hasCachedPodcasts && state.view === 'podcasts') {
      LoadingStates.show(el.podcastInboxList, 'episode', 6);
    }
    if (hasNewsFeeds && !hasCachedArticles && state.view === 'news') {
      LoadingStates.show(el.newsList, 'article', 6);
    }

    // Preload images for visible content in background
    setTimeout(() => {
      ContentPreloader.preloadVisibleImages();
      // Setup lazy loading for all images currently in DOM
      document.querySelectorAll('img[data-src]:not(.loaded)').forEach(img => ImageLoader.loadImage(img, img.dataset.src));
    }, 1000);

    // Auto-refresh if we have feeds - fetch new content in background
    if (state.feeds.length > 0) {
      console.log('[Init] Auto-refreshing', state.feeds.length, 'feeds...');
      refreshAllFeeds(true).catch(e => console.error('[Init] Background refresh failed:', e));
    }

    // Register Service Worker for offline support
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('sw.js').then(reg => {
        console.log('[SW] Service Worker registered:', reg.scope);
      }).catch(e => {
        console.log('[SW] Service Worker registration skipped:', e.message);
      });
    }
  };

  init();
})();
</script>
</body>
</html>
