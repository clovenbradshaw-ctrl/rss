<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Feedr</title>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    :root {
      --bg: #0a0a0a; --bg2: #111; --bg3: #1a1a1a; --bg4: #1f1f1f;
      --border: #1f1f1f; --border2: #333;
      --text: #e5e5e5; --text2: #a0a0a0; --text3: #666;
      --green: #1db954; --green2: #1ed760;
    }
    html, body { height: 100%; }
    body { font-family: 'IBM Plex Sans', system-ui, sans-serif; background: var(--bg); color: var(--text); overflow: hidden; }
    ::-webkit-scrollbar { width: 8px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: var(--border2); border-radius: 4px; }
    
    .app { display: flex; flex-direction: column; height: 100vh; }
    
    /* Header */
    .header { background: var(--bg); border-bottom: 1px solid var(--border); padding: 12px 16px; display: flex; align-items: center; gap: 16px; }
    .logo { font-size: 22px; font-weight: 700; }
    .main-toggle { display: flex; background: var(--bg3); border-radius: 25px; padding: 4px; }
    .toggle-btn { padding: 10px 20px; background: transparent; border: none; border-radius: 21px; color: var(--text2); font-size: 14px; font-weight: 600; cursor: pointer; font-family: inherit; display: flex; align-items: center; gap: 8px; transition: all 0.2s; }
    .toggle-btn.active { background: var(--green); color: #000; }
    .toggle-btn:not(.active):hover { background: var(--bg4); color: var(--text); }
    .spacer { flex: 1; }
    .search-box { max-width: 280px; flex: 1; position: relative; }
    .search-box input { width: 100%; padding: 10px 16px 10px 38px; background: var(--bg3); border: 1px solid var(--border2); border-radius: 20px; color: var(--text); font-size: 14px; font-family: inherit; }
    .search-box input:focus { outline: none; border-color: var(--green); }
    .search-box input::placeholder { color: var(--text3); }
    .search-box svg { position: absolute; left: 12px; top: 50%; transform: translateY(-50%); color: var(--text3); }
    .icon-btn { background: none; border: none; color: var(--text2); cursor: pointer; padding: 10px; border-radius: 50%; transition: all 0.2s; display: flex; align-items: center; justify-content: center; }
    .icon-btn:hover { background: var(--bg4); color: var(--text); }
    
    /* Main */
    .main { flex: 1; overflow: hidden; }
    
    /* === NEWS VIEW === */
    .news-view { display: none; height: 100%; }
    .news-view.active { display: flex; }
    
    .news-sidebar { width: 240px; background: var(--bg2); border-right: 1px solid var(--border); display: flex; flex-direction: column; }
    .sidebar-header { padding: 14px 16px; border-bottom: 1px solid var(--border); display: flex; align-items: center; justify-content: space-between; }
    .sidebar-header h2 { font-size: 12px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text2); }
    .add-btn { background: var(--green); border: none; color: #000; width: 24px; height: 24px; border-radius: 50%; cursor: pointer; font-size: 16px; }
    .sidebar-content { flex: 1; overflow-y: auto; padding: 8px; }
    
    .source-item { display: flex; align-items: center; gap: 10px; padding: 10px; border-radius: 8px; cursor: pointer; margin-bottom: 2px; transition: background 0.15s; }
    .source-item:hover { background: var(--bg3); }
    .source-item:hover .source-name { color: var(--green); }
    .source-item.active { background: var(--bg4); }
    .source-icon { width: 32px; height: 32px; border-radius: 6px; background: var(--bg3); display: flex; align-items: center; justify-content: center; font-size: 16px; overflow: hidden; flex-shrink: 0; }
    .source-icon img { width: 100%; height: 100%; object-fit: cover; }
    .source-name { flex: 1; font-size: 14px; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; transition: color 0.15s; }
    .source-badge { background: var(--green); color: #000; font-size: 10px; font-weight: 700; padding: 2px 6px; border-radius: 10px; flex-shrink: 0; }
    .source-arrow { color: var(--text3); opacity: 0; transition: opacity 0.15s; }
    .source-item:hover .source-arrow { opacity: 1; }
    
    .news-content { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
    .news-list-view { display: flex; flex-direction: column; gap: 8px; }
    .news-header { padding: 12px 16px; border-bottom: 1px solid var(--border); display: flex; align-items: center; gap: 12px; }
    .news-title { font-size: 18px; font-weight: 600; margin-right: 16px; }
    .category-chips { display: flex; gap: 8px; overflow-x: auto; flex: 1; }
    .chip { padding: 6px 14px; background: var(--bg3); border: 1px solid var(--border2); border-radius: 16px; color: var(--text2); font-size: 12px; font-weight: 500; cursor: pointer; white-space: nowrap; font-family: inherit; transition: all 0.15s; }
    .chip:hover { background: var(--bg4); color: var(--text); }
    .chip.active { background: var(--green); border-color: var(--green); color: #000; }
    
    .news-list { flex: 1; overflow-y: auto; padding: 12px 16px 100px; }
    .article { display: flex; gap: 14px; padding: 14px; background: var(--bg2); border-radius: 10px; margin-bottom: 8px; cursor: pointer; border: 1px solid transparent; transition: all 0.15s; }
    .article:hover { background: var(--bg3); border-color: var(--border2); }
    .article.unread { border-left: 3px solid var(--green); }
    .article-icon { width: 40px; height: 40px; border-radius: 8px; background: var(--bg3); display: flex; align-items: center; justify-content: center; font-size: 20px; overflow: hidden; flex-shrink: 0; }
    .article-icon img { width: 100%; height: 100%; object-fit: cover; }
    .article-body { flex: 1; min-width: 0; }
    .article-meta { display: flex; align-items: center; gap: 8px; margin-bottom: 4px; font-size: 12px; }
    .article-source { color: var(--green); font-weight: 500; cursor: pointer; }
    .article-source:hover { text-decoration: underline; }
    .article-time { color: var(--text3); }
    .article-new { color: var(--green); font-weight: 600; font-size: 10px; }
    .article-title { font-size: 15px; font-weight: 500; line-height: 1.4; margin-bottom: 4px; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
    .article-summary { font-size: 13px; color: var(--text2); line-height: 1.4; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
    .article-image { width: 100px; height: 70px; border-radius: 6px; object-fit: cover; flex-shrink: 0; }
    
    /* === PODCAST VIEW === */
    .podcast-view { display: none; height: 100%; flex-direction: column; }
    .podcast-view.active { display: flex; }

    /* === ALL VIEW === */
    .all-view { display: none; height: 100%; flex-direction: column; }
    .all-view.active { display: flex; }
    .all-content { flex: 1; overflow-y: auto; padding: 20px; padding-bottom: 120px; }
    .all-section { margin-bottom: 28px; }
    .all-section-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 14px; }
    .all-section-title { font-size: 18px; font-weight: 600; display: flex; align-items: center; gap: 8px; }
    .all-feed-list { display: flex; flex-direction: column; gap: 8px; }
    .all-item { display: flex; gap: 12px; padding: 12px; background: var(--bg2); border-radius: 10px; cursor: pointer; transition: background 0.15s; }
    .all-item:hover { background: var(--bg3); }
    .all-item-icon { width: 50px; height: 50px; border-radius: 6px; object-fit: cover; flex-shrink: 0; display: flex; align-items: center; justify-content: center; font-size: 24px; background: var(--bg3); }
    .all-item-icon img { width: 100%; height: 100%; object-fit: cover; border-radius: 6px; }
    .all-item-body { flex: 1; min-width: 0; display: flex; flex-direction: column; justify-content: center; }
    .all-item-meta { font-size: 12px; color: var(--green); font-weight: 500; margin-bottom: 2px; display: flex; align-items: center; gap: 6px; }
    .all-item-type { background: var(--bg4); color: var(--text2); padding: 2px 6px; border-radius: 4px; font-size: 10px; text-transform: uppercase; }
    .all-item-title { font-size: 14px; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .all-item-summary { font-size: 12px; color: var(--text3); margin-top: 4px; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
    .all-item-time { font-size: 11px; color: var(--text3); }

    /* All Content View Modes */
    .all-cards { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 16px; }
    .all-card { background: var(--bg2); border-radius: 12px; overflow: hidden; cursor: pointer; border: 1px solid transparent; transition: all 0.15s; display: flex; flex-direction: column; }
    .all-card:hover { background: var(--bg3); border-color: var(--border2); transform: translateY(-2px); }
    .all-card-image { width: 100%; height: 160px; object-fit: cover; background: var(--bg3); display: flex; align-items: center; justify-content: center; font-size: 48px; }
    .all-card-image img { width: 100%; height: 100%; object-fit: cover; }
    .all-card-body { padding: 14px; flex: 1; display: flex; flex-direction: column; }
    .all-card-meta { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; font-size: 12px; }
    .all-card-type { background: var(--bg4); color: var(--text2); padding: 2px 6px; border-radius: 4px; font-size: 10px; text-transform: uppercase; }
    .all-card-source { color: var(--green); font-weight: 500; }
    .all-card-time { color: var(--text3); }
    .all-card-title { font-size: 15px; font-weight: 600; line-height: 1.4; margin-bottom: 8px; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
    .all-card-summary { font-size: 13px; color: var(--text2); line-height: 1.4; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden; flex: 1; }

    .all-masonry { column-count: 3; column-gap: 16px; }
    .all-masonry-item { break-inside: avoid; margin-bottom: 16px; background: var(--bg2); border-radius: 12px; overflow: hidden; cursor: pointer; border: 1px solid transparent; transition: all 0.15s; }
    .all-masonry-item:hover { background: var(--bg3); border-color: var(--border2); }
    .all-masonry-image { width: 100%; object-fit: cover; }
    .all-masonry-body { padding: 14px; }
    .all-masonry-meta { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; font-size: 12px; }
    .all-masonry-type { background: var(--bg4); color: var(--text2); padding: 2px 6px; border-radius: 4px; font-size: 10px; text-transform: uppercase; }
    .all-masonry-source { color: var(--green); font-weight: 500; }
    .all-masonry-time { color: var(--text3); }
    .all-masonry-title { font-size: 15px; font-weight: 600; line-height: 1.4; margin-bottom: 8px; }
    .all-masonry-summary { font-size: 13px; color: var(--text2); line-height: 1.5; }

    .all-table { width: 100%; border-collapse: collapse; }
    .all-table th { text-align: left; padding: 12px; font-size: 12px; font-weight: 600; color: var(--text3); text-transform: uppercase; letter-spacing: 0.5px; border-bottom: 1px solid var(--border); }
    .all-table td { padding: 12px; border-bottom: 1px solid var(--border); vertical-align: middle; }
    .all-table tr { cursor: pointer; transition: background 0.15s; }
    .all-table tbody tr:hover { background: var(--bg3); }
    .all-table .table-title { font-weight: 500; max-width: 400px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .all-table .table-type { font-size: 10px; text-transform: uppercase; padding: 2px 6px; border-radius: 4px; background: var(--bg4); color: var(--text2); }
    .all-table .table-source { color: var(--green); font-weight: 500; font-size: 13px; }
    .all-table .table-time { color: var(--text3); font-size: 13px; white-space: nowrap; }

    @media (max-width: 1024px) {
      .all-masonry { column-count: 2; }
    }
    @media (max-width: 640px) {
      .all-masonry { column-count: 1; }
      .all-cards { grid-template-columns: 1fr; }
    }

    .podcast-nav { display: flex; background: var(--bg2); border-bottom: 1px solid var(--border); padding: 0 16px; }
    .nav-btn { padding: 14px 18px; background: none; border: none; border-bottom: 2px solid transparent; color: var(--text2); font-size: 14px; font-weight: 500; cursor: pointer; font-family: inherit; transition: all 0.15s; }
    .nav-btn:hover { color: var(--text); }
    .nav-btn.active { color: var(--green); border-bottom-color: var(--green); }
    
    .podcast-content { flex: 1; overflow-y: auto; padding: 20px; padding-bottom: 120px; }
    
    .section { margin-bottom: 28px; }
    .section-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 14px; }
    .section-title { font-size: 18px; font-weight: 600; }
    
    .shows-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(130px, 1fr)); gap: 16px; }
    .show-card { cursor: pointer; transition: transform 0.15s; }
    .show-card:hover { transform: translateY(-4px); }
    .show-art { width: 100%; aspect-ratio: 1; border-radius: 8px; object-fit: cover; margin-bottom: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
    .show-name { font-size: 14px; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .show-author { font-size: 12px; color: var(--text3); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    
    .episode-list { display: flex; flex-direction: column; gap: 8px; }
    .episode { display: flex; gap: 12px; padding: 12px; background: var(--bg2); border-radius: 10px; cursor: pointer; transition: background 0.15s; }
    .episode:hover { background: var(--bg3); }
    .episode-art { width: 64px; height: 64px; border-radius: 6px; object-fit: cover; flex-shrink: 0; }
    .episode-body { flex: 1; min-width: 0; display: flex; flex-direction: column; justify-content: center; }
    .episode-show { font-size: 12px; color: var(--green); font-weight: 500; margin-bottom: 2px; cursor: pointer; }
    .episode-show:hover { text-decoration: underline; }
    .episode-title { font-size: 14px; font-weight: 500; margin-bottom: 6px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .episode-footer { display: flex; align-items: center; gap: 10px; }
    .ep-play { width: 28px; height: 28px; border-radius: 50%; background: var(--text); border: none; color: var(--bg); cursor: pointer; display: flex; align-items: center; justify-content: center; flex-shrink: 0; }
    .ep-play:hover { background: var(--green); }
    .ep-progress { flex: 1; display: flex; align-items: center; gap: 8px; }
    .ep-bar { flex: 1; height: 4px; background: var(--border2); border-radius: 2px; overflow: hidden; }
    .ep-fill { height: 100%; background: var(--green); }
    .ep-time { font-size: 11px; color: var(--text3); white-space: nowrap; }
    .ep-dl { background: none; border: none; color: var(--text3); cursor: pointer; padding: 4px; min-width: 24px; display: flex; align-items: center; justify-content: center; }
    .ep-dl:hover { color: var(--text); }
    .ep-dl.active { color: var(--green); }
    .ep-dl.downloading { color: var(--green); cursor: wait; animation: pulse 1.5s ease-in-out infinite; }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    
    /* Show Page & Source Page */
    .show-page, .source-page { display: none; overflow-y: auto; height: 100%; }
    .show-page.active, .source-page.active { display: block; }
    .show-hero, .source-hero { padding: 28px; background: linear-gradient(180deg, #1a1a3a 0%, var(--bg) 100%); display: flex; gap: 24px; align-items: flex-end; }
    .show-hero-art, .source-hero-art { width: 180px; height: 180px; border-radius: 10px; object-fit: cover; box-shadow: 0 8px 24px rgba(0,0,0,0.4); }
    .show-hero-info, .source-hero-info { flex: 1; }
    .show-hero-type, .source-hero-type { font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 1px; color: var(--text2); margin-bottom: 6px; }
    .show-hero-title, .source-hero-title { font-size: 36px; font-weight: 700; line-height: 1.1; margin-bottom: 10px; }
    .show-hero-author, .source-hero-author { font-size: 14px; color: var(--text2); }
    .show-actions, .source-actions { padding: 16px 28px; display: flex; gap: 12px; align-items: center; }
    .show-play { width: 48px; height: 48px; border-radius: 50%; background: var(--green); border: none; color: #000; cursor: pointer; display: flex; align-items: center; justify-content: center; }
    .show-play:hover { transform: scale(1.05); }
    .show-episodes, .source-articles { padding: 0 28px 120px; }
    .show-episodes-title, .source-articles-title { font-size: 18px; font-weight: 600; margin-bottom: 14px; }

    /* Back Button */
    .back-btn { background: none; border: none; color: var(--text2); cursor: pointer; padding: 8px 12px; border-radius: 8px; display: flex; align-items: center; gap: 6px; font-size: 14px; font-weight: 500; font-family: inherit; transition: all 0.15s; }
    .back-btn:hover { background: var(--bg3); color: var(--text); }

    /* View Options */
    .view-options { display: flex; gap: 4px; margin-left: auto; }
    .view-btn { background: var(--bg3); border: 1px solid var(--border2); color: var(--text2); cursor: pointer; padding: 8px 12px; border-radius: 6px; font-size: 12px; font-weight: 500; font-family: inherit; transition: all 0.15s; display: flex; align-items: center; gap: 4px; }
    .view-btn:hover { background: var(--bg4); color: var(--text); }
    .view-btn.active { background: var(--green); border-color: var(--green); color: #000; }

    /* Cards View */
    .articles-cards { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 16px; }
    .article-card { background: var(--bg2); border-radius: 12px; overflow: hidden; cursor: pointer; border: 1px solid transparent; transition: all 0.15s; display: flex; flex-direction: column; }
    .article-card:hover { background: var(--bg3); border-color: var(--border2); transform: translateY(-2px); }
    .article-card.unread { border-left: 3px solid var(--green); }
    .article-card-image { width: 100%; height: 160px; object-fit: cover; background: var(--bg3); }
    .article-card-body { padding: 14px; flex: 1; display: flex; flex-direction: column; }
    .article-card-meta { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; font-size: 12px; }
    .article-card-source { color: var(--green); font-weight: 500; }
    .article-card-time { color: var(--text3); }
    .article-card-title { font-size: 15px; font-weight: 600; line-height: 1.4; margin-bottom: 8px; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
    .article-card-summary { font-size: 13px; color: var(--text2); line-height: 1.4; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden; flex: 1; }

    /* Masonry View */
    .articles-masonry { column-count: 3; column-gap: 16px; }
    .article-masonry { break-inside: avoid; margin-bottom: 16px; background: var(--bg2); border-radius: 12px; overflow: hidden; cursor: pointer; border: 1px solid transparent; transition: all 0.15s; }
    .article-masonry:hover { background: var(--bg3); border-color: var(--border2); }
    .article-masonry.unread { border-left: 3px solid var(--green); }
    .article-masonry-image { width: 100%; object-fit: cover; }
    .article-masonry-body { padding: 14px; }
    .article-masonry-meta { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; font-size: 12px; }
    .article-masonry-source { color: var(--green); font-weight: 500; }
    .article-masonry-time { color: var(--text3); }
    .article-masonry-title { font-size: 15px; font-weight: 600; line-height: 1.4; margin-bottom: 8px; }
    .article-masonry-summary { font-size: 13px; color: var(--text2); line-height: 1.5; }

    /* Table View */
    .articles-table { width: 100%; border-collapse: collapse; }
    .articles-table th { text-align: left; padding: 12px; font-size: 12px; font-weight: 600; color: var(--text3); text-transform: uppercase; letter-spacing: 0.5px; border-bottom: 1px solid var(--border); }
    .articles-table td { padding: 12px; border-bottom: 1px solid var(--border); vertical-align: middle; }
    .articles-table tr { cursor: pointer; transition: background 0.15s; }
    .articles-table tbody tr:hover { background: var(--bg3); }
    .articles-table .table-title { font-weight: 500; max-width: 400px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .articles-table .table-source { color: var(--green); font-weight: 500; font-size: 13px; }
    .articles-table .table-time { color: var(--text3); font-size: 13px; white-space: nowrap; }
    .articles-table .table-new { color: var(--green); font-size: 10px; font-weight: 600; }
    .articles-table tr.unread .table-title { color: var(--text); }
    .articles-table tr:not(.unread) .table-title { color: var(--text2); }

    /* Episode Views */
    .episodes-cards { display: grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); gap: 16px; }
    .episode-card { background: var(--bg2); border-radius: 12px; overflow: hidden; cursor: pointer; transition: all 0.15s; }
    .episode-card:hover { background: var(--bg3); transform: translateY(-2px); }
    .episode-card-art { width: 100%; aspect-ratio: 1; object-fit: cover; }
    .episode-card-body { padding: 14px; }
    .episode-card-title { font-size: 14px; font-weight: 600; margin-bottom: 6px; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
    .episode-card-meta { display: flex; align-items: center; gap: 8px; font-size: 12px; color: var(--text3); }

    .episodes-masonry { column-count: 3; column-gap: 16px; }
    .episode-masonry { break-inside: avoid; margin-bottom: 16px; background: var(--bg2); border-radius: 12px; overflow: hidden; cursor: pointer; transition: all 0.15s; }
    .episode-masonry:hover { background: var(--bg3); }
    .episode-masonry-art { width: 100%; object-fit: cover; }
    .episode-masonry-body { padding: 14px; }
    .episode-masonry-title { font-size: 14px; font-weight: 600; margin-bottom: 6px; }
    .episode-masonry-desc { font-size: 12px; color: var(--text2); line-height: 1.5; margin-bottom: 8px; }
    .episode-masonry-meta { font-size: 11px; color: var(--text3); }

    .episodes-table { width: 100%; border-collapse: collapse; }
    .episodes-table th { text-align: left; padding: 12px; font-size: 12px; font-weight: 600; color: var(--text3); text-transform: uppercase; letter-spacing: 0.5px; border-bottom: 1px solid var(--border); }
    .episodes-table td { padding: 12px; border-bottom: 1px solid var(--border); vertical-align: middle; }
    .episodes-table tr { cursor: pointer; transition: background 0.15s; }
    .episodes-table tbody tr:hover { background: var(--bg3); }
    .episodes-table .table-title { font-weight: 500; }
    .episodes-table .table-duration { color: var(--text3); font-size: 13px; font-family: monospace; }
    .episodes-table .table-date { color: var(--text3); font-size: 13px; }
    .episodes-table .table-play { width: 32px; }
    .episodes-table .table-play-btn { width: 28px; height: 28px; border-radius: 50%; background: var(--text); border: none; color: var(--bg); cursor: pointer; display: flex; align-items: center; justify-content: center; }
    .episodes-table .table-play-btn:hover { background: var(--green); }

    @media (max-width: 1024px) {
      .articles-masonry, .episodes-masonry { column-count: 2; }
    }
    @media (max-width: 640px) {
      .articles-masonry, .episodes-masonry { column-count: 1; }
      .articles-cards, .episodes-cards { grid-template-columns: 1fr; }
    }
    
    /* === PLAYER === */
    .player { position: fixed; bottom: 0; left: 0; right: 0; height: 76px; background: var(--bg2); border-top: 1px solid var(--border); display: none; align-items: center; padding: 0 16px; z-index: 100; }
    .player.active { display: flex; }
    .player-left { display: flex; align-items: center; gap: 12px; width: 25%; min-width: 160px; }
    .player-art { width: 52px; height: 52px; border-radius: 6px; object-fit: cover; cursor: pointer; }
    .player-info { min-width: 0; }
    .player-title { font-size: 14px; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .player-show { font-size: 12px; color: var(--text2); cursor: pointer; }
    .player-show:hover { color: var(--green); text-decoration: underline; }
    .player-center { flex: 1; display: flex; flex-direction: column; align-items: center; max-width: 600px; padding: 0 20px; }
    .player-controls { display: flex; align-items: center; gap: 16px; margin-bottom: 4px; }
    .player-skip { background: none; border: none; color: var(--text); cursor: pointer; font-size: 12px; font-weight: 600; padding: 6px; font-family: inherit; }
    .player-skip:hover { color: var(--green); }
    .player-play { width: 36px; height: 36px; border-radius: 50%; background: var(--text); border: none; color: var(--bg); cursor: pointer; display: flex; align-items: center; justify-content: center; }
    .player-play:hover { background: var(--green); }
    .player-progress { width: 100%; display: flex; align-items: center; gap: 8px; }
    .player-time { font-size: 11px; color: var(--text3); font-family: monospace; min-width: 40px; }
    .player-time.right { text-align: right; }
    .player-bar { flex: 1; height: 4px; background: var(--border2); border-radius: 2px; cursor: pointer; }
    .player-bar:hover { height: 6px; }
    .player-fill { height: 100%; background: var(--text); border-radius: 2px; }
    .player-bar:hover .player-fill { background: var(--green); }
    .player-right { display: flex; align-items: center; gap: 10px; width: 25%; justify-content: flex-end; }
    .speed-btn { font-size: 12px; font-weight: 600; padding: 5px 8px; background: var(--bg3); border: 1px solid var(--border2); border-radius: 4px; color: var(--text2); cursor: pointer; font-family: inherit; }
    .speed-btn:hover { color: var(--text); border-color: var(--text); }
    
    /* Expanded */
    .expanded { position: fixed; inset: 0; background: var(--bg); z-index: 200; display: none; flex-direction: column; }
    .expanded.active { display: flex; }
    .expanded-header { padding: 16px; display: flex; justify-content: space-between; align-items: center; }
    .expanded-label { font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: var(--text3); }
    .expanded-body { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 24px; }
    .expanded-art { width: 260px; height: 260px; border-radius: 10px; object-fit: cover; box-shadow: 0 16px 48px rgba(0,0,0,0.5); margin-bottom: 28px; }
    .expanded-info { text-align: center; margin-bottom: 28px; max-width: 360px; }
    .expanded-title { font-size: 20px; font-weight: 700; margin-bottom: 6px; }
    .expanded-show { font-size: 14px; color: var(--text2); }
    .expanded-progress { width: 100%; max-width: 360px; margin-bottom: 24px; }
    .expanded-bar { width: 100%; height: 4px; background: var(--border2); border-radius: 2px; cursor: pointer; margin-bottom: 6px; }
    .expanded-fill { height: 100%; background: var(--green); border-radius: 2px; }
    .expanded-times { display: flex; justify-content: space-between; font-size: 12px; color: var(--text3); font-family: monospace; }
    .expanded-controls { display: flex; align-items: center; gap: 28px; }
    .expanded-skip { width: 44px; height: 44px; border-radius: 50%; background: none; border: none; color: var(--text); cursor: pointer; font-size: 13px; font-weight: 600; font-family: inherit; }
    .expanded-skip:hover { background: var(--bg3); }
    .expanded-play { width: 56px; height: 56px; border-radius: 50%; background: var(--text); border: none; color: var(--bg); cursor: pointer; display: flex; align-items: center; justify-content: center; }
    .expanded-play:hover { background: var(--green); }

    /* Swipe Seeking */
    .swipe-container { position: relative; touch-action: pan-y; user-select: none; -webkit-user-select: none; }
    .swipe-indicator { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.7); border-radius: 10px; opacity: 0; pointer-events: none; transition: opacity 0.15s; }
    .swipe-indicator.active { opacity: 1; }
    .swipe-indicator-content { display: flex; flex-direction: column; align-items: center; gap: 8px; }
    .swipe-indicator-icon { font-size: 32px; color: var(--text); }
    .swipe-indicator-text { font-size: 28px; font-weight: 700; color: var(--text); }
    .swipe-indicator-label { font-size: 12px; color: var(--text2); text-transform: uppercase; letter-spacing: 1px; }
    .swipe-indicator.rewind .swipe-indicator-icon { color: var(--green); }
    .swipe-indicator.forward .swipe-indicator-icon { color: var(--green); }

    /* Modal */
    .modal { position: fixed; inset: 0; background: rgba(0,0,0,0.75); display: none; align-items: center; justify-content: center; z-index: 300; }
    .modal.active { display: flex; }
    .modal-box { background: var(--bg2); border-radius: 14px; width: 90%; max-width: 400px; }
    .modal-header { padding: 18px 20px; border-bottom: 1px solid var(--border); display: flex; align-items: center; justify-content: space-between; }
    .modal-header h2 { font-size: 18px; font-weight: 600; }
    .modal-close { background: none; border: none; color: var(--text2); cursor: pointer; }
    .modal-body { padding: 20px; }
    .form-group { margin-bottom: 16px; }
    .form-label { display: block; font-size: 13px; font-weight: 500; color: var(--text2); margin-bottom: 6px; }
    .form-input { width: 100%; padding: 11px 14px; background: var(--bg3); border: 1px solid var(--border2); border-radius: 8px; color: var(--text); font-size: 14px; font-family: inherit; }
    .form-input:focus { outline: none; border-color: var(--green); }
    .type-sel { display: flex; gap: 10px; }
    .type-btn { flex: 1; padding: 12px; background: var(--bg3); border: 2px solid var(--border2); border-radius: 10px; color: var(--text); cursor: pointer; display: flex; flex-direction: column; align-items: center; gap: 4px; font-family: inherit; }
    .type-btn.active { border-color: var(--green); background: rgba(29,185,84,0.1); }
    .type-btn .icon { font-size: 22px; }
    .type-btn .label { font-size: 13px; font-weight: 500; }
    .submit-btn { width: 100%; padding: 12px; background: var(--green); border: none; border-radius: 18px; color: #000; font-size: 15px; font-weight: 600; cursor: pointer; font-family: inherit; }
    .submit-btn:disabled { background: var(--border2); color: var(--text3); cursor: not-allowed; }
    .fetch-btn { padding: 11px 16px; background: var(--bg4); border: 1px solid var(--border2); border-radius: 8px; color: var(--text); font-size: 13px; font-weight: 500; cursor: pointer; font-family: inherit; white-space: nowrap; transition: all 0.15s; }
    .fetch-btn:hover:not(:disabled) { background: var(--green); color: #000; border-color: var(--green); }
    .fetch-btn:disabled { background: var(--bg3); color: var(--text3); cursor: not-allowed; }
    .fetch-btn.loading { background: var(--bg3); color: var(--text2); }
    .fetch-status { font-size: 12px; margin-top: 6px; min-height: 16px; }
    .fetch-status.success { color: var(--green); }
    .fetch-status.error { color: #e74c3c; }
    .fetch-status.loading { color: var(--text2); }
    
    .toast { position: fixed; bottom: 100px; left: 50%; transform: translateX(-50%); background: var(--bg4); color: var(--text); padding: 12px 24px; border-radius: 8px; font-size: 14px; z-index: 400; opacity: 0; transition: opacity 0.3s; pointer-events: none; }
    .toast.show { opacity: 1; }
    
    .empty { display: flex; flex-direction: column; align-items: center; padding: 48px 24px; text-align: center; color: var(--text3); }
    .empty-icon { font-size: 48px; margin-bottom: 12px; }
    .empty-title { font-size: 16px; font-weight: 600; color: var(--text); }
    
    @media (max-width: 768px) {
      .toggle-btn span:last-child { display: none; }
      .search-box { display: none; }
      .news-sidebar { display: none; }
      .show-hero { flex-direction: column; align-items: center; text-align: center; padding: 20px; }
      .show-hero-art { width: 160px; height: 160px; }
      .show-hero-title { font-size: 26px; }
      .player-info { display: none; }
    }
  </style>
</head>
<body>
<div class="app">
  <header class="header">
    <div class="logo">üì° Feedr</div>
    <div class="main-toggle">
      <button class="toggle-btn" data-view="all"><span>üìö</span><span>All</span></button>
      <button class="toggle-btn" data-view="news"><span>üì∞</span><span>News</span></button>
      <button class="toggle-btn active" data-view="podcasts"><span>üéß</span><span>Podcasts</span></button>
    </div>
    <div class="spacer"></div>
    <div class="search-box">
      <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2"><circle cx="7" cy="7" r="5"/><path d="M12 12l3 3"/></svg>
      <input type="text" id="searchInput" placeholder="Search...">
    </div>
    <button class="icon-btn" id="refreshBtn" title="Refresh feeds"><svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M1 4v6h6M23 20v-6h-6"/><path d="M20.49 9A9 9 0 005.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 013.51 15"/></svg></button>
    <button class="icon-btn" id="addBtn"><svg width="22" height="22" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12h14"/></svg></button>
  </header>
  
  <div class="main">
    <!-- NEWS VIEW -->
    <div class="news-view active" id="newsView">
      <aside class="news-sidebar">
        <div class="sidebar-header"><h2>Sources</h2><button class="add-btn" id="addNewsBtn">+</button></div>
        <div class="sidebar-content" id="newsSources"></div>
      </aside>
      <div class="news-content" id="newsContent">
        <div class="news-header">
          <div class="news-title" id="newsTitle">All Articles</div>
          <div class="category-chips" id="categoryChips"></div>
        </div>
        <div class="news-list" id="newsList"></div>
      </div>
      <div class="source-page" id="sourcePage"></div>
    </div>
    
    <!-- PODCAST VIEW -->
    <div class="podcast-view" id="podcastView">
      <nav class="podcast-nav">
        <button class="nav-btn active" data-tab="home">Home</button>
        <button class="nav-btn" data-tab="shows">Shows</button>
        <button class="nav-btn" data-tab="queue">Queue</button>
        <button class="nav-btn" data-tab="downloads">Downloads</button>
      </nav>
      <div class="podcast-content" id="podcastContent"></div>
      <div class="show-page" id="showPage"></div>
    </div>

    <!-- ALL VIEW -->
    <div class="all-view" id="allView">
      <div class="all-content" id="allContent"></div>
    </div>
  </div>
  
  <!-- PLAYER -->
  <div class="player" id="player">
    <div class="player-left">
      <img class="player-art" id="playerArt" src="">
      <div class="player-info">
        <div class="player-title" id="playerTitle"></div>
        <div class="player-show" id="playerShow"></div>
      </div>
    </div>
    <div class="player-center">
      <div class="player-controls">
        <button class="player-skip" id="pSkipBack">-15</button>
        <button class="player-play" id="pPlay"><svg width="16" height="16" fill="currentColor" viewBox="0 0 24 24" id="pPlayIcon"><path d="M8 5v14l11-7z"/></svg></button>
        <button class="player-skip" id="pSkipFwd">+30</button>
      </div>
      <div class="player-progress">
        <span class="player-time" id="pCur">0:00</span>
        <div class="player-bar" id="pBar"><div class="player-fill" id="pFill"></div></div>
        <span class="player-time right" id="pDur">0:00</span>
      </div>
    </div>
    <div class="player-right">
      <button class="speed-btn" id="pSpeed">1x</button>
      <button class="icon-btn" id="pExpand"><svg width="16" height="16" fill="currentColor" viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg></button>
    </div>
  </div>
  
  <!-- EXPANDED PLAYER -->
  <div class="expanded" id="expanded">
    <div class="expanded-header">
      <button class="icon-btn" id="expClose"><svg width="24" height="24" fill="none" stroke="currentColor" stroke-width="2"><path d="M6 9l6 6 6-6"/></svg></button>
      <span class="expanded-label">Now Playing</span>
      <div style="width:44px"></div>
    </div>
    <div class="expanded-body">
      <div class="swipe-container" id="swipeContainer">
        <img class="expanded-art" id="expArt" src="">
        <div class="swipe-indicator" id="swipeIndicator">
          <div class="swipe-indicator-content">
            <div class="swipe-indicator-icon" id="swipeIcon">‚è™</div>
            <div class="swipe-indicator-text" id="swipeText">-15s</div>
            <div class="swipe-indicator-label" id="swipeLabel">Rewind</div>
          </div>
        </div>
      </div>
      <div class="expanded-info">
        <div class="expanded-title" id="expTitle"></div>
        <div class="expanded-show" id="expShow"></div>
      </div>
      <div class="expanded-progress">
        <div class="expanded-bar" id="expBar"><div class="expanded-fill" id="expFill"></div></div>
        <div class="expanded-times"><span id="expCur">0:00</span><span id="expDur">0:00</span></div>
      </div>
      <div class="expanded-controls">
        <button class="expanded-skip" id="expBack">-15</button>
        <button class="expanded-play" id="expPlay"><svg width="24" height="24" fill="currentColor" viewBox="0 0 24 24" id="expPlayIcon"><path d="M8 5v14l11-7z"/></svg></button>
        <button class="expanded-skip" id="expFwd">+30</button>
      </div>
    </div>
  </div>
</div>

<!-- MODAL -->
<div class="modal" id="modal">
  <div class="modal-box">
    <div class="modal-header">
      <h2>Add Feed</h2>
      <button class="modal-close" id="modalClose"><svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 5L5 15M5 5l10 10"/></svg></button>
    </div>
    <div class="modal-body">
      <div class="form-group">
        <label class="form-label">Feed URL</label>
        <div style="display:flex;gap:8px">
          <input type="url" class="form-input" id="fUrl" placeholder="https://..." style="flex:1">
          <button class="fetch-btn" id="fFetch" disabled>Fetch</button>
        </div>
        <div class="fetch-status" id="fStatus"></div>
      </div>
      <div class="form-group"><label class="form-label">Name</label><input type="text" class="form-input" id="fName" placeholder="Auto-detected from feed..."></div>
      <div class="form-group"><label class="form-label">Creator / Author</label><input type="text" class="form-input" id="fAuthor" placeholder="Auto-detected from feed..."></div>
      <div class="form-group"><label class="form-label">Type</label>
        <div class="type-sel">
          <button class="type-btn active" id="tNews"><span class="icon">üì∞</span><span class="label">News</span></button>
          <button class="type-btn" id="tPodcast"><span class="icon">üéôÔ∏è</span><span class="label">Podcast</span></button>
        </div>
      </div>
      <div class="form-group"><label class="form-label">Category</label><input type="text" class="form-input" id="fCat" placeholder="Tech, News..."></div>
      <button class="submit-btn" id="fSubmit" disabled>Add Feed</button>
    </div>
  </div>
</div>
<div class="toast" id="toast"></div>

<!-- Audio element for actual playback -->
<audio id="audioPlayer" preload="metadata"></audio>

<script>
(function() {
  'use strict';
  
  // === MEMORY SYSTEM ===
  const Mem = {
    pending: [],
    session: 's_' + Date.now(),
    endpoint: null,

    log(action, target, data = {}) {
      const m = { id: 'm_' + Date.now() + '_' + Math.random().toString(36).substr(2,4), ts: new Date().toISOString(), action, target, session: this.session, ctx: { view: state.view, tab: state.tab }, ...data };
      this.pending.push(m);
      try { const a = JSON.parse(localStorage.getItem('mem') || '[]'); a.push(m); if (a.length > 500) a.splice(0, a.length - 500); localStorage.setItem('mem', JSON.stringify(a)); } catch(e) {}
      this.sync();
    },
    sync() {
      if (!this.endpoint || !this.pending.length) return;
      const t = [...this.pending]; this.pending = [];
      fetch(this.endpoint, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ memories: t }) }).catch(() => this.pending = [...t, ...this.pending]);
    },
    setEndpoint(u) { this.endpoint = u; this.sync(); },
    getLocal() { try { return JSON.parse(localStorage.getItem('mem') || '[]'); } catch(e) { return []; } }
  };
  window.Memory = Mem;

  // === DOWNLOAD STORAGE (IndexedDB) ===
  const DownloadDB = {
    db: null,
    DB_NAME: 'feedr_downloads',
    STORE_NAME: 'audio_files',

    async init() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(this.DB_NAME, 1);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => { this.db = request.result; resolve(); };
        request.onupgradeneeded = (e) => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains(this.STORE_NAME)) {
            db.createObjectStore(this.STORE_NAME, { keyPath: 'id' });
          }
        };
      });
    },

    async save(id, blob, metadata = {}) {
      return new Promise((resolve, reject) => {
        const tx = this.db.transaction(this.STORE_NAME, 'readwrite');
        const store = tx.objectStore(this.STORE_NAME);
        const request = store.put({ id, blob, metadata, savedAt: Date.now() });
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    },

    async get(id) {
      return new Promise((resolve, reject) => {
        const tx = this.db.transaction(this.STORE_NAME, 'readonly');
        const store = tx.objectStore(this.STORE_NAME);
        const request = store.get(id);
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    },

    async delete(id) {
      return new Promise((resolve, reject) => {
        const tx = this.db.transaction(this.STORE_NAME, 'readwrite');
        const store = tx.objectStore(this.STORE_NAME);
        const request = store.delete(id);
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    },

    async has(id) {
      const record = await this.get(id);
      return !!record;
    },

    async getAll() {
      return new Promise((resolve, reject) => {
        const tx = this.db.transaction(this.STORE_NAME, 'readonly');
        const store = tx.objectStore(this.STORE_NAME);
        const request = store.getAllKeys();
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }
  };

  // Track ongoing downloads
  const downloadProgress = {}; // { episodeId: { progress: 0-100, status: 'downloading'|'done'|'error' } }
  
  // === FUZZY SEARCH ===
  const fuzzy = (q, items, fields) => {
    if (!q.trim()) return items;
    const ql = q.toLowerCase();
    return items.map(item => {
      let score = 0;
      for (const f of fields) {
        const v = f.split('.').reduce((o, k) => o?.[k], item);
        if (v && String(v).toLowerCase().includes(ql)) score = 1;
      }
      return { item, score };
    }).filter(x => x.score > 0).map(x => x.item);
  };
  
  // === STATE ===
  const state = {
    view: 'podcasts',
    tab: 'home',
    feeds: [],
    articles: [],
    podcasts: [],
    categories: new Set(['All']),
    selectedSource: null,
    selectedCat: 'All',
    query: '',
    feedType: 'news',
    currentEp: null,
    playing: false,
    speed: 1,
    progress: {},
    viewPrefs: {}, // { sourceId: 'list'|'table'|'cards'|'masonry' }
    currentSourcePage: null, // Currently viewing source page (news)
    currentShowPage: null // Currently viewing show page (podcasts)
  };
  
  // === DOM ===
  const $ = id => document.getElementById(id);
  const el = {
    newsView: $('newsView'), podcastView: $('podcastView'), allView: $('allView'),
    allContent: $('allContent'),
    newsSources: $('newsSources'), newsTitle: $('newsTitle'),
    categoryChips: $('categoryChips'), newsList: $('newsList'),
    newsContent: $('newsContent'), sourcePage: $('sourcePage'),
    podcastContent: $('podcastContent'), showPage: $('showPage'),
    player: $('player'), playerArt: $('playerArt'), playerTitle: $('playerTitle'),
    playerShow: $('playerShow'), pPlay: $('pPlay'), pPlayIcon: $('pPlayIcon'),
    pCur: $('pCur'), pDur: $('pDur'), pBar: $('pBar'), pFill: $('pFill'), pSpeed: $('pSpeed'),
    expanded: $('expanded'), expArt: $('expArt'), expTitle: $('expTitle'),
    expShow: $('expShow'), expPlay: $('expPlay'), expPlayIcon: $('expPlayIcon'),
    expCur: $('expCur'), expDur: $('expDur'), expBar: $('expBar'), expFill: $('expFill'),
    swipeContainer: $('swipeContainer'), swipeIndicator: $('swipeIndicator'),
    swipeIcon: $('swipeIcon'), swipeText: $('swipeText'), swipeLabel: $('swipeLabel'),
    modal: $('modal'), fUrl: $('fUrl'), fName: $('fName'), fAuthor: $('fAuthor'), fCat: $('fCat'),
    fFetch: $('fFetch'), fStatus: $('fStatus'), fSubmit: $('fSubmit'),
    toast: $('toast'), searchInput: $('searchInput'),
    audio: $('audioPlayer')
  };
  
  // === UTILS ===
  const fmt = s => { if (isNaN(s) || s < 0) return '0:00'; const m = Math.floor(s / 60), sec = Math.floor(s % 60); return m + ':' + String(sec).padStart(2, '0'); };
  const toast = m => { el.toast.textContent = m; el.toast.classList.add('show'); setTimeout(() => el.toast.classList.remove('show'), 2500); };
  const save = () => localStorage.setItem('feedr2', JSON.stringify({ feeds: state.feeds, articles: state.articles, podcasts: state.podcasts, progress: state.progress, view: state.view, viewPrefs: state.viewPrefs }));

  const load = () => {
    try {
      const d = JSON.parse(localStorage.getItem('feedr2'));
      if (d) { state.feeds = d.feeds || []; state.articles = d.articles || []; state.podcasts = d.podcasts || []; state.progress = d.progress || {}; if (d.view) state.view = d.view; state.viewPrefs = d.viewPrefs || {}; }
      state.feeds.forEach(f => f.category && state.categories.add(f.category));
      if (!state.feeds.length) loadDemo();
    } catch(e) { loadDemo(); }
  };

  // Get/set view preference for a source
  const getViewPref = (sourceId, defaultView = 'list') => state.viewPrefs[sourceId] || defaultView;
  const setViewPref = (sourceId, viewMode) => { state.viewPrefs[sourceId] = viewMode; save(); };
  
  const loadDemo = () => {
    // No sample data - users add their own feeds
    state.feeds = [];
    state.articles = [];
    state.podcasts = [];
    state.progress = {};
    save();
  };

  // === RSS FEED FETCHING ===
  // Simpler, more reliable CORS proxy configuration
  const CORS_PROXIES = [
    url => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
    url => `https://corsproxy.io/?${encodeURIComponent(url)}`,
    url => `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`
  ];

  const fetchWithTimeout = (url, options = {}, timeout = 15000) => {
    return Promise.race([
      fetch(url, options),
      new Promise((_, reject) =>
        setTimeout(() => reject(new Error('Request timeout')), timeout)
      )
    ]);
  };

  const fetchWithProxy = async (url, proxyIndex = 0) => {
    if (proxyIndex >= CORS_PROXIES.length) {
      throw new Error(`All CORS proxies failed for: ${url}`);
    }

    const proxyUrl = CORS_PROXIES[proxyIndex](url);
    console.log('Trying proxy:', proxyUrl);

    try {
      const response = await fetchWithTimeout(proxyUrl, {
        headers: { 'Accept': 'application/rss+xml, application/xml, text/xml, */*' }
      }, 20000);

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }

      const text = await response.text();

      if (!text || text.trim().length === 0) {
        throw new Error('Empty response');
      }

      // Basic validation that this looks like XML
      if (!text.trim().startsWith('<?xml') && !text.trim().startsWith('<rss') && !text.trim().startsWith('<feed')) {
        console.warn('Response does not look like XML:', text.substring(0, 100));
        // Still try to use it, might be valid
      }

      return text;
    } catch (e) {
      console.warn(`Proxy ${proxyIndex} failed:`, e.message);
      return fetchWithProxy(url, proxyIndex + 1);
    }
  };

  // Download audio file with progress tracking
  const downloadAudioFile = async (episodeId, audioUrl, onProgress) => {
    // Try direct fetch first, then CORS proxies
    const urlsToTry = [
      audioUrl,
      ...CORS_PROXIES.map(p => p(audioUrl))
    ];

    for (let i = 0; i < urlsToTry.length; i++) {
      const url = urlsToTry[i];
      try {
        const response = await fetch(url);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);

        const contentLength = response.headers.get('content-length');
        const total = contentLength ? parseInt(contentLength, 10) : 0;

        if (!response.body) {
          // Fallback for browsers without ReadableStream support
          const blob = await response.blob();
          if (onProgress) onProgress(100);
          return blob;
        }

        const reader = response.body.getReader();
        const chunks = [];
        let received = 0;

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          chunks.push(value);
          received += value.length;
          if (total && onProgress) {
            onProgress(Math.round((received / total) * 100));
          }
        }

        const blob = new Blob(chunks, { type: response.headers.get('content-type') || 'audio/mpeg' });
        if (onProgress) onProgress(100);
        return blob;
      } catch (e) {
        console.warn(`Download attempt ${i + 1} failed:`, e.message);
        if (i === urlsToTry.length - 1) throw e;
      }
    }
    throw new Error('All download attempts failed');
  };

  // Start downloading an episode
  const startDownload = async (episodeId) => {
    const ep = state.podcasts.find(p => p.id === episodeId);
    if (!ep || !ep.audioUrl) {
      toast('No audio URL for this episode');
      return;
    }

    if (downloadProgress[episodeId]?.status === 'downloading') {
      toast('Already downloading...');
      return;
    }

    downloadProgress[episodeId] = { progress: 0, status: 'downloading' };
    renderPodcasts();
    if (state.currentShowPage) renderShowPage(state.currentShowPage);

    try {
      toast('Starting download...');
      const blob = await downloadAudioFile(episodeId, ep.audioUrl, (progress) => {
        downloadProgress[episodeId].progress = progress;
        // Update UI periodically (not every progress update to avoid excessive re-renders)
        if (progress % 10 === 0 || progress === 100) {
          renderPodcasts();
          if (state.currentShowPage) renderShowPage(state.currentShowPage);
        }
      });

      // Save to IndexedDB
      await DownloadDB.save(episodeId, blob, {
        title: ep.title,
        audioUrl: ep.audioUrl,
        size: blob.size
      });

      ep.downloaded = true;
      downloadProgress[episodeId] = { progress: 100, status: 'done' };
      save();
      Mem.log('download_completed', 'ep_' + episodeId, { size: blob.size });
      toast('Download complete!');
    } catch (e) {
      console.error('Download failed:', e);
      downloadProgress[episodeId] = { progress: 0, status: 'error' };
      toast('Download failed: ' + e.message);
    }

    renderPodcasts();
    if (state.currentShowPage) renderShowPage(state.currentShowPage);
  };

  // Remove a downloaded episode
  const removeDownload = async (episodeId) => {
    const ep = state.podcasts.find(p => p.id === episodeId);
    if (!ep) return;

    try {
      await DownloadDB.delete(episodeId);
      ep.downloaded = false;
      delete downloadProgress[episodeId];
      save();
      Mem.log('download_removed', 'ep_' + episodeId);
      toast('Download removed');
    } catch (e) {
      console.error('Failed to remove download:', e);
      toast('Failed to remove download');
    }

    renderPodcasts();
    if (state.currentShowPage) renderShowPage(state.currentShowPage);
  };

  const parseRSSDate = dateStr => {
    if (!dateStr) return new Date();
    const d = new Date(dateStr);
    return isNaN(d.getTime()) ? new Date() : d;
  };

  const formatTimeAgo = date => {
    const now = new Date();
    const diff = Math.floor((now - date) / 1000);
    if (diff < 60) return 'just now';
    if (diff < 3600) return Math.floor(diff / 60) + 'm ago';
    if (diff < 86400) return Math.floor(diff / 3600) + 'h ago';
    if (diff < 604800) return Math.floor(diff / 86400) + 'd ago';
    return Math.floor(diff / 604800) + 'w ago';
  };

  const parseDuration = dur => {
    if (!dur) return 0;
    // Handle HH:MM:SS or MM:SS format
    if (dur.includes(':')) {
      const parts = dur.split(':').map(Number);
      if (parts.length === 3) return parts[0] * 3600 + parts[1] * 60 + parts[2];
      if (parts.length === 2) return parts[0] * 60 + parts[1];
    }
    // Handle seconds as number
    const num = parseInt(dur, 10);
    return isNaN(num) ? 0 : num;
  };

  // Helper to find elements with namespace support (handles itunes:*, media:*, etc.)
  const findElement = (parent, tag) => {
    // Try getElementsByTagName first (works best with namespaced elements)
    let elements = parent.getElementsByTagName(tag);
    if (elements.length > 0) return elements[0];

    // Try without namespace prefix (for local names)
    const localName = tag.includes(':') ? tag.split(':')[1] : tag;
    elements = parent.getElementsByTagName(localName);
    if (elements.length > 0) return elements[0];

    // Try with wildcard namespace
    const nsElements = parent.getElementsByTagNameNS('*', localName);
    if (nsElements.length > 0) return nsElements[0];

    // Fallback to querySelector (may not work with namespaced elements in all browsers)
    try {
      const node = parent.querySelector(tag);
      if (node) return node;
    } catch(e) {
      // Selector may be invalid for namespaced tags
    }

    return null;
  };

  // Find all elements matching a tag (for items/entries)
  const findAllElements = (parent, tag) => {
    let elements = parent.getElementsByTagName(tag);
    if (elements.length > 0) return Array.from(elements);

    const localName = tag.includes(':') ? tag.split(':')[1] : tag;
    elements = parent.getElementsByTagName(localName);
    if (elements.length > 0) return Array.from(elements);

    return [];
  };

  const getNodeText = (parent, tag) => {
    const node = findElement(parent, tag);
    return node ? node.textContent?.trim() || '' : '';
  };

  const getNodeAttr = (parent, tag, attr) => {
    const node = findElement(parent, tag);
    return node ? node.getAttribute(attr) || '' : '';
  };

  // Get image from itunes:image element (has href attribute)
  const getItunesImage = (parent) => {
    // iTunes namespace URI
    const itunesNS = 'http://www.itunes.com/dtds/podcast-1.0.dtd';

    // Try getElementsByTagNameNS with iTunes namespace
    try {
      let elements = parent.getElementsByTagNameNS(itunesNS, 'image');
      if (elements.length > 0) {
        const href = elements[0].getAttribute('href');
        if (href) return href;
      }
    } catch(e) {}

    // Try itunes:image with colon
    try {
      let elements = parent.getElementsByTagName('itunes:image');
      if (elements.length > 0) {
        const href = elements[0].getAttribute('href');
        if (href) return href;
      }
    } catch(e) {}

    // Try wildcard namespace with local name 'image'
    try {
      const elements = parent.getElementsByTagNameNS('*', 'image');
      for (let i = 0; i < elements.length; i++) {
        const href = elements[i].getAttribute('href');
        if (href) return href;
      }
    } catch(e) {}

    // Try just 'image' elements with href attribute
    const imageEls = parent.getElementsByTagName('image');
    for (let i = 0; i < imageEls.length; i++) {
      const href = imageEls[i].getAttribute('href');
      if (href) return href;
    }

    return '';
  };

  // Check if URL looks like a valid image URL (not just a homepage)
  const isValidImageUrl = url => {
    if (!url) return false;
    try {
      const parsed = new URL(url);
      // Reject URLs that are just hostnames with no meaningful path
      if (parsed.pathname === '/' || parsed.pathname === '') return false;
      // Accept URLs with image extensions or meaningful paths
      const imageExtensions = /\.(jpg|jpeg|png|gif|webp|svg|bmp|ico)(\?|$)/i;
      if (imageExtensions.test(parsed.pathname)) return true;
      // Accept URLs with paths that look like they could be images
      if (parsed.pathname.length > 1) return true;
      return false;
    } catch (e) {
      return false;
    }
  };

  const extractImage = item => {
    // Try media:content
    let img = getNodeAttr(item, 'media:content', 'url');
    if (img && isValidImageUrl(img)) return img;

    // Try media:thumbnail
    img = getNodeAttr(item, 'media:thumbnail', 'url');
    if (img && isValidImageUrl(img)) return img;

    // Try enclosure with image type
    const enclosure = findElement(item, 'enclosure');
    if (enclosure) {
      const type = enclosure.getAttribute('type') || '';
      if (type.startsWith('image/')) {
        return enclosure.getAttribute('url') || '';
      }
    }

    // Try to extract from description/content HTML
    const desc = getNodeText(item, 'description') || getNodeText(item, 'content:encoded');
    const match = desc.match(/<img[^>]+src=["']([^"']+)["']/i);
    if (match) return match[1];

    return '';
  };

  const parseNewsFeed = (xml, feedId) => {
    const parser = new DOMParser();
    const doc = parser.parseFromString(xml, 'text/xml');

    const parserError = doc.querySelector('parsererror');
    if (parserError) {
      throw new Error('Invalid RSS feed XML');
    }

    const items = doc.querySelectorAll('item, entry');
    const articles = [];

    items.forEach((item, index) => {
      const title = getNodeText(item, 'title');
      if (!title) return;

      const pubDate = parseRSSDate(
        getNodeText(item, 'pubDate') ||
        getNodeText(item, 'published') ||
        getNodeText(item, 'updated') ||
        getNodeText(item, 'dc:date')
      );

      // Get description and clean HTML
      let summary = getNodeText(item, 'description') || getNodeText(item, 'summary') || getNodeText(item, 'content:encoded') || '';
      // Strip HTML tags for summary
      const tmp = document.createElement('div');
      tmp.innerHTML = summary;
      summary = tmp.textContent?.trim().slice(0, 300) || '';

      const link = getNodeText(item, 'link') || getNodeAttr(item, 'link', 'href');
      const image = extractImage(item);

      // Create unique ID using feed ID, hash of title, and index
      const titleHash = title.split('').reduce((a, c) => ((a << 5) - a + c.charCodeAt(0)) | 0, 0);
      const uniqueId = Math.abs(feedId * 100000 + titleHash + index);

      articles.push({
        id: uniqueId,
        feedId,
        title,
        summary,
        link,
        time: formatTimeAgo(pubDate),
        pubDate: pubDate.toISOString(),
        image,
        unread: true
      });
    });

    return articles;
  };

  const parsePodcastFeed = (xml, feedId) => {
    const parser = new DOMParser();
    const doc = parser.parseFromString(xml, 'text/xml');

    const parserError = doc.querySelector('parsererror');
    if (parserError) {
      console.error('XML parse error:', parserError.textContent);
      throw new Error('Invalid podcast feed XML');
    }

    // Get channel element for fallback image
    const channel = doc.querySelector('channel') || doc.querySelector('feed');
    let channelImage = '';
    if (channel) {
      channelImage = getItunesImage(channel);
      if (!channelImage) {
        // Try standard RSS image/url
        const imageEl = channel.querySelector('image');
        if (imageEl) {
          const urlEl = imageEl.querySelector('url');
          if (urlEl) channelImage = urlEl.textContent?.trim() || '';
        }
      }
    }

    // Find all items - use getElementsByTagName for better compatibility
    const items = Array.from(doc.getElementsByTagName('item'));
    if (items.length === 0) {
      // Try Atom entry format
      items.push(...Array.from(doc.getElementsByTagName('entry')));
    }

    console.log('Parsing podcast feed, found', items.length, 'items');
    const episodes = [];

    items.forEach((item, index) => {
      const title = getNodeText(item, 'title');
      if (!title) return;

      // Get audio enclosure - try multiple methods
      let audioUrl = '';
      const enclosures = item.getElementsByTagName('enclosure');
      for (let i = 0; i < enclosures.length; i++) {
        const enc = enclosures[i];
        const type = enc.getAttribute('type') || '';
        const url = enc.getAttribute('url') || '';
        if (url && (type.includes('audio') || type.includes('video') || !type)) {
          audioUrl = url;
          break;
        }
      }

      // Fallback to link with enclosure rel for Atom
      if (!audioUrl) {
        const links = item.getElementsByTagName('link');
        for (let i = 0; i < links.length; i++) {
          const link = links[i];
          if (link.getAttribute('rel') === 'enclosure') {
            audioUrl = link.getAttribute('href') || '';
            break;
          }
        }
      }

      const pubDate = parseRSSDate(
        getNodeText(item, 'pubDate') ||
        getNodeText(item, 'published') ||
        getNodeText(item, 'updated')
      );

      // Get duration from itunes:duration - try multiple approaches
      let durationStr = '';
      const durationEls = item.getElementsByTagName('itunes:duration');
      if (durationEls.length > 0) {
        durationStr = durationEls[0].textContent?.trim() || '';
      }
      if (!durationStr) {
        const durEls = item.getElementsByTagName('duration');
        if (durEls.length > 0) {
          durationStr = durEls[0].textContent?.trim() || '';
        }
      }
      const duration = parseDuration(durationStr);

      // Get description - try multiple fields
      let desc = '';
      const descFields = ['itunes:summary', 'itunes:subtitle', 'description', 'summary', 'content:encoded'];
      for (const field of descFields) {
        const els = item.getElementsByTagName(field);
        if (els.length > 0 && els[0].textContent?.trim()) {
          desc = els[0].textContent.trim();
          break;
        }
      }
      // Strip HTML
      const tmp = document.createElement('div');
      tmp.innerHTML = desc;
      desc = tmp.textContent?.trim().slice(0, 300) || '';

      // Get episode image - try multiple approaches
      let image = getItunesImage(item);
      if (!image) {
        image = extractImage(item);
      }
      // Fallback to channel image
      if (!image) {
        image = channelImage;
      }

      // Create unique ID using feed ID, hash of title, and index
      const titleHash = title.split('').reduce((a, c) => ((a << 5) - a + c.charCodeAt(0)) | 0, 0);
      const uniqueId = Math.abs(feedId * 100000 + titleHash + index);

      episodes.push({
        id: uniqueId,
        feedId,
        title,
        desc,
        duration: duration || 1800, // Default 30 min if no duration
        date: formatTimeAgo(pubDate),
        pubDate: pubDate.toISOString(),
        image,
        audioUrl,
        downloaded: false
      });
    });

    console.log('Parsed', episodes.length, 'episodes');
    return episodes;
  };

  const extractFeedMeta = xml => {
    const parser = new DOMParser();
    const doc = parser.parseFromString(xml, 'text/xml');

    const channel = doc.querySelector('channel') || doc.querySelector('feed');
    if (!channel) return {};

    // Get image - try multiple methods
    let image = getItunesImage(channel);

    if (!image) {
      // Try standard RSS image element with url child
      const imageEl = channel.querySelector('image');
      if (imageEl) {
        const urlEl = imageEl.querySelector('url');
        if (urlEl) {
          image = urlEl.textContent?.trim() || '';
        }
        if (!image) {
          image = imageEl.getAttribute('href') || '';
        }
      }
    }

    if (!image) {
      // Try Atom logo
      const logoEl = channel.querySelector('logo');
      if (logoEl) {
        image = logoEl.textContent?.trim() || logoEl.getAttribute('src') || '';
      }
    }

    // Get author - try multiple approaches
    let author = '';
    const authorFields = ['itunes:author', 'author', 'managingEditor', 'dc:creator'];
    for (const field of authorFields) {
      const els = channel.getElementsByTagName(field);
      if (els.length > 0 && els[0].textContent?.trim()) {
        author = els[0].textContent.trim();
        break;
      }
    }

    return {
      title: getNodeText(channel, 'title'),
      description: getNodeText(channel, 'description') || getNodeText(channel, 'subtitle'),
      author,
      image
    };
  };

  // Fetch feed metadata without adding it - for preview/auto-detect
  const fetchFeedMetadata = async (url) => {
    try {
      const xml = await fetchWithProxy(url);
      const meta = extractFeedMeta(xml);

      // Also try to detect feed type based on content
      const parser = new DOMParser();
      const doc = parser.parseFromString(xml, 'text/xml');
      const hasEnclosure = doc.querySelector('enclosure[type^="audio"], enclosure[type^="video"]');
      const hasItunesNs = xml.includes('xmlns:itunes') || xml.includes('itunes:');
      const suggestedType = (hasEnclosure || hasItunesNs) ? 'podcast' : 'news';

      return {
        success: true,
        title: meta.title || '',
        author: meta.author || '',
        description: meta.description || '',
        image: meta.image || '',
        suggestedType
      };
    } catch (e) {
      console.error('Failed to fetch feed metadata:', e);
      return {
        success: false,
        error: e.message
      };
    }
  };

  const fetchAndParseFeed = async feed => {
    try {
      const xml = await fetchWithProxy(feed.url);
      const meta = extractFeedMeta(xml);

      // Update feed metadata if available (only if user hasn't provided values)
      if (meta.title && (!feed.name || feed.name === 'Loading...')) feed.name = meta.title;
      if (meta.image && !feed.image) feed.image = meta.image;
      if (meta.author && !feed.author) feed.author = meta.author;

      if (feed.type === 'news') {
        const articles = parseNewsFeed(xml, feed.id);
        // Merge with existing, avoiding duplicates by title
        const existingTitles = new Set(state.articles.filter(a => a.feedId === feed.id).map(a => a.title));
        const newArticles = articles.filter(a => !existingTitles.has(a.title));
        state.articles = [...newArticles, ...state.articles.filter(a => a.feedId !== feed.id || existingTitles.has(a.title))];
        // Sort by date
        state.articles.sort((a, b) => new Date(b.pubDate || 0) - new Date(a.pubDate || 0));
        // Update unread count
        feed.unread = state.articles.filter(a => a.feedId === feed.id && a.unread).length;
      } else {
        const episodes = parsePodcastFeed(xml, feed.id);
        const existingTitles = new Set(state.podcasts.filter(p => p.feedId === feed.id).map(p => p.title));
        const newEpisodes = episodes.filter(e => !existingTitles.has(e.title));
        state.podcasts = [...newEpisodes, ...state.podcasts.filter(p => p.feedId !== feed.id || existingTitles.has(p.title))];
        // Sort by date
        state.podcasts.sort((a, b) => new Date(b.pubDate || 0) - new Date(a.pubDate || 0));
      }

      feed.lastFetched = new Date().toISOString();
      feed.error = null;
      return true;
    } catch (e) {
      console.error(`Failed to fetch feed ${feed.name}:`, e);
      feed.error = e.message;
      return false;
    }
  };

  const refreshAllFeeds = async () => {
    if (state.refreshing) return;
    state.refreshing = true;
    toast('Refreshing feeds...');

    const results = await Promise.allSettled(
      state.feeds.map(feed => fetchAndParseFeed(feed))
    );

    const success = results.filter(r => r.status === 'fulfilled' && r.value).length;
    const failed = results.length - success;

    state.refreshing = false;
    save();
    renderNewsSources();
    renderCategories();
    renderNews();
    if (state.view === 'podcasts') renderPodcasts();

    if (failed > 0) {
      toast(`Refreshed ${success} feeds, ${failed} failed`);
    } else if (success > 0) {
      toast(`Refreshed ${success} feeds`);
    }
  };

  const addFeed = async (url, name, type, category, author) => {
    const id = Date.now();
    const feed = {
      id,
      url,
      name: name || 'Loading...',
      type,
      category: category || 'Uncategorized',
      image: '',
      author: author || '',
      unread: 0
    };

    state.feeds.push(feed);
    state.categories.add(feed.category);
    save();

    toast('Adding feed...');
    const success = await fetchAndParseFeed(feed);

    if (success) {
      save();
      renderNewsSources();
      renderCategories();
      renderNews();
      if (state.view === 'podcasts') renderPodcasts();
      toast(`Added: ${feed.name}`);
    } else {
      // Keep the feed but show error
      toast(`Added ${feed.name} (fetch failed)`);
    }

    return success;
  };
  
  // === RENDER NEWS ===
  const renderNewsSources = () => {
    const news = state.feeds.filter(f => f.type === 'news');
    el.newsSources.innerHTML = `<div class="source-item ${!state.selectedSource && !state.currentSourcePage ? 'active' : ''}" data-id="all"><div class="source-icon">üìö</div><div class="source-name">All Sources</div></div>` +
      news.map(f => `<div class="source-item ${state.currentSourcePage === f.id ? 'active' : ''}" data-id="${f.id}"><div class="source-icon">${f.image ? `<img src="${f.image}">` : 'üì∞'}</div><div class="source-name">${f.name}</div>${f.unread ? `<span class="source-badge">${f.unread}</span>` : ''}<span class="source-arrow">‚Üí</span></div>`).join('');
  };
  
  const renderCategories = () => {
    const cats = ['All', ...Array.from(state.categories).filter(c => c !== 'All')];
    el.categoryChips.innerHTML = cats.map(c => `<button class="chip ${state.selectedCat === c ? 'active' : ''}" data-cat="${c}">${c}</button>`).join('');
  };
  
  const renderNews = () => {
    let items = state.articles.map(a => ({ ...a, feed: state.feeds.find(f => f.id === a.feedId) }));
    if (state.selectedSource) items = items.filter(i => i.feedId === state.selectedSource);
    if (state.selectedCat !== 'All') items = fuzzy(state.selectedCat, items, ['feed.category']);
    if (state.query) items = fuzzy(state.query, items, ['title', 'summary', 'feed.name']);
    
    if (!items.length) {
      const hasFeeds = state.feeds.filter(f => f.type === 'news').length > 0;
      el.newsList.innerHTML = hasFeeds
        ? '<div class="empty"><div class="empty-icon">üì≠</div><div class="empty-title">No articles found</div><div style="color:var(--text3);margin-top:8px">Try refreshing your feeds</div></div>'
        : '<div class="empty"><div class="empty-icon">üì°</div><div class="empty-title">No news feeds yet</div><div style="color:var(--text3);margin-top:8px">Click + to add your first RSS feed</div></div>';
      return;
    }
    
    el.newsList.innerHTML = items.map(i => `<div class="article ${i.unread ? 'unread' : ''}" data-id="${i.id}"><div class="article-icon">${i.feed?.image ? `<img src="${i.feed.image}">` : 'üìÑ'}</div><div class="article-body"><div class="article-meta"><span class="article-source">${i.feed?.name || ''}</span><span class="article-time">¬∑ ${i.time}</span>${i.unread ? '<span class="article-new">NEW</span>' : ''}</div><div class="article-title">${i.title}</div>${i.summary ? `<div class="article-summary">${i.summary}</div>` : ''}</div>${i.image ? `<img class="article-image" src="${i.image}">` : ''}</div>`).join('');
  };
  
  // === RENDER PODCASTS ===
  const renderPodcasts = () => {
    el.showPage.classList.remove('active');
    el.podcastContent.style.display = 'block';
    
    const shows = state.feeds.filter(f => f.type === 'podcast');
    const inProgress = state.podcasts.filter(p => { const pr = state.progress[p.id] || 0; return pr > 0 && pr < p.duration * 0.95; });
    const downloaded = state.podcasts.filter(p => p.downloaded);
    
    if (state.tab === 'home') {
      if (!shows.length) {
        el.podcastContent.innerHTML = '<div class="empty" style="padding-top:80px"><div class="empty-icon">üéôÔ∏è</div><div class="empty-title">No podcasts yet</div><div style="color:var(--text3);margin-top:8px">Click + to add your first podcast feed</div></div>';
        return;
      }
      el.podcastContent.innerHTML = `
        ${inProgress.length ? `<div class="section"><div class="section-header"><div class="section-title">Continue Listening</div></div><div class="episode-list">${inProgress.map(renderEpisode).join('')}</div></div>` : ''}
        <div class="section"><div class="section-header"><div class="section-title">Your Shows</div></div><div class="shows-grid">${shows.map(s => `<div class="show-card" data-show="${s.id}"><img class="show-art" src="${s.image || placeholderImg}" onerror="this.src='${placeholderImg}'"><div class="show-name">${s.name}</div><div class="show-author">${s.author || ''}</div></div>`).join('')}</div></div>
        ${state.podcasts.length ? `<div class="section"><div class="section-header"><div class="section-title">Recent Episodes</div></div><div class="episode-list">${state.podcasts.slice(0, 6).map(renderEpisode).join('')}</div></div>` : ''}`;
    } else if (state.tab === 'shows') {
      el.podcastContent.innerHTML = `<div class="section"><div class="section-header"><div class="section-title">All Shows</div><button class="add-btn" onclick="document.getElementById('tPodcast').click();document.getElementById('modal').classList.add('active')">+</button></div><div class="shows-grid">${shows.map(s => `<div class="show-card" data-show="${s.id}"><img class="show-art" src="${s.image || placeholderImg}" onerror="this.src='${placeholderImg}'"><div class="show-name">${s.name}</div><div class="show-author">${s.author || ''}</div></div>`).join('')}</div></div>`;
    } else if (state.tab === 'queue') {
      el.podcastContent.innerHTML = `<div class="section"><div class="section-header"><div class="section-title">Up Next</div></div>${state.podcasts.length ? `<div class="episode-list">${state.podcasts.slice(0, 10).map(renderEpisode).join('')}</div>` : '<div class="empty"><div class="empty-icon">üìã</div><div class="empty-title">Queue empty</div></div>'}</div>`;
    } else if (state.tab === 'downloads') {
      el.podcastContent.innerHTML = `<div class="section"><div class="section-header"><div class="section-title">Downloads</div></div>${downloaded.length ? `<div class="episode-list">${downloaded.map(renderEpisode).join('')}</div>` : '<div class="empty"><div class="empty-icon">‚¨áÔ∏è</div><div class="empty-title">No downloads</div></div>'}</div>`;
    }
  };
  
  // Placeholder SVG for broken images
  const placeholderImg = 'data:image/svg+xml,' + encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><rect fill="#1a1a1a" width="100" height="100"/><text x="50" y="60" text-anchor="middle" font-size="40">üéôÔ∏è</text></svg>');

  const renderEpisode = ep => {
    const show = state.feeds.find(f => f.id === ep.feedId);
    const pr = state.progress[ep.id] || 0;
    const pct = ep.duration ? (pr / ep.duration) * 100 : 0;
    const rem = ep.duration - pr;
    const done = pr >= ep.duration * 0.95;
    const imgSrc = ep.image || show?.image || placeholderImg;

    // Download status
    const dlStatus = downloadProgress[ep.id];
    const isDownloading = dlStatus?.status === 'downloading';
    const dlPct = dlStatus?.progress || 0;

    // Download button content
    let dlBtnContent;
    if (isDownloading) {
      dlBtnContent = `<span style="font-size:10px;font-weight:600">${dlPct}%</span>`;
    } else if (ep.downloaded) {
      dlBtnContent = `<svg width="16" height="16" fill="currentColor" stroke="none" viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>`;
    } else {
      dlBtnContent = `<svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M7 10l5 5 5-5M12 15V3"/></svg>`;
    }

    return `<div class="episode" data-ep="${ep.id}"><img class="episode-art" src="${imgSrc}" onerror="this.src='${placeholderImg}'"><div class="episode-body"><div class="episode-show">${show?.name || ''}</div><div class="episode-title">${ep.title}</div><div class="episode-footer"><button class="ep-play" data-ep="${ep.id}"><svg width="10" height="10" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg></button><div class="ep-progress"><div class="ep-bar"><div class="ep-fill" style="width:${pct}%"></div></div><span class="ep-time">${done ? 'Played' : pr > 0 ? fmt(rem) + ' left' : fmt(ep.duration)}</span></div><button class="ep-dl ${ep.downloaded ? 'active' : ''} ${isDownloading ? 'downloading' : ''}" data-dl="${ep.id}" ${isDownloading ? 'disabled' : ''}>${dlBtnContent}</button></div></div></div>`;
  };
  
  // View options HTML generator
  const renderViewOptions = (sourceId, currentView, views = ['list', 'table', 'cards', 'masonry']) => {
    const icons = {
      list: '<svg width="14" height="14" fill="currentColor" viewBox="0 0 24 24"><path d="M3 13h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2V7H3v2zm4 4h14v-2H7v2zm0 4h14v-2H7v2zM7 7v2h14V7H7z"/></svg>',
      table: '<svg width="14" height="14" fill="currentColor" viewBox="0 0 24 24"><path d="M3 3v18h18V3H3zm8 16H5v-6h6v6zm0-8H5V5h6v6zm8 8h-6v-6h6v6zm0-8h-6V5h6v6z"/></svg>',
      cards: '<svg width="14" height="14" fill="currentColor" viewBox="0 0 24 24"><path d="M4 11h5V5H4v6zm0 7h5v-6H4v6zm6 0h5v-6h-5v6zm6 0h5v-6h-5v6zm-6-7h5V5h-5v6zm6-6v6h5V5h-5z"/></svg>',
      masonry: '<svg width="14" height="14" fill="currentColor" viewBox="0 0 24 24"><path d="M3 3v8h8V3H3zm6 6H5V5h4v4zm-6 4v8h8v-8H3zm6 6H5v-4h4v4zm4-16v12h8V3h-8zm6 10h-4V5h4v8zm-6 2v8h8v-8h-8zm6 6h-4v-4h4v4z"/></svg>'
    };
    const labels = { list: 'List', table: 'Table', cards: 'Cards', masonry: 'Masonry' };
    return `<div class="view-options" data-source="${sourceId}">${views.map(v =>
      `<button class="view-btn ${currentView === v ? 'active' : ''}" data-view="${v}" title="${labels[v]}">${icons[v]}</button>`
    ).join('')}</div>`;
  };

  // Render article in different view modes
  const renderArticleCard = (article, feed) => `
    <div class="article-card ${article.unread ? 'unread' : ''}" data-id="${article.id}">
      ${article.image ? `<img class="article-card-image" src="${article.image}" onerror="this.style.display='none'">` : '<div class="article-card-image" style="background:var(--bg3);display:flex;align-items:center;justify-content:center;font-size:32px">üìÑ</div>'}
      <div class="article-card-body">
        <div class="article-card-meta">
          <span class="article-card-source">${feed?.name || ''}</span>
          <span class="article-card-time">¬∑ ${article.time}</span>
        </div>
        <div class="article-card-title">${article.title}</div>
        ${article.summary ? `<div class="article-card-summary">${article.summary}</div>` : ''}
      </div>
    </div>`;

  const renderArticleMasonry = (article, feed) => `
    <div class="article-masonry ${article.unread ? 'unread' : ''}" data-id="${article.id}">
      ${article.image ? `<img class="article-masonry-image" src="${article.image}" onerror="this.style.display='none'">` : ''}
      <div class="article-masonry-body">
        <div class="article-masonry-meta">
          <span class="article-masonry-source">${feed?.name || ''}</span>
          <span class="article-masonry-time">¬∑ ${article.time}</span>
        </div>
        <div class="article-masonry-title">${article.title}</div>
        ${article.summary ? `<div class="article-masonry-summary">${article.summary}</div>` : ''}
      </div>
    </div>`;

  const renderArticleTable = (article, feed) => `
    <tr class="${article.unread ? 'unread' : ''}" data-id="${article.id}">
      <td class="table-title">${article.title}</td>
      <td class="table-source">${feed?.name || ''}</td>
      <td class="table-time">${article.time}</td>
      <td class="table-new">${article.unread ? 'NEW' : ''}</td>
    </tr>`;

  // Render episodes in different view modes
  const renderEpisodeCard = ep => {
    const show = state.feeds.find(f => f.id === ep.feedId);
    const imgSrc = ep.image || show?.image || placeholderImg;
    const pr = state.progress[ep.id] || 0;
    return `<div class="episode-card" data-ep="${ep.id}">
      <img class="episode-card-art" src="${imgSrc}" onerror="this.src='${placeholderImg}'">
      <div class="episode-card-body">
        <div class="episode-card-title">${ep.title}</div>
        <div class="episode-card-meta">
          <span>${fmt(ep.duration)}</span>
          ${pr > 0 ? `<span>¬∑ ${Math.round((pr / ep.duration) * 100)}% played</span>` : ''}
        </div>
      </div>
    </div>`;
  };

  const renderEpisodeMasonry = ep => {
    const show = state.feeds.find(f => f.id === ep.feedId);
    const imgSrc = ep.image || show?.image || placeholderImg;
    return `<div class="episode-masonry" data-ep="${ep.id}">
      <img class="episode-masonry-art" src="${imgSrc}" onerror="this.src='${placeholderImg}'">
      <div class="episode-masonry-body">
        <div class="episode-masonry-title">${ep.title}</div>
        ${ep.desc ? `<div class="episode-masonry-desc">${ep.desc}</div>` : ''}
        <div class="episode-masonry-meta">${fmt(ep.duration)} ¬∑ ${ep.date}</div>
      </div>
    </div>`;
  };

  const renderEpisodeTable = ep => {
    const show = state.feeds.find(f => f.id === ep.feedId);
    return `<tr data-ep="${ep.id}">
      <td class="table-play"><button class="table-play-btn" data-ep="${ep.id}"><svg width="10" height="10" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg></button></td>
      <td class="table-title">${ep.title}</td>
      <td class="table-duration">${fmt(ep.duration)}</td>
      <td class="table-date">${ep.date}</td>
    </tr>`;
  };

  // Render articles content based on view mode
  const renderArticlesContent = (articles, viewMode, sourceId) => {
    if (!articles.length) return '<div class="empty"><div class="empty-icon">üì≠</div><div class="empty-title">No articles found</div></div>';

    switch (viewMode) {
      case 'cards':
        return `<div class="articles-cards">${articles.map(a => renderArticleCard(a, state.feeds.find(f => f.id === a.feedId))).join('')}</div>`;
      case 'masonry':
        return `<div class="articles-masonry">${articles.map(a => renderArticleMasonry(a, state.feeds.find(f => f.id === a.feedId))).join('')}</div>`;
      case 'table':
        return `<table class="articles-table"><thead><tr><th>Title</th><th>Source</th><th>Time</th><th></th></tr></thead><tbody>${articles.map(a => renderArticleTable(a, state.feeds.find(f => f.id === a.feedId))).join('')}</tbody></table>`;
      default: // list
        return `<div class="news-list-view">${articles.map(a => {
          const feed = state.feeds.find(f => f.id === a.feedId);
          return `<div class="article ${a.unread ? 'unread' : ''}" data-id="${a.id}"><div class="article-icon">${feed?.image ? `<img src="${feed.image}">` : 'üìÑ'}</div><div class="article-body"><div class="article-meta"><span class="article-source">${feed?.name || ''}</span><span class="article-time">¬∑ ${a.time}</span>${a.unread ? '<span class="article-new">NEW</span>' : ''}</div><div class="article-title">${a.title}</div>${a.summary ? `<div class="article-summary">${a.summary}</div>` : ''}</div>${a.image ? `<img class="article-image" src="${a.image}">` : ''}</div>`;
        }).join('')}</div>`;
    }
  };

  // Render episodes content based on view mode
  const renderEpisodesContent = (episodes, viewMode) => {
    if (!episodes.length) return '<div class="empty"><div class="empty-icon">üéß</div><div class="empty-title">No episodes found</div></div>';

    switch (viewMode) {
      case 'cards':
        return `<div class="episodes-cards">${episodes.map(renderEpisodeCard).join('')}</div>`;
      case 'masonry':
        return `<div class="episodes-masonry">${episodes.map(renderEpisodeMasonry).join('')}</div>`;
      case 'table':
        return `<table class="episodes-table"><thead><tr><th class="table-play"></th><th>Title</th><th>Duration</th><th>Date</th></tr></thead><tbody>${episodes.map(renderEpisodeTable).join('')}</tbody></table>`;
      default: // list
        return `<div class="episode-list">${episodes.map(renderEpisode).join('')}</div>`;
    }
  };

  // Render source page for news feeds
  const renderSourcePage = id => {
    const source = state.feeds.find(f => f.id === id);
    if (!source) return;
    Mem.log('feed_opened', 'source_' + id);
    state.currentSourcePage = id;

    const articles = state.articles.filter(a => a.feedId === id);
    const viewMode = getViewPref('news_' + id, 'list');

    el.newsContent.style.display = 'none';
    el.sourcePage.classList.add('active');
    renderNewsSources(); // Update active state in sidebar
    el.sourcePage.innerHTML = `
      <div class="source-hero">
        <button class="back-btn" id="sourceBackBtn"><svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 18l-6-6 6-6"/></svg> Back</button>
      </div>
      <div class="source-hero" style="padding-top:0">
        <img class="source-hero-art" src="${source.image || placeholderImg}" onerror="this.src='${placeholderImg}'">
        <div class="source-hero-info">
          <div class="source-hero-type">News Feed</div>
          <div class="source-hero-title">${source.name}</div>
          <div class="source-hero-author">${source.author || source.category || ''}</div>
        </div>
      </div>
      <div class="source-actions">
        <span style="font-size:14px;color:var(--text2)">${articles.length} articles</span>
        ${renderViewOptions('news_' + id, viewMode)}
      </div>
      <div class="source-articles">
        <div class="source-articles-content">${renderArticlesContent(articles, viewMode, id)}</div>
      </div>`;
  };

  const closeSourcePage = () => {
    state.currentSourcePage = null;
    el.sourcePage.classList.remove('active');
    el.newsContent.style.display = 'flex';
    renderNewsSources(); // Update active state in sidebar
  };

  const renderShowPage = id => {
    const show = state.feeds.find(f => f.id === id);
    if (!show) return;
    Mem.log('feed_opened', 'source_' + id);
    state.currentShowPage = id;

    const eps = state.podcasts.filter(p => p.feedId === id);
    const viewMode = getViewPref('podcast_' + id, 'list');

    el.podcastContent.style.display = 'none';
    el.showPage.classList.add('active');
    el.showPage.innerHTML = `
      <div class="show-hero">
        <button class="back-btn" id="showBackBtn"><svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 18l-6-6 6-6"/></svg> Back</button>
      </div>
      <div class="show-hero" style="padding-top:0">
        <img class="show-hero-art" src="${show.image || placeholderImg}" onerror="this.src='${placeholderImg}'">
        <div class="show-hero-info">
          <div class="show-hero-type">Podcast</div>
          <div class="show-hero-title">${show.name}</div>
          <div class="show-hero-author">${show.author || ''}</div>
        </div>
      </div>
      <div class="show-actions">
        <button class="show-play" data-show="${id}"><svg width="22" height="22" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg></button>
        ${renderViewOptions('podcast_' + id, viewMode)}
      </div>
      <div class="show-episodes">
        <div class="show-episodes-title">Episodes</div>
        <div class="show-episodes-content">${renderEpisodesContent(eps, viewMode)}</div>
      </div>`;
  };

  const closeShowPage = () => {
    state.currentShowPage = null;
    el.showPage.classList.remove('active');
    el.podcastContent.style.display = 'block';
  };

  // === RENDER ALL ===
  const renderAllItem = (item, type) => {
    const feed = state.feeds.find(f => f.id === item.feedId);
    const icon = feed?.image ? `<img src="${feed.image}">` : (type === 'podcast' ? 'üéß' : 'üì∞');
    const summary = type === 'podcast' ? item.desc : item.summary;
    return `<div class="all-item" data-type="${type}" data-id="${item.id}">
      <div class="all-item-icon">${icon}</div>
      <div class="all-item-body">
        <div class="all-item-meta">
          <span class="all-item-type">${type}</span>
          <span>${feed?.name || ''}</span>
          <span class="all-item-time">¬∑ ${item.time || item.date}</span>
        </div>
        <div class="all-item-title">${item.title}</div>
        ${summary ? `<div class="all-item-summary">${summary}</div>` : ''}
      </div>
    </div>`;
  };

  const renderAllCard = (item, type) => {
    const feed = state.feeds.find(f => f.id === item.feedId);
    const summary = type === 'podcast' ? item.desc : item.summary;
    const image = item.image || feed?.image;
    const icon = type === 'podcast' ? 'üéß' : 'üì∞';
    return `<div class="all-card" data-type="${type}" data-id="${item.id}">
      <div class="all-card-image">${image ? `<img src="${image}" onerror="this.parentElement.innerHTML='${icon}'">` : icon}</div>
      <div class="all-card-body">
        <div class="all-card-meta">
          <span class="all-card-type">${type}</span>
          <span class="all-card-source">${feed?.name || ''}</span>
          <span class="all-card-time">¬∑ ${item.time || item.date}</span>
        </div>
        <div class="all-card-title">${item.title}</div>
        ${summary ? `<div class="all-card-summary">${summary}</div>` : ''}
      </div>
    </div>`;
  };

  const renderAllMasonry = (item, type) => {
    const feed = state.feeds.find(f => f.id === item.feedId);
    const summary = type === 'podcast' ? item.desc : item.summary;
    const image = item.image || feed?.image;
    return `<div class="all-masonry-item" data-type="${type}" data-id="${item.id}">
      ${image ? `<img class="all-masonry-image" src="${image}" onerror="this.style.display='none'">` : ''}
      <div class="all-masonry-body">
        <div class="all-masonry-meta">
          <span class="all-masonry-type">${type}</span>
          <span class="all-masonry-source">${feed?.name || ''}</span>
          <span class="all-masonry-time">¬∑ ${item.time || item.date}</span>
        </div>
        <div class="all-masonry-title">${item.title}</div>
        ${summary ? `<div class="all-masonry-summary">${summary}</div>` : ''}
      </div>
    </div>`;
  };

  const renderAllTable = (item, type) => {
    const feed = state.feeds.find(f => f.id === item.feedId);
    return `<tr data-type="${type}" data-id="${item.id}">
      <td><span class="table-type">${type}</span></td>
      <td class="table-title">${item.title}</td>
      <td class="table-source">${feed?.name || ''}</td>
      <td class="table-time">${item.time || item.date}</td>
    </tr>`;
  };

  const renderAllContent = (items, viewMode) => {
    if (!items.length) return '';
    switch (viewMode) {
      case 'cards':
        return `<div class="all-cards">${items.map(item => renderAllCard(item, item.type)).join('')}</div>`;
      case 'masonry':
        return `<div class="all-masonry">${items.map(item => renderAllMasonry(item, item.type)).join('')}</div>`;
      case 'table':
        return `<table class="all-table"><thead><tr><th>Type</th><th>Title</th><th>Source</th><th>Time</th></tr></thead><tbody>${items.map(item => renderAllTable(item, item.type)).join('')}</tbody></table>`;
      default: // list
        return `<div class="all-feed-list">${items.map(item => renderAllItem(item, item.type)).join('')}</div>`;
    }
  };

  const renderAll = () => {
    const articles = state.articles.map(a => ({ ...a, sortDate: new Date(a.pubDate), type: 'news' }));
    const episodes = state.podcasts.map(p => ({ ...p, sortDate: new Date(p.pubDate), type: 'podcast' }));

    // Combine and sort by date
    let allItems = [...articles, ...episodes].sort((a, b) => b.sortDate - a.sortDate);

    // Apply search filter if present
    if (state.query) {
      allItems = fuzzy(state.query, allItems, ['title', 'summary', 'desc']);
    }

    if (!allItems.length) {
      const hasFeeds = state.feeds.length > 0;
      el.allContent.innerHTML = hasFeeds
        ? '<div class="empty"><div class="empty-icon">üì≠</div><div class="empty-title">No content found</div><div style="color:var(--text3);margin-top:8px">Try refreshing your feeds</div></div>'
        : '<div class="empty"><div class="empty-icon">üì°</div><div class="empty-title">No feeds yet</div><div style="color:var(--text3);margin-top:8px">Click + to add your first feed</div></div>';
      return;
    }

    const viewMode = getViewPref('all', 'list');
    el.allContent.innerHTML = `
      <div class="all-section">
        <div class="all-section-header">
          <div class="all-section-title">üìö All Content</div>
          ${renderViewOptions('all', viewMode)}
        </div>
        ${renderAllContent(allItems.slice(0, 50), viewMode)}
      </div>
    `;
  };

  // Handle clicks in all view
  el.allContent.onclick = e => {
    // View options
    const viewBtn = e.target.closest('.view-btn');
    if (viewBtn) {
      const newView = viewBtn.dataset.view;
      setViewPref('all', newView);
      renderAll();
      return;
    }

    // Handle all view types (list, card, masonry, table row)
    const item = e.target.closest('.all-item, .all-card, .all-masonry-item, tr[data-type]');
    if (!item) return;
    const type = item.dataset.type;
    const id = parseInt(item.dataset.id);
    if (type === 'podcast') {
      playEp(id);
    } else if (type === 'news') {
      const art = state.articles.find(a => a.id === id);
      if (art) {
        Mem.log('article_opened', 'art_' + id, { source: art.feedId });
        if (art.link) window.open(art.link, '_blank');
      }
    }
  };

  // === PLAYER ===
  const updatePlayer = () => {
    if (!state.currentEp) { el.player.classList.remove('active'); return; }
    const ep = state.currentEp, show = state.feeds.find(f => f.id === ep.feedId);
    const pr = state.progress[ep.id] || 0, pct = ep.duration ? (pr / ep.duration) * 100 : 0;
    el.player.classList.add('active');
    const artSrc = ep.image || show?.image || placeholderImg;
    el.playerArt.src = artSrc;
    el.playerArt.onerror = () => { el.playerArt.src = placeholderImg; };
    el.expArt.src = artSrc;
    el.expArt.onerror = () => { el.expArt.src = placeholderImg; };
    el.playerTitle.textContent = ep.title;
    el.playerShow.textContent = show?.name || '';
    el.expTitle.textContent = ep.title;
    el.expShow.textContent = show?.name || '';
    el.pCur.textContent = fmt(pr);
    el.pDur.textContent = fmt(ep.duration);
    el.expCur.textContent = fmt(pr);
    el.expDur.textContent = fmt(ep.duration);
    el.pFill.style.width = pct + '%';
    el.expFill.style.width = pct + '%';
    const icon = state.playing ? '<rect x="6" y="4" width="4" height="16" rx="1"/><rect x="14" y="4" width="4" height="16" rx="1"/>' : '<path d="M8 5v14l11-7z"/>';
    el.pPlayIcon.innerHTML = icon;
    el.expPlayIcon.innerHTML = icon;
    el.pSpeed.textContent = state.speed + 'x';
  };
  
  let progStart = 0;

  // Audio event handlers
  el.audio.addEventListener('timeupdate', () => {
    if (!state.currentEp) return;
    const cur = el.audio.currentTime;
    state.progress[state.currentEp.id] = cur;

    // Log progress every 30 seconds
    if (cur - progStart >= 30) {
      Mem.log('playback_progress', 'ep_' + state.currentEp.id, { from: progStart, to: cur });
      progStart = cur;
    }
    updatePlayer();
  });

  el.audio.addEventListener('ended', () => {
    if (state.currentEp) {
      Mem.log('episode_completed', 'ep_' + state.currentEp.id);
      state.progress[state.currentEp.id] = state.currentEp.duration;
    }
    state.playing = false;
    save();
    updatePlayer();
  });

  el.audio.addEventListener('pause', () => {
    state.playing = false;
    updatePlayer();
  });

  el.audio.addEventListener('play', () => {
    state.playing = true;
    updatePlayer();
  });

  el.audio.addEventListener('loadedmetadata', () => {
    if (state.currentEp) {
      // Update duration from audio if available
      if (el.audio.duration && !isNaN(el.audio.duration)) {
        state.currentEp.duration = el.audio.duration;
      }
      // Seek to saved position
      const savedPos = state.progress[state.currentEp.id] || 0;
      if (savedPos > 0 && savedPos < el.audio.duration) {
        el.audio.currentTime = savedPos;
      }
    }
    updatePlayer();
  });

  el.audio.addEventListener('error', (e) => {
    console.error('Audio error:', e);
    toast('Error loading audio. Try again.');
    state.playing = false;
    updatePlayer();
  });

  // Save progress periodically
  setInterval(() => {
    if (state.currentEp && state.playing) {
      save();
    }
  }, 10000);

  // Track current blob URL for cleanup
  let currentBlobUrl = null;

  const playEp = async id => {
    const ep = state.podcasts.find(p => p.id === id);
    if (!ep) return;
    if (!ep.audioUrl) {
      toast('No audio URL for this episode');
      return;
    }

    if (state.currentEp && state.currentEp.id !== id) {
      Mem.log('episode_exited', 'ep_' + state.currentEp.id, { pos: state.progress[state.currentEp.id] || 0 });
    }

    state.currentEp = ep;
    const pr = state.progress[id] || 0;
    if (pr > 0) Mem.log('returned_to_episode', 'ep_' + id, { prev_pos: pr });
    Mem.log('play_pressed', 'ep_' + id, { pos: pr });

    progStart = pr;

    // Clean up previous blob URL
    if (currentBlobUrl) {
      URL.revokeObjectURL(currentBlobUrl);
      currentBlobUrl = null;
    }

    // Check if episode is downloaded and use local content
    let audioSrc = ep.audioUrl;
    if (ep.downloaded) {
      try {
        const downloaded = await DownloadDB.get(id);
        if (downloaded && downloaded.blob) {
          currentBlobUrl = URL.createObjectURL(downloaded.blob);
          audioSrc = currentBlobUrl;
          console.log('Playing from downloaded content');
        }
      } catch (e) {
        console.warn('Failed to load downloaded content, falling back to stream:', e);
      }
    }

    // Set audio source and play
    if (el.audio.src !== audioSrc) {
      el.audio.src = audioSrc;
      el.audio.load();
    }
    el.audio.playbackRate = state.speed;
    el.audio.play().catch(e => {
      console.error('Playback failed:', e);
      toast('Playback failed. Check audio source.');
    });

    state.playing = true;
    updatePlayer();
  };

  const togglePlay = () => {
    if (!state.currentEp) return;
    const pr = state.progress[state.currentEp.id] || 0;

    if (state.playing) {
      el.audio.pause();
      Mem.log('pause_pressed', 'ep_' + state.currentEp.id, { pos: pr });
    } else {
      el.audio.play().catch(e => {
        console.error('Playback failed:', e);
        toast('Playback failed');
      });
      Mem.log('play_pressed', 'ep_' + state.currentEp.id, { pos: pr });
    }
  };

  const seekTo = pos => {
    if (!state.currentEp) return;
    const prev = state.progress[state.currentEp.id] || 0;
    const duration = el.audio.duration || state.currentEp.duration;
    const p = Math.max(0, Math.min(duration, pos));
    Mem.log('seek', 'ep_' + state.currentEp.id, { from: prev, to: p });
    el.audio.currentTime = p;
    state.progress[state.currentEp.id] = p;
    save();
    updatePlayer();
  };

  const skip = s => {
    if (state.currentEp) {
      seekTo(el.audio.currentTime + s);
    }
  };

  const cycleSpeed = () => {
    const sp = [0.5, 0.75, 1, 1.25, 1.5, 1.75, 2];
    const i = sp.indexOf(state.speed);
    const prev = state.speed;
    state.speed = sp[(i + 1) % sp.length];
    el.audio.playbackRate = state.speed;
    Mem.log('speed_changed', 'settings', { speed: state.speed, prev });
    updatePlayer();
  };

  // === SWIPE SEEKING ===
  // Swipe on cover art to seek: right = rewind, left = forward
  // Short swipe = 5s, medium = 15s, long = 30s, very long = 60s
  const swipeState = {
    active: false,
    startX: 0,
    startY: 0,
    currentX: 0,
    seekAmount: 0
  };

  const getSeekAmount = (distance) => {
    const absDistance = Math.abs(distance);
    if (absDistance < 30) return 0;      // Dead zone
    if (absDistance < 80) return 5;      // Short swipe: 5s
    if (absDistance < 150) return 15;    // Medium swipe: 15s
    if (absDistance < 250) return 30;    // Long swipe: 30s
    return 60;                            // Very long swipe: 60s
  };

  const triggerHaptic = (intensity = 'light') => {
    if ('vibrate' in navigator) {
      const patterns = { light: 10, medium: 25, heavy: 50 };
      navigator.vibrate(patterns[intensity] || 10);
    }
  };

  const updateSwipeIndicator = (distance, seekAmount) => {
    if (!el.swipeIndicator) return;

    const isRewind = distance > 0;  // Right swipe = rewind

    el.swipeIndicator.classList.toggle('active', seekAmount > 0);
    el.swipeIndicator.classList.toggle('rewind', isRewind);
    el.swipeIndicator.classList.toggle('forward', !isRewind);

    if (seekAmount > 0) {
      el.swipeIcon.textContent = isRewind ? '‚è™' : '‚è©';
      el.swipeText.textContent = (isRewind ? '-' : '+') + seekAmount + 's';
      el.swipeLabel.textContent = isRewind ? 'Rewind' : 'Forward';
    }
  };

  const handleSwipeStart = (e) => {
    if (!state.currentEp) return;

    const touch = e.touches ? e.touches[0] : e;
    swipeState.active = true;
    swipeState.startX = touch.clientX;
    swipeState.startY = touch.clientY;
    swipeState.currentX = touch.clientX;
    swipeState.seekAmount = 0;
  };

  const handleSwipeMove = (e) => {
    if (!swipeState.active || !state.currentEp) return;

    const touch = e.touches ? e.touches[0] : e;
    const deltaX = touch.clientX - swipeState.startX;
    const deltaY = touch.clientY - swipeState.startY;

    // Ignore if vertical swipe is dominant (allow scrolling)
    if (Math.abs(deltaY) > Math.abs(deltaX) * 1.5) return;

    // Prevent default to stop scrolling during horizontal swipe
    if (Math.abs(deltaX) > 20) {
      e.preventDefault();
    }

    swipeState.currentX = touch.clientX;
    const newSeekAmount = getSeekAmount(deltaX);

    // Haptic feedback when crossing thresholds
    if (newSeekAmount !== swipeState.seekAmount && newSeekAmount > 0) {
      triggerHaptic(newSeekAmount >= 30 ? 'medium' : 'light');
    }

    swipeState.seekAmount = newSeekAmount;
    updateSwipeIndicator(deltaX, newSeekAmount);
  };

  const handleSwipeEnd = (e) => {
    if (!swipeState.active) return;

    const deltaX = swipeState.currentX - swipeState.startX;
    const seekAmount = swipeState.seekAmount;

    if (seekAmount > 0 && state.currentEp) {
      const direction = deltaX > 0 ? -1 : 1;  // Right = rewind (negative), Left = forward (positive)
      const seekSeconds = direction * seekAmount;

      skip(seekSeconds);
      triggerHaptic('medium');
      Mem.log('swipe_seek', 'ep_' + state.currentEp.id, {
        direction: deltaX > 0 ? 'rewind' : 'forward',
        amount: seekAmount,
        swipeDistance: Math.abs(deltaX)
      });
    }

    // Reset state
    swipeState.active = false;
    swipeState.seekAmount = 0;
    updateSwipeIndicator(0, 0);
  };

  // Attach swipe handlers to the artwork container
  if (el.swipeContainer) {
    el.swipeContainer.addEventListener('touchstart', handleSwipeStart, { passive: true });
    el.swipeContainer.addEventListener('touchmove', handleSwipeMove, { passive: false });
    el.swipeContainer.addEventListener('touchend', handleSwipeEnd, { passive: true });
    el.swipeContainer.addEventListener('touchcancel', handleSwipeEnd, { passive: true });

    // Mouse support for desktop testing
    el.swipeContainer.addEventListener('mousedown', handleSwipeStart);
    el.swipeContainer.addEventListener('mousemove', (e) => {
      if (swipeState.active) handleSwipeMove(e);
    });
    el.swipeContainer.addEventListener('mouseup', handleSwipeEnd);
    el.swipeContainer.addEventListener('mouseleave', handleSwipeEnd);
  }

  // === EVENTS ===
  document.querySelector('.main-toggle').onclick = e => {
    const btn = e.target.closest('.toggle-btn');
    if (!btn) return;
    document.querySelectorAll('.toggle-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    const prev = state.view;
    state.view = btn.dataset.view;
    Mem.log('view_changed', 'view_' + state.view, { prev });
    el.newsView.classList.toggle('active', state.view === 'news');
    el.podcastView.classList.toggle('active', state.view === 'podcasts');
    el.allView.classList.toggle('active', state.view === 'all');
    if (state.view === 'podcasts') renderPodcasts();
    if (state.view === 'all') renderAll();
    save();
  };
  
  el.newsSources.onclick = e => {
    const src = e.target.closest('.source-item');
    if (!src) return;
    const id = src.dataset.id;
    if (id === 'all') {
      state.selectedSource = null;
      el.newsTitle.textContent = 'All Articles';
      renderNewsSources(); renderNews();
    } else {
      // Open source page for individual sources
      renderSourcePage(parseInt(id));
    }
  };
  
  el.categoryChips.onclick = e => {
    const chip = e.target.closest('.chip');
    if (!chip) return;
    const prev = state.selectedCat;
    state.selectedCat = chip.dataset.cat;
    Mem.log('category_changed', 'cat_' + state.selectedCat, { prev });
    renderCategories(); renderNews();
  };
  
  el.newsList.onclick = e => {
    // Source name click - navigate to source page
    const sourceEl = e.target.closest('.article-source');
    if (sourceEl) {
      const item = e.target.closest('.article');
      if (item) {
        const id = parseInt(item.dataset.id);
        const art = state.articles.find(a => a.id === id);
        if (art && art.feedId) {
          renderSourcePage(art.feedId);
          return;
        }
      }
    }

    const item = e.target.closest('.article');
    if (!item) return;
    const id = parseInt(item.dataset.id);
    const art = state.articles.find(a => a.id === id);
    if (art) {
      Mem.log('article_opened', 'art_' + id, { source: art.feedId });
      art.unread = false;
      save();
      if (art.link) window.open(art.link, '_blank');
      renderNews();
    }
  };

  // Source page event handlers
  el.sourcePage.onclick = e => {
    // Back button
    const backBtn = e.target.closest('#sourceBackBtn');
    if (backBtn) {
      closeSourcePage();
      return;
    }

    // View options
    const viewBtn = e.target.closest('.view-btn');
    if (viewBtn) {
      const sourceKey = viewBtn.closest('.view-options').dataset.source;
      const newView = viewBtn.dataset.view;
      setViewPref(sourceKey, newView);
      if (state.currentSourcePage) renderSourcePage(state.currentSourcePage);
      return;
    }

    // Article clicks (all view modes)
    const articleEl = e.target.closest('.article, .article-card, .article-masonry, [data-id]');
    if (articleEl && articleEl.dataset.id) {
      const id = parseInt(articleEl.dataset.id);
      const art = state.articles.find(a => a.id === id);
      if (art) {
        Mem.log('article_opened', 'art_' + id, { source: art.feedId });
        art.unread = false;
        save();
        if (art.link) window.open(art.link, '_blank');
        if (state.currentSourcePage) renderSourcePage(state.currentSourcePage);
      }
      return;
    }

    // Table row clicks
    const tableRow = e.target.closest('tr[data-id]');
    if (tableRow) {
      const id = parseInt(tableRow.dataset.id);
      const art = state.articles.find(a => a.id === id);
      if (art) {
        Mem.log('article_opened', 'art_' + id, { source: art.feedId });
        art.unread = false;
        save();
        if (art.link) window.open(art.link, '_blank');
        if (state.currentSourcePage) renderSourcePage(state.currentSourcePage);
      }
    }
  };

  document.querySelector('.podcast-nav').onclick = e => {
    const btn = e.target.closest('.nav-btn');
    if (!btn) return;
    document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    state.tab = btn.dataset.tab;
    closeShowPage(); // Close show page and reset state
    renderPodcasts();
  };
  
  el.podcastContent.onclick = e => {
    // Show card click
    const card = e.target.closest('.show-card');
    if (card) { renderShowPage(parseInt(card.dataset.show)); return; }

    // Show name click in episode - navigate to show page
    const showNameEl = e.target.closest('.episode-show');
    if (showNameEl) {
      const epEl = e.target.closest('.episode, .episode-card, .episode-masonry, tr[data-ep]');
      if (epEl && epEl.dataset.ep) {
        const ep = state.podcasts.find(p => p.id === parseInt(epEl.dataset.ep));
        if (ep && ep.feedId) {
          renderShowPage(ep.feedId);
          return;
        }
      }
    }

    // Play button (list/table view)
    const playBtn = e.target.closest('.ep-play, .table-play-btn');
    if (playBtn) { playEp(parseInt(playBtn.dataset.ep)); return; }

    // Download button
    const dl = e.target.closest('.ep-dl');
    if (dl) {
      const id = parseInt(dl.dataset.dl);
      const p = state.podcasts.find(x => x.id === id);
      if (p) {
        if (p.downloaded) {
          removeDownload(id);
        } else {
          startDownload(id);
        }
      }
      return;
    }

    // Episode clicks (all view modes - list, card, masonry, table row)
    const epEl = e.target.closest('.episode, .episode-card, .episode-masonry, tr[data-ep]');
    if (epEl && epEl.dataset.ep) {
      playEp(parseInt(epEl.dataset.ep));
    }
  };
  
  el.showPage.onclick = e => {
    // Back button
    const backBtn = e.target.closest('#showBackBtn');
    if (backBtn) {
      closeShowPage();
      return;
    }

    // View options
    const viewBtn = e.target.closest('.view-btn');
    if (viewBtn) {
      const sourceKey = viewBtn.closest('.view-options').dataset.source;
      const newView = viewBtn.dataset.view;
      setViewPref(sourceKey, newView);
      if (state.currentShowPage) renderShowPage(state.currentShowPage);
      return;
    }

    // Play button (list view)
    const playBtn = e.target.closest('.ep-play, .table-play-btn');
    if (playBtn) { playEp(parseInt(playBtn.dataset.ep)); return; }

    // Show play button
    const showPlay = e.target.closest('.show-play');
    if (showPlay) { const eps = state.podcasts.filter(p => p.feedId === parseInt(showPlay.dataset.show)); if (eps.length) playEp(eps[0].id); return; }

    // Download button
    const dl = e.target.closest('.ep-dl');
    if (dl) {
      const id = parseInt(dl.dataset.dl);
      const p = state.podcasts.find(x => x.id === id);
      if (p) {
        if (p.downloaded) {
          removeDownload(id);
        } else {
          startDownload(id);
        }
      }
      return;
    }

    // Episode clicks (all view modes - list, card, masonry, table row)
    const epEl = e.target.closest('.episode, .episode-card, .episode-masonry, tr[data-ep]');
    if (epEl && epEl.dataset.ep) {
      playEp(parseInt(epEl.dataset.ep));
    }
  };
  
  el.pPlay.onclick = togglePlay;
  el.expPlay.onclick = togglePlay;
  el.pSpeed.onclick = cycleSpeed;
  $('pSkipBack').onclick = () => skip(-15);
  $('pSkipFwd').onclick = () => skip(30);
  $('expBack').onclick = () => skip(-15);
  $('expFwd').onclick = () => skip(30);
  el.pBar.onclick = e => { if (!state.currentEp) return; const r = el.pBar.getBoundingClientRect(); seekTo((e.clientX - r.left) / r.width * state.currentEp.duration); };
  el.expBar.onclick = e => { if (!state.currentEp) return; const r = el.expBar.getBoundingClientRect(); seekTo((e.clientX - r.left) / r.width * state.currentEp.duration); };
  $('pExpand').onclick = () => el.expanded.classList.add('active');
  $('expClose').onclick = () => el.expanded.classList.remove('active');
  el.playerArt.onclick = () => el.expanded.classList.add('active');
  
  $('refreshBtn').onclick = () => refreshAllFeeds();
  $('addBtn').onclick = () => el.modal.classList.add('active');
  $('addNewsBtn').onclick = () => { $('tNews').click(); el.modal.classList.add('active'); };
  $('modalClose').onclick = () => el.modal.classList.remove('active');
  el.modal.onclick = e => { if (e.target === el.modal) el.modal.classList.remove('active'); };
  $('tNews').onclick = () => { state.feedType = 'news'; $('tNews').classList.add('active'); $('tPodcast').classList.remove('active'); };
  $('tPodcast').onclick = () => { state.feedType = 'podcast'; $('tPodcast').classList.add('active'); $('tNews').classList.remove('active'); };

  // Form validation and state
  let metadataFetched = false;
  const validateForm = () => {
    const hasUrl = el.fUrl.value.trim().length > 0;
    el.fFetch.disabled = !hasUrl;
    el.fSubmit.disabled = !hasUrl;
  };

  const setFetchStatus = (message, type) => {
    el.fStatus.textContent = message;
    el.fStatus.className = 'fetch-status ' + (type || '');
  };

  const setFormDisabled = (disabled) => {
    el.fUrl.disabled = disabled;
    el.fName.disabled = disabled;
    el.fAuthor.disabled = disabled;
    el.fCat.disabled = disabled;
    el.fFetch.disabled = disabled;
  };

  // Fetch metadata when button is clicked
  el.fFetch.onclick = async () => {
    const url = el.fUrl.value.trim();
    if (!url) return;

    // Show loading state
    el.fFetch.disabled = true;
    el.fFetch.textContent = 'Fetching...';
    el.fFetch.classList.add('loading');
    setFetchStatus('Fetching feed metadata...', 'loading');

    const result = await fetchFeedMetadata(url);

    el.fFetch.textContent = 'Fetch';
    el.fFetch.classList.remove('loading');
    el.fFetch.disabled = false;

    if (result.success) {
      // Pre-populate form fields with fetched metadata
      if (result.title && !el.fName.value.trim()) {
        el.fName.value = result.title;
      }
      if (result.author && !el.fAuthor.value.trim()) {
        el.fAuthor.value = result.author;
      }

      // Auto-select feed type based on content
      if (result.suggestedType === 'podcast') {
        state.feedType = 'podcast';
        $('tPodcast').classList.add('active');
        $('tNews').classList.remove('active');
      } else {
        state.feedType = 'news';
        $('tNews').classList.add('active');
        $('tPodcast').classList.remove('active');
      }

      metadataFetched = true;
      setFetchStatus('Metadata loaded! You can edit the fields below.', 'success');
    } else {
      setFetchStatus('Failed to fetch: ' + (result.error || 'Unknown error'), 'error');
    }
  };

  // Also fetch on URL blur if we haven't fetched yet
  el.fUrl.onblur = () => {
    const url = el.fUrl.value.trim();
    if (url && !metadataFetched && url.startsWith('http')) {
      el.fFetch.click();
    }
  };

  el.fUrl.oninput = () => {
    metadataFetched = false; // Reset when URL changes
    setFetchStatus('', '');
    validateForm();
  };
  el.fName.oninput = validateForm;
  el.fAuthor.oninput = validateForm;

  el.fSubmit.onclick = async () => {
    const url = el.fUrl.value.trim();
    const name = el.fName.value.trim();
    const author = el.fAuthor.value.trim();
    const cat = el.fCat.value.trim() || 'Uncategorized';
    if (!url) return;

    // Disable form while adding
    el.fSubmit.disabled = true;
    el.fSubmit.textContent = 'Adding...';
    setFormDisabled(true);

    await addFeed(url, name, state.feedType, cat, author);

    // Reset form
    el.fUrl.value = '';
    el.fName.value = '';
    el.fAuthor.value = '';
    el.fCat.value = '';
    el.fSubmit.textContent = 'Add Feed';
    el.fSubmit.disabled = true;
    setFormDisabled(false);
    setFetchStatus('', '');
    metadataFetched = false;
    el.modal.classList.remove('active');
  };
  
  let searchTO;
  el.searchInput.oninput = e => { clearTimeout(searchTO); searchTO = setTimeout(() => { state.query = e.target.value; if (state.view === 'news') renderNews(); if (state.view === 'all') renderAll(); }, 200); };
  
  document.onkeydown = e => { if (e.target.tagName === 'INPUT') return; if (e.code === 'Space') { e.preventDefault(); togglePlay(); } if (e.code === 'ArrowLeft') skip(-15); if (e.code === 'ArrowRight') skip(30); };
  
  // === INIT ===
  const init = async () => {
    load();

    // Initialize download database
    try {
      await DownloadDB.init();
      console.log('Download database initialized');

      // Sync download state with actual IndexedDB content
      const downloadedIds = await DownloadDB.getAll();
      const downloadedSet = new Set(downloadedIds);

      // Update podcast downloaded flags based on what's actually in IndexedDB
      let syncNeeded = false;
      state.podcasts.forEach(p => {
        const actuallyDownloaded = downloadedSet.has(p.id);
        if (p.downloaded !== actuallyDownloaded) {
          p.downloaded = actuallyDownloaded;
          syncNeeded = true;
        }
      });
      if (syncNeeded) save();
    } catch (e) {
      console.error('Failed to initialize download database:', e);
    }

    // Apply saved view state
    const applyView = () => {
      // Update toggle buttons
      document.querySelectorAll('.toggle-btn').forEach(b => {
        b.classList.toggle('active', b.dataset.view === state.view);
      });
      // Update view visibility
      el.newsView.classList.toggle('active', state.view === 'news');
      el.podcastView.classList.toggle('active', state.view === 'podcasts');
      el.allView.classList.toggle('active', state.view === 'all');
    };

    applyView();
    renderNewsSources();
    renderCategories();
    renderNews();
    if (state.view === 'podcasts') renderPodcasts();
    if (state.view === 'all') renderAll();

    console.log('Feedr loaded');
    console.log('Memory API: Memory.setEndpoint(url), Memory.getLocal()');
  };

  init();
})();
</script>
</body>
</html>
