<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Feedr</title>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    :root {
      --bg: #0a0a0a; --bg2: #111; --bg3: #1a1a1a; --bg4: #1f1f1f;
      --border: #1f1f1f; --border2: #333;
      --text: #e5e5e5; --text2: #a0a0a0; --text3: #666;
      --green: #1db954; --green2: #1ed760;
    }
    html, body { height: 100%; }
    body { font-family: 'IBM Plex Sans', system-ui, sans-serif; background: var(--bg); color: var(--text); overflow: hidden; }
    ::-webkit-scrollbar { width: 8px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: var(--border2); border-radius: 4px; }
    
    .app { display: flex; flex-direction: column; height: 100vh; }
    
    /* Header */
    .header { background: var(--bg); border-bottom: 1px solid var(--border); padding: 12px 16px; display: flex; align-items: center; gap: 16px; }
    .logo { font-size: 22px; font-weight: 700; }
    .main-toggle { display: flex; background: var(--bg3); border-radius: 25px; padding: 4px; }
    .toggle-btn { padding: 10px 20px; background: transparent; border: none; border-radius: 21px; color: var(--text2); font-size: 14px; font-weight: 600; cursor: pointer; font-family: inherit; display: flex; align-items: center; gap: 8px; transition: all 0.2s; }
    .toggle-btn.active { background: var(--green); color: #000; }
    .toggle-btn:not(.active):hover { background: var(--bg4); color: var(--text); }
    .spacer { flex: 1; }
    .search-box { max-width: 280px; flex: 1; position: relative; }
    .search-box input { width: 100%; padding: 10px 16px 10px 38px; background: var(--bg3); border: 1px solid var(--border2); border-radius: 20px; color: var(--text); font-size: 14px; font-family: inherit; }
    .search-box input:focus { outline: none; border-color: var(--green); }
    .search-box input::placeholder { color: var(--text3); }
    .search-box svg { position: absolute; left: 12px; top: 50%; transform: translateY(-50%); color: var(--text3); }
    .icon-btn { background: none; border: none; color: var(--text2); cursor: pointer; padding: 10px; border-radius: 50%; transition: all 0.2s; display: flex; align-items: center; justify-content: center; }
    .icon-btn:hover { background: var(--bg4); color: var(--text); }
    
    /* Main */
    .main { flex: 1; overflow: hidden; }
    
    /* === NEWS VIEW === */
    .news-view { display: none; height: 100%; }
    .news-view.active { display: flex; }
    
    .news-sidebar { width: 240px; background: var(--bg2); border-right: 1px solid var(--border); display: flex; flex-direction: column; }
    .sidebar-header { padding: 14px 16px; border-bottom: 1px solid var(--border); display: flex; align-items: center; justify-content: space-between; }
    .sidebar-header h2 { font-size: 12px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text2); }
    .add-btn { background: var(--green); border: none; color: #000; width: 24px; height: 24px; border-radius: 50%; cursor: pointer; font-size: 16px; }
    .sidebar-content { flex: 1; overflow-y: auto; padding: 8px; }
    
    .source-item { display: flex; align-items: center; gap: 10px; padding: 10px; border-radius: 8px; cursor: pointer; margin-bottom: 2px; transition: background 0.15s; }
    .source-item:hover { background: var(--bg3); }
    .source-item.active { background: var(--bg4); }
    .source-icon { width: 32px; height: 32px; border-radius: 6px; background: var(--bg3); display: flex; align-items: center; justify-content: center; font-size: 16px; overflow: hidden; }
    .source-icon img { width: 100%; height: 100%; object-fit: cover; }
    .source-name { flex: 1; font-size: 14px; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .source-badge { background: var(--green); color: #000; font-size: 10px; font-weight: 700; padding: 2px 6px; border-radius: 10px; }
    
    .news-content { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
    .news-header { padding: 12px 16px; border-bottom: 1px solid var(--border); display: flex; align-items: center; gap: 12px; }
    .news-title { font-size: 18px; font-weight: 600; margin-right: 16px; }
    .category-chips { display: flex; gap: 8px; overflow-x: auto; flex: 1; }
    .chip { padding: 6px 14px; background: var(--bg3); border: 1px solid var(--border2); border-radius: 16px; color: var(--text2); font-size: 12px; font-weight: 500; cursor: pointer; white-space: nowrap; font-family: inherit; transition: all 0.15s; }
    .chip:hover { background: var(--bg4); color: var(--text); }
    .chip.active { background: var(--green); border-color: var(--green); color: #000; }
    
    .news-list { flex: 1; overflow-y: auto; padding: 12px 16px 100px; }
    .article { display: flex; gap: 14px; padding: 14px; background: var(--bg2); border-radius: 10px; margin-bottom: 8px; cursor: pointer; border: 1px solid transparent; transition: all 0.15s; }
    .article:hover { background: var(--bg3); border-color: var(--border2); }
    .article.unread { border-left: 3px solid var(--green); }
    .article-icon { width: 40px; height: 40px; border-radius: 8px; background: var(--bg3); display: flex; align-items: center; justify-content: center; font-size: 20px; overflow: hidden; flex-shrink: 0; }
    .article-icon img { width: 100%; height: 100%; object-fit: cover; }
    .article-body { flex: 1; min-width: 0; }
    .article-meta { display: flex; align-items: center; gap: 8px; margin-bottom: 4px; font-size: 12px; }
    .article-source { color: var(--green); font-weight: 500; }
    .article-time { color: var(--text3); }
    .article-new { color: var(--green); font-weight: 600; font-size: 10px; }
    .article-title { font-size: 15px; font-weight: 500; line-height: 1.4; margin-bottom: 4px; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
    .article-summary { font-size: 13px; color: var(--text2); line-height: 1.4; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
    .article-image { width: 100px; height: 70px; border-radius: 6px; object-fit: cover; flex-shrink: 0; }
    
    /* === PODCAST VIEW === */
    .podcast-view { display: none; height: 100%; flex-direction: column; }
    .podcast-view.active { display: flex; }
    
    .podcast-nav { display: flex; background: var(--bg2); border-bottom: 1px solid var(--border); padding: 0 16px; }
    .nav-btn { padding: 14px 18px; background: none; border: none; border-bottom: 2px solid transparent; color: var(--text2); font-size: 14px; font-weight: 500; cursor: pointer; font-family: inherit; transition: all 0.15s; }
    .nav-btn:hover { color: var(--text); }
    .nav-btn.active { color: var(--green); border-bottom-color: var(--green); }
    
    .podcast-content { flex: 1; overflow-y: auto; padding: 20px; padding-bottom: 120px; }
    
    .section { margin-bottom: 28px; }
    .section-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 14px; }
    .section-title { font-size: 18px; font-weight: 600; }
    
    .shows-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(130px, 1fr)); gap: 16px; }
    .show-card { cursor: pointer; transition: transform 0.15s; }
    .show-card:hover { transform: translateY(-4px); }
    .show-art { width: 100%; aspect-ratio: 1; border-radius: 8px; object-fit: cover; margin-bottom: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
    .show-name { font-size: 14px; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .show-author { font-size: 12px; color: var(--text3); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    
    .episode-list { display: flex; flex-direction: column; gap: 8px; }
    .episode { display: flex; gap: 12px; padding: 12px; background: var(--bg2); border-radius: 10px; cursor: pointer; transition: background 0.15s; }
    .episode:hover { background: var(--bg3); }
    .episode-art { width: 64px; height: 64px; border-radius: 6px; object-fit: cover; flex-shrink: 0; }
    .episode-body { flex: 1; min-width: 0; display: flex; flex-direction: column; justify-content: center; }
    .episode-show { font-size: 12px; color: var(--green); font-weight: 500; margin-bottom: 2px; }
    .episode-title { font-size: 14px; font-weight: 500; margin-bottom: 6px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .episode-footer { display: flex; align-items: center; gap: 10px; }
    .ep-play { width: 28px; height: 28px; border-radius: 50%; background: var(--text); border: none; color: var(--bg); cursor: pointer; display: flex; align-items: center; justify-content: center; flex-shrink: 0; }
    .ep-play:hover { background: var(--green); }
    .ep-progress { flex: 1; display: flex; align-items: center; gap: 8px; }
    .ep-bar { flex: 1; height: 4px; background: var(--border2); border-radius: 2px; overflow: hidden; }
    .ep-fill { height: 100%; background: var(--green); }
    .ep-time { font-size: 11px; color: var(--text3); white-space: nowrap; }
    .ep-dl { background: none; border: none; color: var(--text3); cursor: pointer; padding: 4px; }
    .ep-dl:hover { color: var(--text); }
    .ep-dl.active { color: var(--green); }
    
    /* Show Page */
    .show-page { display: none; }
    .show-page.active { display: block; }
    .show-hero { padding: 28px; background: linear-gradient(180deg, #1a1a3a 0%, var(--bg) 100%); display: flex; gap: 24px; align-items: flex-end; }
    .show-hero-art { width: 180px; height: 180px; border-radius: 10px; object-fit: cover; box-shadow: 0 8px 24px rgba(0,0,0,0.4); }
    .show-hero-info { flex: 1; }
    .show-hero-type { font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 1px; color: var(--text2); margin-bottom: 6px; }
    .show-hero-title { font-size: 36px; font-weight: 700; line-height: 1.1; margin-bottom: 10px; }
    .show-hero-author { font-size: 14px; color: var(--text2); }
    .show-actions { padding: 16px 28px; display: flex; gap: 12px; }
    .show-play { width: 48px; height: 48px; border-radius: 50%; background: var(--green); border: none; color: #000; cursor: pointer; display: flex; align-items: center; justify-content: center; }
    .show-play:hover { transform: scale(1.05); }
    .show-episodes { padding: 0 28px 120px; }
    .show-episodes-title { font-size: 18px; font-weight: 600; margin-bottom: 14px; }
    
    /* === PLAYER === */
    .player { position: fixed; bottom: 0; left: 0; right: 0; height: 76px; background: var(--bg2); border-top: 1px solid var(--border); display: none; align-items: center; padding: 0 16px; z-index: 100; }
    .player.active { display: flex; }
    .player-left { display: flex; align-items: center; gap: 12px; width: 25%; min-width: 160px; }
    .player-art { width: 52px; height: 52px; border-radius: 6px; object-fit: cover; cursor: pointer; }
    .player-info { min-width: 0; }
    .player-title { font-size: 14px; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .player-show { font-size: 12px; color: var(--text2); cursor: pointer; }
    .player-show:hover { color: var(--green); text-decoration: underline; }
    .player-center { flex: 1; display: flex; flex-direction: column; align-items: center; max-width: 600px; padding: 0 20px; }
    .player-controls { display: flex; align-items: center; gap: 16px; margin-bottom: 4px; }
    .player-skip { background: none; border: none; color: var(--text); cursor: pointer; font-size: 12px; font-weight: 600; padding: 6px; font-family: inherit; }
    .player-skip:hover { color: var(--green); }
    .player-play { width: 36px; height: 36px; border-radius: 50%; background: var(--text); border: none; color: var(--bg); cursor: pointer; display: flex; align-items: center; justify-content: center; }
    .player-play:hover { background: var(--green); }
    .player-progress { width: 100%; display: flex; align-items: center; gap: 8px; }
    .player-time { font-size: 11px; color: var(--text3); font-family: monospace; min-width: 40px; }
    .player-time.right { text-align: right; }
    .player-bar { flex: 1; height: 4px; background: var(--border2); border-radius: 2px; cursor: pointer; }
    .player-bar:hover { height: 6px; }
    .player-fill { height: 100%; background: var(--text); border-radius: 2px; }
    .player-bar:hover .player-fill { background: var(--green); }
    .player-right { display: flex; align-items: center; gap: 10px; width: 25%; justify-content: flex-end; }
    .speed-btn { font-size: 12px; font-weight: 600; padding: 5px 8px; background: var(--bg3); border: 1px solid var(--border2); border-radius: 4px; color: var(--text2); cursor: pointer; font-family: inherit; }
    .speed-btn:hover { color: var(--text); border-color: var(--text); }
    
    /* Expanded Fullscreen Player - Libby-style */
    .expanded {
      position: fixed; inset: 0; z-index: 200; display: none; flex-direction: column;
      background: var(--bg);
      transition: background 0.5s ease;
    }
    .expanded.active { display: flex; }
    .expanded-bg {
      position: absolute; inset: 0;
      background: linear-gradient(180deg, var(--exp-color1, #1a1a2e) 0%, var(--exp-color2, #0a0a0a) 100%);
      opacity: 0.85;
      transition: background 0.8s ease;
    }
    .expanded-content { position: relative; z-index: 1; display: flex; flex-direction: column; height: 100%; }

    /* Top progress bar - Libby style */
    .expanded-top-progress {
      padding: 12px 20px 8px;
      display: flex; align-items: center; gap: 12px;
    }
    .expanded-top-time { font-size: 12px; font-family: monospace; color: var(--text2); min-width: 50px; }
    .expanded-top-time.right { text-align: right; }
    .expanded-top-pct {
      font-size: 11px; color: var(--text3);
      background: var(--bg3); padding: 3px 8px; border-radius: 10px;
      cursor: pointer; user-select: none;
    }
    .expanded-top-pct:active { background: var(--bg4); }
    .expanded-top-bar-wrap { flex: 1; position: relative; }
    .expanded-top-bar {
      width: 100%; height: 6px; background: rgba(255,255,255,0.1);
      border-radius: 3px; cursor: pointer; position: relative;
      transition: height 0.15s;
    }
    .expanded-top-bar:hover { height: 10px; }
    .expanded-top-fill {
      height: 100%; background: var(--green); border-radius: 3px;
      transition: width 0.1s linear;
      position: relative;
    }
    .expanded-top-fill::after {
      content: ''; position: absolute; right: -6px; top: 50%; transform: translateY(-50%);
      width: 12px; height: 12px; border-radius: 50%; background: var(--text);
      opacity: 0; transition: opacity 0.15s;
      box-shadow: 0 2px 8px rgba(0,0,0,0.4);
    }
    .expanded-top-bar:hover .expanded-top-fill::after { opacity: 1; }
    .expanded-scrub-preview {
      position: absolute; top: -36px; left: 50%; transform: translateX(-50%);
      background: var(--bg2); padding: 6px 12px; border-radius: 6px;
      font-size: 13px; font-family: monospace; color: var(--text);
      display: none; pointer-events: none; white-space: nowrap;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    }
    .expanded-scrub-preview.visible { display: block; }

    /* Bookmark markers on timeline */
    .bookmark-marker {
      position: absolute; top: -4px; width: 2px; height: 14px;
      background: var(--green2); border-radius: 1px;
      cursor: pointer; z-index: 2;
    }
    .bookmark-marker:hover { background: #fff; transform: scaleX(2); }

    /* Header with icons */
    .expanded-header {
      padding: 8px 16px; display: flex; justify-content: space-between; align-items: center;
    }
    .expanded-label { font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: var(--text3); }
    .expanded-header-icons { display: flex; gap: 4px; }
    .exp-icon-btn {
      background: none; border: none; color: var(--text2); cursor: pointer;
      padding: 10px; border-radius: 50%; transition: all 0.2s;
      display: flex; align-items: center; justify-content: center; position: relative;
    }
    .exp-icon-btn:hover { background: rgba(255,255,255,0.1); color: var(--text); }
    .exp-icon-btn.active { color: var(--green); }
    .exp-icon-btn .countdown-badge {
      position: absolute; top: 2px; right: 2px;
      font-size: 8px; font-weight: 700; background: var(--green);
      color: #000; padding: 2px 4px; border-radius: 8px;
      min-width: 16px; text-align: center;
    }

    /* Artwork area - swipeable */
    .expanded-body {
      flex: 1; display: flex; flex-direction: column; align-items: center;
      justify-content: center; padding: 20px; overflow: hidden;
    }
    .expanded-art-container {
      position: relative; width: 280px; height: 280px;
      cursor: grab; user-select: none; touch-action: pan-y;
    }
    .expanded-art-container:active { cursor: grabbing; }
    .expanded-art {
      width: 100%; height: 100%; border-radius: 12px; object-fit: cover;
      box-shadow: 0 20px 60px rgba(0,0,0,0.6);
      transition: transform 0.15s ease-out;
      pointer-events: none;
    }
    .expanded-art.swiping { transition: none; }
    .swipe-indicator {
      position: absolute; top: 50%; transform: translateY(-50%);
      font-size: 18px; font-weight: 700; color: var(--text);
      background: rgba(0,0,0,0.7); padding: 8px 14px; border-radius: 20px;
      opacity: 0; transition: opacity 0.15s;
      pointer-events: none;
    }
    .swipe-indicator.left { left: 10px; }
    .swipe-indicator.right { right: 10px; }
    .swipe-indicator.visible { opacity: 1; }

    /* Episode info */
    .expanded-info { text-align: center; margin: 24px 0 16px; max-width: 360px; padding: 0 20px; }
    .expanded-title {
      font-size: 22px; font-weight: 700; margin-bottom: 8px;
      line-height: 1.3;
      display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden;
    }
    .expanded-show { font-size: 14px; color: var(--green); cursor: pointer; }
    .expanded-show:hover { text-decoration: underline; }

    /* Main controls */
    .expanded-controls { display: flex; align-items: center; justify-content: center; gap: 20px; margin-bottom: 20px; }
    .expanded-skip-outer {
      width: 52px; height: 52px; border-radius: 50%; background: rgba(255,255,255,0.08);
      border: none; color: var(--text); cursor: pointer;
      display: flex; align-items: center; justify-content: center;
      transition: all 0.15s;
    }
    .expanded-skip-outer:hover { background: rgba(255,255,255,0.15); }
    .expanded-skip-outer:active { transform: scale(0.95); }
    .expanded-skip {
      font-size: 12px; font-weight: 700; font-family: inherit;
      background: none; border: none; color: inherit; cursor: pointer;
    }
    .expanded-play {
      width: 72px; height: 72px; border-radius: 50%; background: var(--text);
      border: none; color: var(--bg); cursor: pointer;
      display: flex; align-items: center; justify-content: center;
      transition: all 0.15s;
    }
    .expanded-play:hover { background: var(--green); transform: scale(1.05); }
    .expanded-play:active { transform: scale(0.98); }

    /* Chapter skip buttons */
    .chapter-skip {
      width: 40px; height: 40px; border-radius: 50%; background: transparent;
      border: none; color: var(--text2); cursor: pointer;
      display: flex; align-items: center; justify-content: center;
      transition: all 0.15s;
    }
    .chapter-skip:hover { color: var(--text); background: rgba(255,255,255,0.08); }

    /* Speed control slider */
    .expanded-speed-section {
      width: 100%; max-width: 320px; margin-bottom: 24px; padding: 0 20px;
    }
    .speed-control-wrap {
      display: flex; align-items: center; gap: 12px;
      background: rgba(255,255,255,0.05); border-radius: 12px; padding: 12px 16px;
    }
    .speed-icon { color: var(--text2); }
    .speed-slider-wrap { flex: 1; display: flex; flex-direction: column; gap: 4px; }
    .speed-slider {
      -webkit-appearance: none; appearance: none;
      width: 100%; height: 4px; background: var(--border2); border-radius: 2px;
      outline: none; cursor: pointer;
    }
    .speed-slider::-webkit-slider-thumb {
      -webkit-appearance: none; appearance: none;
      width: 16px; height: 16px; border-radius: 50%;
      background: var(--green); cursor: pointer;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }
    .speed-slider::-moz-range-thumb {
      width: 16px; height: 16px; border-radius: 50%;
      background: var(--green); cursor: pointer; border: none;
    }
    .speed-presets { display: flex; justify-content: space-between; }
    .speed-preset {
      font-size: 10px; color: var(--text3); background: none; border: none;
      cursor: pointer; padding: 2px 4px; border-radius: 4px;
      font-family: inherit;
    }
    .speed-preset:hover { color: var(--text); background: var(--bg3); }
    .speed-preset.active { color: var(--green); font-weight: 600; }
    .speed-value {
      font-size: 14px; font-weight: 600; color: var(--green);
      min-width: 48px; text-align: right;
    }

    /* Sleep Timer Panel */
    .sleep-panel {
      position: fixed; bottom: 0; left: 0; right: 0;
      background: var(--bg2); border-radius: 20px 20px 0 0;
      padding: 20px; z-index: 250;
      transform: translateY(100%);
      transition: transform 0.3s ease;
      max-height: 60vh; overflow-y: auto;
    }
    .sleep-panel.active { transform: translateY(0); }
    .sleep-panel-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; }
    .sleep-panel-title { font-size: 18px; font-weight: 600; }
    .sleep-options { display: flex; flex-direction: column; gap: 8px; }
    .sleep-option {
      padding: 14px 16px; background: var(--bg3); border: 2px solid transparent;
      border-radius: 12px; cursor: pointer; display: flex; justify-content: space-between;
      align-items: center; transition: all 0.15s; font-family: inherit; color: var(--text);
    }
    .sleep-option:hover { background: var(--bg4); }
    .sleep-option.active { border-color: var(--green); background: rgba(29,185,84,0.1); }
    .sleep-option-label { font-size: 15px; font-weight: 500; }
    .sleep-option-check { color: var(--green); opacity: 0; }
    .sleep-option.active .sleep-option-check { opacity: 1; }
    .sleep-custom { margin-top: 12px; display: flex; gap: 8px; }
    .sleep-custom input {
      flex: 1; padding: 12px; background: var(--bg3); border: 1px solid var(--border2);
      border-radius: 10px; color: var(--text); font-size: 14px; font-family: inherit;
    }
    .sleep-custom button {
      padding: 12px 20px; background: var(--green); border: none; border-radius: 10px;
      color: #000; font-weight: 600; cursor: pointer; font-family: inherit;
    }
    .sleep-backdrop {
      position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 249;
      opacity: 0; pointer-events: none; transition: opacity 0.3s;
    }
    .sleep-backdrop.active { opacity: 1; pointer-events: auto; }

    /* Bookmarks Panel */
    .bookmarks-panel {
      position: fixed; bottom: 0; left: 0; right: 0;
      background: var(--bg2); border-radius: 20px 20px 0 0;
      padding: 20px; z-index: 250;
      transform: translateY(100%);
      transition: transform 0.3s ease;
      max-height: 70vh; overflow-y: auto;
    }
    .bookmarks-panel.active { transform: translateY(0); }
    .bookmarks-panel-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; }
    .bookmarks-panel-title { font-size: 18px; font-weight: 600; }
    .bookmark-item {
      padding: 12px; background: var(--bg3); border-radius: 10px; margin-bottom: 8px;
      cursor: pointer; display: flex; justify-content: space-between; align-items: center;
      transition: background 0.15s;
    }
    .bookmark-item:hover { background: var(--bg4); }
    .bookmark-item-info { flex: 1; }
    .bookmark-item-time { font-size: 15px; font-weight: 600; color: var(--green); font-family: monospace; }
    .bookmark-item-note { font-size: 13px; color: var(--text2); margin-top: 4px; }
    .bookmark-item-delete {
      background: none; border: none; color: var(--text3); cursor: pointer;
      padding: 8px; border-radius: 50%;
    }
    .bookmark-item-delete:hover { background: rgba(255,255,255,0.1); color: #e74c3c; }
    .bookmarks-empty { text-align: center; color: var(--text3); padding: 40px 20px; }

    @media (max-width: 768px) {
      .expanded-art-container { width: 240px; height: 240px; }
      .expanded-title { font-size: 18px; }
      .expanded-play { width: 64px; height: 64px; }
      .speed-control-wrap { padding: 10px 12px; }
    }
    
    /* Modal */
    .modal { position: fixed; inset: 0; background: rgba(0,0,0,0.75); display: none; align-items: center; justify-content: center; z-index: 300; }
    .modal.active { display: flex; }
    .modal-box { background: var(--bg2); border-radius: 14px; width: 90%; max-width: 400px; }
    .modal-header { padding: 18px 20px; border-bottom: 1px solid var(--border); display: flex; align-items: center; justify-content: space-between; }
    .modal-header h2 { font-size: 18px; font-weight: 600; }
    .modal-close { background: none; border: none; color: var(--text2); cursor: pointer; }
    .modal-body { padding: 20px; }
    .form-group { margin-bottom: 16px; }
    .form-label { display: block; font-size: 13px; font-weight: 500; color: var(--text2); margin-bottom: 6px; }
    .form-input { width: 100%; padding: 11px 14px; background: var(--bg3); border: 1px solid var(--border2); border-radius: 8px; color: var(--text); font-size: 14px; font-family: inherit; }
    .form-input:focus { outline: none; border-color: var(--green); }
    .type-sel { display: flex; gap: 10px; }
    .type-btn { flex: 1; padding: 12px; background: var(--bg3); border: 2px solid var(--border2); border-radius: 10px; color: var(--text); cursor: pointer; display: flex; flex-direction: column; align-items: center; gap: 4px; font-family: inherit; }
    .type-btn.active { border-color: var(--green); background: rgba(29,185,84,0.1); }
    .type-btn .icon { font-size: 22px; }
    .type-btn .label { font-size: 13px; font-weight: 500; }
    .submit-btn { width: 100%; padding: 12px; background: var(--green); border: none; border-radius: 18px; color: #000; font-size: 15px; font-weight: 600; cursor: pointer; font-family: inherit; }
    .submit-btn:disabled { background: var(--border2); color: var(--text3); cursor: not-allowed; }
    .fetch-btn { padding: 11px 16px; background: var(--bg4); border: 1px solid var(--border2); border-radius: 8px; color: var(--text); font-size: 13px; font-weight: 500; cursor: pointer; font-family: inherit; white-space: nowrap; transition: all 0.15s; }
    .fetch-btn:hover:not(:disabled) { background: var(--green); color: #000; border-color: var(--green); }
    .fetch-btn:disabled { background: var(--bg3); color: var(--text3); cursor: not-allowed; }
    .fetch-btn.loading { background: var(--bg3); color: var(--text2); }
    .fetch-status { font-size: 12px; margin-top: 6px; min-height: 16px; }
    .fetch-status.success { color: var(--green); }
    .fetch-status.error { color: #e74c3c; }
    .fetch-status.loading { color: var(--text2); }
    
    .toast { position: fixed; bottom: 100px; left: 50%; transform: translateX(-50%); background: var(--bg4); color: var(--text); padding: 12px 24px; border-radius: 8px; font-size: 14px; z-index: 400; opacity: 0; transition: opacity 0.3s; pointer-events: none; }
    .toast.show { opacity: 1; }
    
    .empty { display: flex; flex-direction: column; align-items: center; padding: 48px 24px; text-align: center; color: var(--text3); }
    .empty-icon { font-size: 48px; margin-bottom: 12px; }
    .empty-title { font-size: 16px; font-weight: 600; color: var(--text); }
    
    @media (max-width: 768px) {
      .toggle-btn span:last-child { display: none; }
      .search-box { display: none; }
      .news-sidebar { display: none; }
      .show-hero { flex-direction: column; align-items: center; text-align: center; padding: 20px; }
      .show-hero-art { width: 160px; height: 160px; }
      .show-hero-title { font-size: 26px; }
      .player-info { display: none; }
    }
  </style>
</head>
<body>
<div class="app">
  <header class="header">
    <div class="logo">üì° Feedr</div>
    <div class="main-toggle">
      <button class="toggle-btn active" data-view="news"><span>üì∞</span><span>News</span></button>
      <button class="toggle-btn" data-view="podcasts"><span>üéß</span><span>Podcasts</span></button>
    </div>
    <div class="spacer"></div>
    <div class="search-box">
      <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2"><circle cx="7" cy="7" r="5"/><path d="M12 12l3 3"/></svg>
      <input type="text" id="searchInput" placeholder="Search...">
    </div>
    <button class="icon-btn" id="refreshBtn" title="Refresh feeds"><svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M1 4v6h6M23 20v-6h-6"/><path d="M20.49 9A9 9 0 005.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 013.51 15"/></svg></button>
    <button class="icon-btn" id="addBtn"><svg width="22" height="22" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12h14"/></svg></button>
  </header>
  
  <div class="main">
    <!-- NEWS VIEW -->
    <div class="news-view active" id="newsView">
      <aside class="news-sidebar">
        <div class="sidebar-header"><h2>Sources</h2><button class="add-btn" id="addNewsBtn">+</button></div>
        <div class="sidebar-content" id="newsSources"></div>
      </aside>
      <div class="news-content">
        <div class="news-header">
          <div class="news-title" id="newsTitle">All Articles</div>
          <div class="category-chips" id="categoryChips"></div>
        </div>
        <div class="news-list" id="newsList"></div>
      </div>
    </div>
    
    <!-- PODCAST VIEW -->
    <div class="podcast-view" id="podcastView">
      <nav class="podcast-nav">
        <button class="nav-btn active" data-tab="home">Home</button>
        <button class="nav-btn" data-tab="shows">Shows</button>
        <button class="nav-btn" data-tab="queue">Queue</button>
        <button class="nav-btn" data-tab="downloads">Downloads</button>
      </nav>
      <div class="podcast-content" id="podcastContent"></div>
      <div class="show-page" id="showPage"></div>
    </div>
  </div>
  
  <!-- PLAYER -->
  <div class="player" id="player">
    <div class="player-left">
      <img class="player-art" id="playerArt" src="">
      <div class="player-info">
        <div class="player-title" id="playerTitle"></div>
        <div class="player-show" id="playerShow"></div>
      </div>
    </div>
    <div class="player-center">
      <div class="player-controls">
        <button class="player-skip" id="pSkipBack">-15</button>
        <button class="player-play" id="pPlay"><svg width="16" height="16" fill="currentColor" viewBox="0 0 24 24" id="pPlayIcon"><path d="M8 5v14l11-7z"/></svg></button>
        <button class="player-skip" id="pSkipFwd">+30</button>
      </div>
      <div class="player-progress">
        <span class="player-time" id="pCur">0:00</span>
        <div class="player-bar" id="pBar"><div class="player-fill" id="pFill"></div></div>
        <span class="player-time right" id="pDur">0:00</span>
      </div>
    </div>
    <div class="player-right">
      <button class="speed-btn" id="pSpeed">1x</button>
      <button class="icon-btn" id="pExpand"><svg width="16" height="16" fill="currentColor" viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg></button>
    </div>
  </div>
  
  <!-- EXPANDED FULLSCREEN PLAYER -->
  <div class="expanded" id="expanded">
    <div class="expanded-bg" id="expBg"></div>
    <div class="expanded-content">
      <!-- Top Progress Bar - Libby style -->
      <div class="expanded-top-progress">
        <span class="expanded-top-time" id="expTopCur">0:00</span>
        <div class="expanded-top-bar-wrap">
          <div class="expanded-scrub-preview" id="expScrubPreview">0:00</div>
          <div class="expanded-top-bar" id="expTopBar">
            <div class="expanded-top-fill" id="expTopFill"></div>
            <!-- Bookmark markers will be inserted here -->
          </div>
        </div>
        <span class="expanded-top-pct" id="expTopPct" title="Triple-tap to toggle">0%</span>
        <span class="expanded-top-time right" id="expTopDur">0:00</span>
      </div>

      <!-- Header with icons -->
      <div class="expanded-header">
        <button class="icon-btn" id="expClose"><svg width="24" height="24" fill="none" stroke="currentColor" stroke-width="2"><path d="M6 9l6 6 6-6"/></svg></button>
        <span class="expanded-label">Now Playing</span>
        <div class="expanded-header-icons">
          <button class="exp-icon-btn" id="expSpeedBtn" title="Playback Speed"><svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/></svg></button>
          <button class="exp-icon-btn" id="expSleepBtn" title="Sleep Timer"><svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></button>
          <button class="exp-icon-btn" id="expBookmarksBtn" title="View Bookmarks"><svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M19 21l-7-5-7 5V5a2 2 0 012-2h10a2 2 0 012 2v16z"/></svg></button>
          <button class="exp-icon-btn" id="expAddBookmarkBtn" title="Add Bookmark"><svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M19 21l-7-5-7 5V5a2 2 0 012-2h10a2 2 0 012 2v16z"/><path d="M12 7v6M9 10h6"/></svg></button>
        </div>
      </div>

      <!-- Artwork with swipe gestures -->
      <div class="expanded-body">
        <div class="expanded-art-container" id="expArtContainer">
          <img class="expanded-art" id="expArt" src="" crossorigin="anonymous">
          <div class="swipe-indicator left" id="swipeIndicatorLeft">-0s</div>
          <div class="swipe-indicator right" id="swipeIndicatorRight">+0s</div>
        </div>
        <div class="expanded-info">
          <div class="expanded-title" id="expTitle"></div>
          <div class="expanded-show" id="expShow"></div>
        </div>
      </div>

      <!-- Main Controls -->
      <div class="expanded-controls">
        <button class="chapter-skip" id="expPrevChapter" title="Previous"><svg width="20" height="20" fill="currentColor" viewBox="0 0 24 24"><path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/></svg></button>
        <div class="expanded-skip-outer" id="expBackOuter">
          <button class="expanded-skip" id="expBack">-15</button>
        </div>
        <button class="expanded-play" id="expPlay"><svg width="28" height="28" fill="currentColor" viewBox="0 0 24 24" id="expPlayIcon"><path d="M8 5v14l11-7z"/></svg></button>
        <div class="expanded-skip-outer" id="expFwdOuter">
          <button class="expanded-skip" id="expFwd">+30</button>
        </div>
        <button class="chapter-skip" id="expNextChapter" title="Next"><svg width="20" height="20" fill="currentColor" viewBox="0 0 24 24"><path d="M6 18l8.5-6L6 6v12zm2 0h2V6h-2v12z" transform="rotate(180 12 12)"/></svg></button>
      </div>

      <!-- Speed Control Slider -->
      <div class="expanded-speed-section" id="expSpeedSection" style="display:none;">
        <div class="speed-control-wrap">
          <div class="speed-icon"><svg width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/></svg></div>
          <div class="speed-slider-wrap">
            <input type="range" class="speed-slider" id="expSpeedSlider" min="0.5" max="3" step="0.05" value="1">
            <div class="speed-presets">
              <button class="speed-preset" data-speed="0.75">0.75x</button>
              <button class="speed-preset active" data-speed="1">1x</button>
              <button class="speed-preset" data-speed="1.25">1.25x</button>
              <button class="speed-preset" data-speed="1.5">1.5x</button>
              <button class="speed-preset" data-speed="2">2x</button>
            </div>
          </div>
          <div class="speed-value" id="expSpeedValue">1.00x</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Sleep Timer Panel -->
  <div class="sleep-backdrop" id="sleepBackdrop"></div>
  <div class="sleep-panel" id="sleepPanel">
    <div class="sleep-panel-header">
      <div class="sleep-panel-title">Sleep Timer</div>
      <button class="icon-btn" id="sleepPanelClose"><svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 6L6 18M6 6l12 12"/></svg></button>
    </div>
    <div class="sleep-options">
      <button class="sleep-option" data-minutes="5"><span class="sleep-option-label">5 minutes</span><svg class="sleep-option-check" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M20 6L9 17l-5-5"/></svg></button>
      <button class="sleep-option" data-minutes="10"><span class="sleep-option-label">10 minutes</span><svg class="sleep-option-check" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M20 6L9 17l-5-5"/></svg></button>
      <button class="sleep-option" data-minutes="15"><span class="sleep-option-label">15 minutes</span><svg class="sleep-option-check" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M20 6L9 17l-5-5"/></svg></button>
      <button class="sleep-option" data-minutes="30"><span class="sleep-option-label">30 minutes</span><svg class="sleep-option-check" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M20 6L9 17l-5-5"/></svg></button>
      <button class="sleep-option" data-minutes="45"><span class="sleep-option-label">45 minutes</span><svg class="sleep-option-check" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M20 6L9 17l-5-5"/></svg></button>
      <button class="sleep-option" data-minutes="60"><span class="sleep-option-label">60 minutes</span><svg class="sleep-option-check" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M20 6L9 17l-5-5"/></svg></button>
      <button class="sleep-option" data-minutes="end"><span class="sleep-option-label">End of episode</span><svg class="sleep-option-check" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M20 6L9 17l-5-5"/></svg></button>
      <button class="sleep-option" data-minutes="off"><span class="sleep-option-label">Turn off</span><svg class="sleep-option-check" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M20 6L9 17l-5-5"/></svg></button>
    </div>
    <div class="sleep-custom">
      <input type="number" id="sleepCustomMin" placeholder="Custom minutes...">
      <button id="sleepCustomSet">Set</button>
    </div>
  </div>

  <!-- Bookmarks Panel -->
  <div class="bookmarks-panel" id="bookmarksPanel">
    <div class="bookmarks-panel-header">
      <div class="bookmarks-panel-title">Bookmarks</div>
      <button class="icon-btn" id="bookmarksPanelClose"><svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 6L6 18M6 6l12 12"/></svg></button>
    </div>
    <div class="bookmarks-list" id="bookmarksList">
      <div class="bookmarks-empty">No bookmarks yet. Tap the bookmark icon to add one.</div>
    </div>
  </div>
</div>

<!-- MODAL -->
<div class="modal" id="modal">
  <div class="modal-box">
    <div class="modal-header">
      <h2>Add Feed</h2>
      <button class="modal-close" id="modalClose"><svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 5L5 15M5 5l10 10"/></svg></button>
    </div>
    <div class="modal-body">
      <div class="form-group">
        <label class="form-label">Feed URL</label>
        <div style="display:flex;gap:8px">
          <input type="url" class="form-input" id="fUrl" placeholder="https://..." style="flex:1">
          <button class="fetch-btn" id="fFetch" disabled>Fetch</button>
        </div>
        <div class="fetch-status" id="fStatus"></div>
      </div>
      <div class="form-group"><label class="form-label">Name</label><input type="text" class="form-input" id="fName" placeholder="Auto-detected from feed..."></div>
      <div class="form-group"><label class="form-label">Creator / Author</label><input type="text" class="form-input" id="fAuthor" placeholder="Auto-detected from feed..."></div>
      <div class="form-group"><label class="form-label">Type</label>
        <div class="type-sel">
          <button class="type-btn active" id="tNews"><span class="icon">üì∞</span><span class="label">News</span></button>
          <button class="type-btn" id="tPodcast"><span class="icon">üéôÔ∏è</span><span class="label">Podcast</span></button>
        </div>
      </div>
      <div class="form-group"><label class="form-label">Category</label><input type="text" class="form-input" id="fCat" placeholder="Tech, News..."></div>
      <button class="submit-btn" id="fSubmit" disabled>Add Feed</button>
    </div>
  </div>
</div>
<div class="toast" id="toast"></div>

<!-- Audio element for actual playback -->
<audio id="audioPlayer" preload="metadata"></audio>

<script>
(function() {
  'use strict';
  
  // === MEMORY SYSTEM ===
  const Mem = {
    pending: [],
    session: 's_' + Date.now(),
    endpoint: null,
    
    log(action, target, data = {}) {
      const m = { id: 'm_' + Date.now() + '_' + Math.random().toString(36).substr(2,4), ts: new Date().toISOString(), action, target, session: this.session, ctx: { view: state.view, tab: state.tab }, ...data };
      this.pending.push(m);
      try { const a = JSON.parse(localStorage.getItem('mem') || '[]'); a.push(m); if (a.length > 500) a.splice(0, a.length - 500); localStorage.setItem('mem', JSON.stringify(a)); } catch(e) {}
      this.sync();
    },
    sync() {
      if (!this.endpoint || !this.pending.length) return;
      const t = [...this.pending]; this.pending = [];
      fetch(this.endpoint, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ memories: t }) }).catch(() => this.pending = [...t, ...this.pending]);
    },
    setEndpoint(u) { this.endpoint = u; this.sync(); },
    getLocal() { try { return JSON.parse(localStorage.getItem('mem') || '[]'); } catch(e) { return []; } }
  };
  window.Memory = Mem;
  
  // === FUZZY SEARCH ===
  const fuzzy = (q, items, fields) => {
    if (!q.trim()) return items;
    const ql = q.toLowerCase();
    return items.map(item => {
      let score = 0;
      for (const f of fields) {
        const v = f.split('.').reduce((o, k) => o?.[k], item);
        if (v && String(v).toLowerCase().includes(ql)) score = 1;
      }
      return { item, score };
    }).filter(x => x.score > 0).map(x => x.item);
  };
  
  // === STATE ===
  const state = {
    view: 'news',
    tab: 'home',
    feeds: [],
    articles: [],
    podcasts: [],
    categories: new Set(['All']),
    selectedSource: null,
    selectedCat: 'All',
    query: '',
    feedType: 'news',
    currentEp: null,
    playing: false,
    speed: 1,
    progress: {},
    // Fullscreen player state
    bookmarks: {}, // { episodeId: [{ time: number, note: string, created: ISO }] }
    sleepTimer: null, // { endTime: timestamp, fadeStart: timestamp, type: 'minutes'|'end' }
    sleepTimerInterval: null,
    showTimeAsPercent: false // Toggle for time/percentage display
  };
  
  // === DOM ===
  const $ = id => document.getElementById(id);
  const el = {
    newsView: $('newsView'), podcastView: $('podcastView'),
    newsSources: $('newsSources'), newsTitle: $('newsTitle'),
    categoryChips: $('categoryChips'), newsList: $('newsList'),
    podcastContent: $('podcastContent'), showPage: $('showPage'),
    player: $('player'), playerArt: $('playerArt'), playerTitle: $('playerTitle'),
    playerShow: $('playerShow'), pPlay: $('pPlay'), pPlayIcon: $('pPlayIcon'),
    pCur: $('pCur'), pDur: $('pDur'), pBar: $('pBar'), pFill: $('pFill'), pSpeed: $('pSpeed'),
    // Expanded player elements
    expanded: $('expanded'), expBg: $('expBg'), expArt: $('expArt'),
    expArtContainer: $('expArtContainer'), expTitle: $('expTitle'),
    expShow: $('expShow'), expPlay: $('expPlay'), expPlayIcon: $('expPlayIcon'),
    // Top progress bar
    expTopCur: $('expTopCur'), expTopDur: $('expTopDur'), expTopPct: $('expTopPct'),
    expTopBar: $('expTopBar'), expTopFill: $('expTopFill'), expScrubPreview: $('expScrubPreview'),
    // Swipe indicators
    swipeIndicatorLeft: $('swipeIndicatorLeft'), swipeIndicatorRight: $('swipeIndicatorRight'),
    // Header buttons
    expSpeedBtn: $('expSpeedBtn'), expSleepBtn: $('expSleepBtn'),
    expBookmarksBtn: $('expBookmarksBtn'), expAddBookmarkBtn: $('expAddBookmarkBtn'),
    // Speed section
    expSpeedSection: $('expSpeedSection'), expSpeedSlider: $('expSpeedSlider'), expSpeedValue: $('expSpeedValue'),
    // Sleep panel
    sleepBackdrop: $('sleepBackdrop'), sleepPanel: $('sleepPanel'),
    sleepCustomMin: $('sleepCustomMin'), sleepCustomSet: $('sleepCustomSet'),
    // Bookmarks panel
    bookmarksPanel: $('bookmarksPanel'), bookmarksList: $('bookmarksList'),
    // Modal and form
    modal: $('modal'), fUrl: $('fUrl'), fName: $('fName'), fAuthor: $('fAuthor'), fCat: $('fCat'),
    fFetch: $('fFetch'), fStatus: $('fStatus'), fSubmit: $('fSubmit'),
    toast: $('toast'), searchInput: $('searchInput'),
    audio: $('audioPlayer')
  };
  
  // === UTILS ===
  const fmt = s => { if (isNaN(s) || s < 0) return '0:00'; const m = Math.floor(s / 60), sec = Math.floor(s % 60); return m + ':' + String(sec).padStart(2, '0'); };
  const toast = m => { el.toast.textContent = m; el.toast.classList.add('show'); setTimeout(() => el.toast.classList.remove('show'), 2500); };
  const save = () => localStorage.setItem('feedr2', JSON.stringify({ feeds: state.feeds, articles: state.articles, podcasts: state.podcasts, progress: state.progress, bookmarks: state.bookmarks, speed: state.speed }));
  
  const load = () => {
    try {
      const d = JSON.parse(localStorage.getItem('feedr2'));
      if (d) {
        state.feeds = d.feeds || [];
        state.articles = d.articles || [];
        state.podcasts = d.podcasts || [];
        state.progress = d.progress || {};
        state.bookmarks = d.bookmarks || {};
        state.speed = d.speed || 1;
      }
      state.feeds.forEach(f => f.category && state.categories.add(f.category));
      if (!state.feeds.length) loadDemo();
    } catch(e) { loadDemo(); }
  };
  
  const loadDemo = () => {
    // No sample data - users add their own feeds
    state.feeds = [];
    state.articles = [];
    state.podcasts = [];
    state.progress = {};
    save();
  };

  // === RSS FEED FETCHING ===
  // Simpler, more reliable CORS proxy configuration
  const CORS_PROXIES = [
    url => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
    url => `https://corsproxy.io/?${encodeURIComponent(url)}`,
    url => `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`
  ];

  const fetchWithTimeout = (url, options = {}, timeout = 15000) => {
    return Promise.race([
      fetch(url, options),
      new Promise((_, reject) =>
        setTimeout(() => reject(new Error('Request timeout')), timeout)
      )
    ]);
  };

  const fetchWithProxy = async (url, proxyIndex = 0) => {
    if (proxyIndex >= CORS_PROXIES.length) {
      throw new Error(`All CORS proxies failed for: ${url}`);
    }

    const proxyUrl = CORS_PROXIES[proxyIndex](url);
    console.log('Trying proxy:', proxyUrl);

    try {
      const response = await fetchWithTimeout(proxyUrl, {
        headers: { 'Accept': 'application/rss+xml, application/xml, text/xml, */*' }
      }, 20000);

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }

      const text = await response.text();

      if (!text || text.trim().length === 0) {
        throw new Error('Empty response');
      }

      // Basic validation that this looks like XML
      if (!text.trim().startsWith('<?xml') && !text.trim().startsWith('<rss') && !text.trim().startsWith('<feed')) {
        console.warn('Response does not look like XML:', text.substring(0, 100));
        // Still try to use it, might be valid
      }

      return text;
    } catch (e) {
      console.warn(`Proxy ${proxyIndex} failed:`, e.message);
      return fetchWithProxy(url, proxyIndex + 1);
    }
  };

  const parseRSSDate = dateStr => {
    if (!dateStr) return new Date();
    const d = new Date(dateStr);
    return isNaN(d.getTime()) ? new Date() : d;
  };

  const formatTimeAgo = date => {
    const now = new Date();
    const diff = Math.floor((now - date) / 1000);
    if (diff < 60) return 'just now';
    if (diff < 3600) return Math.floor(diff / 60) + 'm ago';
    if (diff < 86400) return Math.floor(diff / 3600) + 'h ago';
    if (diff < 604800) return Math.floor(diff / 86400) + 'd ago';
    return Math.floor(diff / 604800) + 'w ago';
  };

  const parseDuration = dur => {
    if (!dur) return 0;
    // Handle HH:MM:SS or MM:SS format
    if (dur.includes(':')) {
      const parts = dur.split(':').map(Number);
      if (parts.length === 3) return parts[0] * 3600 + parts[1] * 60 + parts[2];
      if (parts.length === 2) return parts[0] * 60 + parts[1];
    }
    // Handle seconds as number
    const num = parseInt(dur, 10);
    return isNaN(num) ? 0 : num;
  };

  // Helper to find elements with namespace support (handles itunes:*, media:*, etc.)
  const findElement = (parent, tag) => {
    // Try getElementsByTagName first (works best with namespaced elements)
    let elements = parent.getElementsByTagName(tag);
    if (elements.length > 0) return elements[0];

    // Try without namespace prefix (for local names)
    const localName = tag.includes(':') ? tag.split(':')[1] : tag;
    elements = parent.getElementsByTagName(localName);
    if (elements.length > 0) return elements[0];

    // Try with wildcard namespace
    const nsElements = parent.getElementsByTagNameNS('*', localName);
    if (nsElements.length > 0) return nsElements[0];

    // Fallback to querySelector (may not work with namespaced elements in all browsers)
    try {
      const node = parent.querySelector(tag);
      if (node) return node;
    } catch(e) {
      // Selector may be invalid for namespaced tags
    }

    return null;
  };

  // Find all elements matching a tag (for items/entries)
  const findAllElements = (parent, tag) => {
    let elements = parent.getElementsByTagName(tag);
    if (elements.length > 0) return Array.from(elements);

    const localName = tag.includes(':') ? tag.split(':')[1] : tag;
    elements = parent.getElementsByTagName(localName);
    if (elements.length > 0) return Array.from(elements);

    return [];
  };

  const getNodeText = (parent, tag) => {
    const node = findElement(parent, tag);
    return node ? node.textContent?.trim() || '' : '';
  };

  const getNodeAttr = (parent, tag, attr) => {
    const node = findElement(parent, tag);
    return node ? node.getAttribute(attr) || '' : '';
  };

  // Get image from itunes:image element (has href attribute)
  const getItunesImage = (parent) => {
    // iTunes namespace URI
    const itunesNS = 'http://www.itunes.com/dtds/podcast-1.0.dtd';

    // Try getElementsByTagNameNS with iTunes namespace
    try {
      let elements = parent.getElementsByTagNameNS(itunesNS, 'image');
      if (elements.length > 0) {
        const href = elements[0].getAttribute('href');
        if (href) return href;
      }
    } catch(e) {}

    // Try itunes:image with colon
    try {
      let elements = parent.getElementsByTagName('itunes:image');
      if (elements.length > 0) {
        const href = elements[0].getAttribute('href');
        if (href) return href;
      }
    } catch(e) {}

    // Try wildcard namespace with local name 'image'
    try {
      const elements = parent.getElementsByTagNameNS('*', 'image');
      for (let i = 0; i < elements.length; i++) {
        const href = elements[i].getAttribute('href');
        if (href) return href;
      }
    } catch(e) {}

    // Try just 'image' elements with href attribute
    const imageEls = parent.getElementsByTagName('image');
    for (let i = 0; i < imageEls.length; i++) {
      const href = imageEls[i].getAttribute('href');
      if (href) return href;
    }

    return '';
  };

  // Check if URL looks like a valid image URL (not just a homepage)
  const isValidImageUrl = url => {
    if (!url) return false;
    try {
      const parsed = new URL(url);
      // Reject URLs that are just hostnames with no meaningful path
      if (parsed.pathname === '/' || parsed.pathname === '') return false;
      // Accept URLs with image extensions or meaningful paths
      const imageExtensions = /\.(jpg|jpeg|png|gif|webp|svg|bmp|ico)(\?|$)/i;
      if (imageExtensions.test(parsed.pathname)) return true;
      // Accept URLs with paths that look like they could be images
      if (parsed.pathname.length > 1) return true;
      return false;
    } catch (e) {
      return false;
    }
  };

  const extractImage = item => {
    // Try media:content
    let img = getNodeAttr(item, 'media:content', 'url');
    if (img && isValidImageUrl(img)) return img;

    // Try media:thumbnail
    img = getNodeAttr(item, 'media:thumbnail', 'url');
    if (img && isValidImageUrl(img)) return img;

    // Try enclosure with image type
    const enclosure = findElement(item, 'enclosure');
    if (enclosure) {
      const type = enclosure.getAttribute('type') || '';
      if (type.startsWith('image/')) {
        return enclosure.getAttribute('url') || '';
      }
    }

    // Try to extract from description/content HTML
    const desc = getNodeText(item, 'description') || getNodeText(item, 'content:encoded');
    const match = desc.match(/<img[^>]+src=["']([^"']+)["']/i);
    if (match) return match[1];

    return '';
  };

  const parseNewsFeed = (xml, feedId) => {
    const parser = new DOMParser();
    const doc = parser.parseFromString(xml, 'text/xml');

    const parserError = doc.querySelector('parsererror');
    if (parserError) {
      throw new Error('Invalid RSS feed XML');
    }

    const items = doc.querySelectorAll('item, entry');
    const articles = [];

    items.forEach((item, index) => {
      const title = getNodeText(item, 'title');
      if (!title) return;

      const pubDate = parseRSSDate(
        getNodeText(item, 'pubDate') ||
        getNodeText(item, 'published') ||
        getNodeText(item, 'updated') ||
        getNodeText(item, 'dc:date')
      );

      // Get description and clean HTML
      let summary = getNodeText(item, 'description') || getNodeText(item, 'summary') || getNodeText(item, 'content:encoded') || '';
      // Strip HTML tags for summary
      const tmp = document.createElement('div');
      tmp.innerHTML = summary;
      summary = tmp.textContent?.trim().slice(0, 300) || '';

      const link = getNodeText(item, 'link') || getNodeAttr(item, 'link', 'href');
      const image = extractImage(item);

      // Create unique ID using feed ID, hash of title, and index
      const titleHash = title.split('').reduce((a, c) => ((a << 5) - a + c.charCodeAt(0)) | 0, 0);
      const uniqueId = Math.abs(feedId * 100000 + titleHash + index);

      articles.push({
        id: uniqueId,
        feedId,
        title,
        summary,
        link,
        time: formatTimeAgo(pubDate),
        pubDate: pubDate.toISOString(),
        image,
        unread: true
      });
    });

    return articles;
  };

  const parsePodcastFeed = (xml, feedId) => {
    const parser = new DOMParser();
    const doc = parser.parseFromString(xml, 'text/xml');

    const parserError = doc.querySelector('parsererror');
    if (parserError) {
      console.error('XML parse error:', parserError.textContent);
      throw new Error('Invalid podcast feed XML');
    }

    // Get channel element for fallback image
    const channel = doc.querySelector('channel') || doc.querySelector('feed');
    let channelImage = '';
    if (channel) {
      channelImage = getItunesImage(channel);
      if (!channelImage) {
        // Try standard RSS image/url
        const imageEl = channel.querySelector('image');
        if (imageEl) {
          const urlEl = imageEl.querySelector('url');
          if (urlEl) channelImage = urlEl.textContent?.trim() || '';
        }
      }
    }

    // Find all items - use getElementsByTagName for better compatibility
    const items = Array.from(doc.getElementsByTagName('item'));
    if (items.length === 0) {
      // Try Atom entry format
      items.push(...Array.from(doc.getElementsByTagName('entry')));
    }

    console.log('Parsing podcast feed, found', items.length, 'items');
    const episodes = [];

    items.forEach((item, index) => {
      const title = getNodeText(item, 'title');
      if (!title) return;

      // Get audio enclosure - try multiple methods
      let audioUrl = '';
      const enclosures = item.getElementsByTagName('enclosure');
      for (let i = 0; i < enclosures.length; i++) {
        const enc = enclosures[i];
        const type = enc.getAttribute('type') || '';
        const url = enc.getAttribute('url') || '';
        if (url && (type.includes('audio') || type.includes('video') || !type)) {
          audioUrl = url;
          break;
        }
      }

      // Fallback to link with enclosure rel for Atom
      if (!audioUrl) {
        const links = item.getElementsByTagName('link');
        for (let i = 0; i < links.length; i++) {
          const link = links[i];
          if (link.getAttribute('rel') === 'enclosure') {
            audioUrl = link.getAttribute('href') || '';
            break;
          }
        }
      }

      const pubDate = parseRSSDate(
        getNodeText(item, 'pubDate') ||
        getNodeText(item, 'published') ||
        getNodeText(item, 'updated')
      );

      // Get duration from itunes:duration - try multiple approaches
      let durationStr = '';
      const durationEls = item.getElementsByTagName('itunes:duration');
      if (durationEls.length > 0) {
        durationStr = durationEls[0].textContent?.trim() || '';
      }
      if (!durationStr) {
        const durEls = item.getElementsByTagName('duration');
        if (durEls.length > 0) {
          durationStr = durEls[0].textContent?.trim() || '';
        }
      }
      const duration = parseDuration(durationStr);

      // Get description - try multiple fields
      let desc = '';
      const descFields = ['itunes:summary', 'itunes:subtitle', 'description', 'summary', 'content:encoded'];
      for (const field of descFields) {
        const els = item.getElementsByTagName(field);
        if (els.length > 0 && els[0].textContent?.trim()) {
          desc = els[0].textContent.trim();
          break;
        }
      }
      // Strip HTML
      const tmp = document.createElement('div');
      tmp.innerHTML = desc;
      desc = tmp.textContent?.trim().slice(0, 300) || '';

      // Get episode image - try multiple approaches
      let image = getItunesImage(item);
      if (!image) {
        image = extractImage(item);
      }
      // Fallback to channel image
      if (!image) {
        image = channelImage;
      }

      // Create unique ID using feed ID, hash of title, and index
      const titleHash = title.split('').reduce((a, c) => ((a << 5) - a + c.charCodeAt(0)) | 0, 0);
      const uniqueId = Math.abs(feedId * 100000 + titleHash + index);

      episodes.push({
        id: uniqueId,
        feedId,
        title,
        desc,
        duration: duration || 1800, // Default 30 min if no duration
        date: formatTimeAgo(pubDate),
        pubDate: pubDate.toISOString(),
        image,
        audioUrl,
        downloaded: false
      });
    });

    console.log('Parsed', episodes.length, 'episodes');
    return episodes;
  };

  const extractFeedMeta = xml => {
    const parser = new DOMParser();
    const doc = parser.parseFromString(xml, 'text/xml');

    const channel = doc.querySelector('channel') || doc.querySelector('feed');
    if (!channel) return {};

    // Get image - try multiple methods
    let image = getItunesImage(channel);

    if (!image) {
      // Try standard RSS image element with url child
      const imageEl = channel.querySelector('image');
      if (imageEl) {
        const urlEl = imageEl.querySelector('url');
        if (urlEl) {
          image = urlEl.textContent?.trim() || '';
        }
        if (!image) {
          image = imageEl.getAttribute('href') || '';
        }
      }
    }

    if (!image) {
      // Try Atom logo
      const logoEl = channel.querySelector('logo');
      if (logoEl) {
        image = logoEl.textContent?.trim() || logoEl.getAttribute('src') || '';
      }
    }

    // Get author - try multiple approaches
    let author = '';
    const authorFields = ['itunes:author', 'author', 'managingEditor', 'dc:creator'];
    for (const field of authorFields) {
      const els = channel.getElementsByTagName(field);
      if (els.length > 0 && els[0].textContent?.trim()) {
        author = els[0].textContent.trim();
        break;
      }
    }

    return {
      title: getNodeText(channel, 'title'),
      description: getNodeText(channel, 'description') || getNodeText(channel, 'subtitle'),
      author,
      image
    };
  };

  // Fetch feed metadata without adding it - for preview/auto-detect
  const fetchFeedMetadata = async (url) => {
    try {
      const xml = await fetchWithProxy(url);
      const meta = extractFeedMeta(xml);

      // Also try to detect feed type based on content
      const parser = new DOMParser();
      const doc = parser.parseFromString(xml, 'text/xml');
      const hasEnclosure = doc.querySelector('enclosure[type^="audio"], enclosure[type^="video"]');
      const hasItunesNs = xml.includes('xmlns:itunes') || xml.includes('itunes:');
      const suggestedType = (hasEnclosure || hasItunesNs) ? 'podcast' : 'news';

      return {
        success: true,
        title: meta.title || '',
        author: meta.author || '',
        description: meta.description || '',
        image: meta.image || '',
        suggestedType
      };
    } catch (e) {
      console.error('Failed to fetch feed metadata:', e);
      return {
        success: false,
        error: e.message
      };
    }
  };

  const fetchAndParseFeed = async feed => {
    try {
      const xml = await fetchWithProxy(feed.url);
      const meta = extractFeedMeta(xml);

      // Update feed metadata if available (only if user hasn't provided values)
      if (meta.title && (!feed.name || feed.name === 'Loading...')) feed.name = meta.title;
      if (meta.image && !feed.image) feed.image = meta.image;
      if (meta.author && !feed.author) feed.author = meta.author;

      if (feed.type === 'news') {
        const articles = parseNewsFeed(xml, feed.id);
        // Merge with existing, avoiding duplicates by title
        const existingTitles = new Set(state.articles.filter(a => a.feedId === feed.id).map(a => a.title));
        const newArticles = articles.filter(a => !existingTitles.has(a.title));
        state.articles = [...newArticles, ...state.articles.filter(a => a.feedId !== feed.id || existingTitles.has(a.title))];
        // Sort by date
        state.articles.sort((a, b) => new Date(b.pubDate || 0) - new Date(a.pubDate || 0));
        // Update unread count
        feed.unread = state.articles.filter(a => a.feedId === feed.id && a.unread).length;
      } else {
        const episodes = parsePodcastFeed(xml, feed.id);
        const existingTitles = new Set(state.podcasts.filter(p => p.feedId === feed.id).map(p => p.title));
        const newEpisodes = episodes.filter(e => !existingTitles.has(e.title));
        state.podcasts = [...newEpisodes, ...state.podcasts.filter(p => p.feedId !== feed.id || existingTitles.has(p.title))];
        // Sort by date
        state.podcasts.sort((a, b) => new Date(b.pubDate || 0) - new Date(a.pubDate || 0));
      }

      feed.lastFetched = new Date().toISOString();
      feed.error = null;
      return true;
    } catch (e) {
      console.error(`Failed to fetch feed ${feed.name}:`, e);
      feed.error = e.message;
      return false;
    }
  };

  const refreshAllFeeds = async () => {
    if (state.refreshing) return;
    state.refreshing = true;
    toast('Refreshing feeds...');

    const results = await Promise.allSettled(
      state.feeds.map(feed => fetchAndParseFeed(feed))
    );

    const success = results.filter(r => r.status === 'fulfilled' && r.value).length;
    const failed = results.length - success;

    state.refreshing = false;
    save();
    renderNewsSources();
    renderCategories();
    renderNews();
    if (state.view === 'podcasts') renderPodcasts();

    if (failed > 0) {
      toast(`Refreshed ${success} feeds, ${failed} failed`);
    } else if (success > 0) {
      toast(`Refreshed ${success} feeds`);
    }
  };

  const addFeed = async (url, name, type, category, author) => {
    const id = Date.now();
    const feed = {
      id,
      url,
      name: name || 'Loading...',
      type,
      category: category || 'Uncategorized',
      image: '',
      author: author || '',
      unread: 0
    };

    state.feeds.push(feed);
    state.categories.add(feed.category);
    save();

    toast('Adding feed...');
    const success = await fetchAndParseFeed(feed);

    if (success) {
      save();
      renderNewsSources();
      renderCategories();
      renderNews();
      if (state.view === 'podcasts') renderPodcasts();
      toast(`Added: ${feed.name}`);
    } else {
      // Keep the feed but show error
      toast(`Added ${feed.name} (fetch failed)`);
    }

    return success;
  };
  
  // === RENDER NEWS ===
  const renderNewsSources = () => {
    const news = state.feeds.filter(f => f.type === 'news');
    el.newsSources.innerHTML = `<div class="source-item ${!state.selectedSource ? 'active' : ''}" data-id="all"><div class="source-icon">üìö</div><div class="source-name">All Sources</div></div>` +
      news.map(f => `<div class="source-item ${state.selectedSource === f.id ? 'active' : ''}" data-id="${f.id}"><div class="source-icon">${f.image ? `<img src="${f.image}">` : 'üì∞'}</div><div class="source-name">${f.name}</div>${f.unread ? `<span class="source-badge">${f.unread}</span>` : ''}</div>`).join('');
  };
  
  const renderCategories = () => {
    const cats = ['All', ...Array.from(state.categories).filter(c => c !== 'All')];
    el.categoryChips.innerHTML = cats.map(c => `<button class="chip ${state.selectedCat === c ? 'active' : ''}" data-cat="${c}">${c}</button>`).join('');
  };
  
  const renderNews = () => {
    let items = state.articles.map(a => ({ ...a, feed: state.feeds.find(f => f.id === a.feedId) }));
    if (state.selectedSource) items = items.filter(i => i.feedId === state.selectedSource);
    if (state.selectedCat !== 'All') items = fuzzy(state.selectedCat, items, ['feed.category']);
    if (state.query) items = fuzzy(state.query, items, ['title', 'summary', 'feed.name']);
    
    if (!items.length) {
      const hasFeeds = state.feeds.filter(f => f.type === 'news').length > 0;
      el.newsList.innerHTML = hasFeeds
        ? '<div class="empty"><div class="empty-icon">üì≠</div><div class="empty-title">No articles found</div><div style="color:var(--text3);margin-top:8px">Try refreshing your feeds</div></div>'
        : '<div class="empty"><div class="empty-icon">üì°</div><div class="empty-title">No news feeds yet</div><div style="color:var(--text3);margin-top:8px">Click + to add your first RSS feed</div></div>';
      return;
    }
    
    el.newsList.innerHTML = items.map(i => `<div class="article ${i.unread ? 'unread' : ''}" data-id="${i.id}"><div class="article-icon">${i.feed?.image ? `<img src="${i.feed.image}">` : 'üìÑ'}</div><div class="article-body"><div class="article-meta"><span class="article-source">${i.feed?.name || ''}</span><span class="article-time">¬∑ ${i.time}</span>${i.unread ? '<span class="article-new">NEW</span>' : ''}</div><div class="article-title">${i.title}</div>${i.summary ? `<div class="article-summary">${i.summary}</div>` : ''}</div>${i.image ? `<img class="article-image" src="${i.image}">` : ''}</div>`).join('');
  };
  
  // === RENDER PODCASTS ===
  const renderPodcasts = () => {
    el.showPage.classList.remove('active');
    el.podcastContent.style.display = 'block';
    
    const shows = state.feeds.filter(f => f.type === 'podcast');
    const inProgress = state.podcasts.filter(p => { const pr = state.progress[p.id] || 0; return pr > 0 && pr < p.duration * 0.95; });
    const downloaded = state.podcasts.filter(p => p.downloaded);
    
    if (state.tab === 'home') {
      if (!shows.length) {
        el.podcastContent.innerHTML = '<div class="empty" style="padding-top:80px"><div class="empty-icon">üéôÔ∏è</div><div class="empty-title">No podcasts yet</div><div style="color:var(--text3);margin-top:8px">Click + to add your first podcast feed</div></div>';
        return;
      }
      el.podcastContent.innerHTML = `
        ${inProgress.length ? `<div class="section"><div class="section-header"><div class="section-title">Continue Listening</div></div><div class="episode-list">${inProgress.map(renderEpisode).join('')}</div></div>` : ''}
        <div class="section"><div class="section-header"><div class="section-title">Your Shows</div></div><div class="shows-grid">${shows.map(s => `<div class="show-card" data-show="${s.id}"><img class="show-art" src="${s.image || placeholderImg}" onerror="this.src='${placeholderImg}'"><div class="show-name">${s.name}</div><div class="show-author">${s.author || ''}</div></div>`).join('')}</div></div>
        ${state.podcasts.length ? `<div class="section"><div class="section-header"><div class="section-title">Recent Episodes</div></div><div class="episode-list">${state.podcasts.slice(0, 6).map(renderEpisode).join('')}</div></div>` : ''}`;
    } else if (state.tab === 'shows') {
      el.podcastContent.innerHTML = `<div class="section"><div class="section-header"><div class="section-title">All Shows</div><button class="add-btn" onclick="document.getElementById('tPodcast').click();document.getElementById('modal').classList.add('active')">+</button></div><div class="shows-grid">${shows.map(s => `<div class="show-card" data-show="${s.id}"><img class="show-art" src="${s.image || placeholderImg}" onerror="this.src='${placeholderImg}'"><div class="show-name">${s.name}</div><div class="show-author">${s.author || ''}</div></div>`).join('')}</div></div>`;
    } else if (state.tab === 'queue') {
      el.podcastContent.innerHTML = `<div class="section"><div class="section-header"><div class="section-title">Up Next</div></div>${state.podcasts.length ? `<div class="episode-list">${state.podcasts.slice(0, 10).map(renderEpisode).join('')}</div>` : '<div class="empty"><div class="empty-icon">üìã</div><div class="empty-title">Queue empty</div></div>'}</div>`;
    } else if (state.tab === 'downloads') {
      el.podcastContent.innerHTML = `<div class="section"><div class="section-header"><div class="section-title">Downloads</div></div>${downloaded.length ? `<div class="episode-list">${downloaded.map(renderEpisode).join('')}</div>` : '<div class="empty"><div class="empty-icon">‚¨áÔ∏è</div><div class="empty-title">No downloads</div></div>'}</div>`;
    }
  };
  
  // Placeholder SVG for broken images
  const placeholderImg = 'data:image/svg+xml,' + encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><rect fill="#1a1a1a" width="100" height="100"/><text x="50" y="60" text-anchor="middle" font-size="40">üéôÔ∏è</text></svg>');

  const renderEpisode = ep => {
    const show = state.feeds.find(f => f.id === ep.feedId);
    const pr = state.progress[ep.id] || 0;
    const pct = ep.duration ? (pr / ep.duration) * 100 : 0;
    const rem = ep.duration - pr;
    const done = pr >= ep.duration * 0.95;
    const imgSrc = ep.image || show?.image || placeholderImg;
    return `<div class="episode" data-ep="${ep.id}"><img class="episode-art" src="${imgSrc}" onerror="this.src='${placeholderImg}'"><div class="episode-body"><div class="episode-show">${show?.name || ''}</div><div class="episode-title">${ep.title}</div><div class="episode-footer"><button class="ep-play" data-ep="${ep.id}"><svg width="10" height="10" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg></button><div class="ep-progress"><div class="ep-bar"><div class="ep-fill" style="width:${pct}%"></div></div><span class="ep-time">${done ? 'Played' : pr > 0 ? fmt(rem) + ' left' : fmt(ep.duration)}</span></div><button class="ep-dl ${ep.downloaded ? 'active' : ''}" data-dl="${ep.id}"><svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M7 10l5 5 5-5M12 15V3"/></svg></button></div></div></div>`;
  };
  
  const renderShowPage = id => {
    const show = state.feeds.find(f => f.id === id);
    if (!show) return;
    Mem.log('feed_opened', 'source_' + id);
    const eps = state.podcasts.filter(p => p.feedId === id);
    el.podcastContent.style.display = 'none';
    el.showPage.classList.add('active');
    el.showPage.innerHTML = `<div class="show-hero"><img class="show-hero-art" src="${show.image || placeholderImg}" onerror="this.src='${placeholderImg}'"><div class="show-hero-info"><div class="show-hero-type">Podcast</div><div class="show-hero-title">${show.name}</div><div class="show-hero-author">${show.author || ''}</div></div></div><div class="show-actions"><button class="show-play" data-show="${id}"><svg width="22" height="22" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg></button></div><div class="show-episodes"><div class="show-episodes-title">Episodes</div><div class="episode-list">${eps.map(renderEpisode).join('')}</div></div>`;
  };
  
  // === PLAYER ===
  const updatePlayer = () => {
    if (!state.currentEp) { el.player.classList.remove('active'); return; }
    const ep = state.currentEp, show = state.feeds.find(f => f.id === ep.feedId);
    const pr = state.progress[ep.id] || 0;
    const duration = el.audio.duration || ep.duration;
    const pct = duration ? (pr / duration) * 100 : 0;

    el.player.classList.add('active');
    const artSrc = ep.image || show?.image || placeholderImg;
    el.playerArt.src = artSrc;
    el.playerArt.onerror = () => { el.playerArt.src = placeholderImg; };
    el.expArt.src = artSrc;
    el.expArt.onerror = () => { el.expArt.src = placeholderImg; };
    el.playerTitle.textContent = ep.title;
    el.playerShow.textContent = show?.name || '';
    el.expTitle.textContent = ep.title;
    el.expShow.textContent = show?.name || '';

    // Mini player times and progress
    el.pCur.textContent = fmt(pr);
    el.pDur.textContent = fmt(duration);
    el.pFill.style.width = pct + '%';

    // Expanded player - top progress bar
    el.expTopCur.textContent = fmt(pr);
    el.expTopDur.textContent = fmt(duration);
    if (!isScrubbing) {
      el.expTopFill.style.width = pct + '%';
    }

    // Percentage display (triple-tap to toggle between time remaining/percentage)
    if (state.showTimeAsPercent) {
      el.expTopPct.textContent = Math.round(pct) + '%';
    } else {
      const remaining = Math.max(0, duration - pr);
      el.expTopPct.textContent = '-' + fmt(remaining);
    }

    // Play/pause icon
    const icon = state.playing ? '<rect x="6" y="4" width="4" height="16" rx="1"/><rect x="14" y="4" width="4" height="16" rx="1"/>' : '<path d="M8 5v14l11-7z"/>';
    el.pPlayIcon.innerHTML = icon;
    el.expPlayIcon.innerHTML = icon;
    el.pSpeed.textContent = state.speed + 'x';

    // Update speed slider
    el.expSpeedSlider.value = state.speed;
    el.expSpeedValue.textContent = state.speed.toFixed(2) + 'x';

    // Update Media Session
    updateMediaSession();
    updatePositionState();

    // Update bookmark markers
    renderBookmarkMarkers();
  };
  
  let progStart = 0;

  // Audio event handlers
  el.audio.addEventListener('timeupdate', () => {
    if (!state.currentEp) return;
    const cur = el.audio.currentTime;
    state.progress[state.currentEp.id] = cur;

    // Log progress every 30 seconds
    if (cur - progStart >= 30) {
      Mem.log('playback_progress', 'ep_' + state.currentEp.id, { from: progStart, to: cur });
      progStart = cur;
    }
    updatePlayer();
  });

  el.audio.addEventListener('ended', () => {
    if (state.currentEp) {
      Mem.log('episode_completed', 'ep_' + state.currentEp.id);
      state.progress[state.currentEp.id] = state.currentEp.duration;
    }
    state.playing = false;
    save();
    updatePlayer();
  });

  el.audio.addEventListener('pause', () => {
    state.playing = false;
    updatePlayer();
  });

  el.audio.addEventListener('play', () => {
    state.playing = true;
    updatePlayer();
  });

  el.audio.addEventListener('loadedmetadata', () => {
    if (state.currentEp) {
      // Update duration from audio if available
      if (el.audio.duration && !isNaN(el.audio.duration)) {
        state.currentEp.duration = el.audio.duration;
      }
      // Seek to saved position
      const savedPos = state.progress[state.currentEp.id] || 0;
      if (savedPos > 0 && savedPos < el.audio.duration) {
        el.audio.currentTime = savedPos;
      }
    }
    updatePlayer();
  });

  el.audio.addEventListener('error', (e) => {
    console.error('Audio error:', e);
    toast('Error loading audio. Try again.');
    state.playing = false;
    updatePlayer();
  });

  // Save progress periodically
  setInterval(() => {
    if (state.currentEp && state.playing) {
      save();
    }
  }, 10000);

  const playEp = id => {
    const ep = state.podcasts.find(p => p.id === id);
    if (!ep) return;
    if (!ep.audioUrl) {
      toast('No audio URL for this episode');
      return;
    }

    if (state.currentEp && state.currentEp.id !== id) {
      Mem.log('episode_exited', 'ep_' + state.currentEp.id, { pos: state.progress[state.currentEp.id] || 0 });
    }

    state.currentEp = ep;
    const pr = state.progress[id] || 0;
    if (pr > 0) Mem.log('returned_to_episode', 'ep_' + id, { prev_pos: pr });
    Mem.log('play_pressed', 'ep_' + id, { pos: pr });

    progStart = pr;

    // Set audio source and play
    if (el.audio.src !== ep.audioUrl) {
      el.audio.src = ep.audioUrl;
      el.audio.load();
    }
    el.audio.playbackRate = state.speed;
    el.audio.play().catch(e => {
      console.error('Playback failed:', e);
      toast('Playback failed. Check audio source.');
    });

    state.playing = true;
    updatePlayer();
  };

  const togglePlay = () => {
    if (!state.currentEp) return;
    const pr = state.progress[state.currentEp.id] || 0;

    if (state.playing) {
      el.audio.pause();
      Mem.log('pause_pressed', 'ep_' + state.currentEp.id, { pos: pr });
    } else {
      el.audio.play().catch(e => {
        console.error('Playback failed:', e);
        toast('Playback failed');
      });
      Mem.log('play_pressed', 'ep_' + state.currentEp.id, { pos: pr });
    }
  };

  const seekTo = pos => {
    if (!state.currentEp) return;
    const prev = state.progress[state.currentEp.id] || 0;
    const duration = el.audio.duration || state.currentEp.duration;
    const p = Math.max(0, Math.min(duration, pos));
    Mem.log('seek', 'ep_' + state.currentEp.id, { from: prev, to: p });
    el.audio.currentTime = p;
    state.progress[state.currentEp.id] = p;
    save();
    updatePlayer();
  };

  const skip = s => {
    if (state.currentEp) {
      seekTo(el.audio.currentTime + s);
    }
  };

  const cycleSpeed = () => {
    const sp = [0.5, 0.75, 1, 1.25, 1.5, 1.75, 2];
    const i = sp.indexOf(state.speed);
    const prev = state.speed;
    state.speed = sp[(i + 1) % sp.length];
    el.audio.playbackRate = state.speed;
    Mem.log('speed_changed', 'settings', { speed: state.speed, prev });
    updatePlayer();
  };

  // === FULLSCREEN PLAYER FEATURES ===

  // Speed slider control
  const setSpeed = (speed) => {
    const prev = state.speed;
    state.speed = Math.round(speed * 100) / 100;
    state.speed = Math.max(0.5, Math.min(3, state.speed));
    el.audio.playbackRate = state.speed;
    el.expSpeedSlider.value = state.speed;
    el.expSpeedValue.textContent = state.speed.toFixed(2) + 'x';
    el.pSpeed.textContent = state.speed + 'x';
    // Update preset buttons
    document.querySelectorAll('.speed-preset').forEach(btn => {
      btn.classList.toggle('active', parseFloat(btn.dataset.speed) === state.speed);
    });
    if (prev !== state.speed) {
      Mem.log('speed_changed', 'settings', { speed: state.speed, prev });
      save();
    }
    updateMediaSession();
  };

  // Adaptive background colors from artwork
  const extractColors = (img) => {
    try {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = 50;
      canvas.height = 50;
      ctx.drawImage(img, 0, 0, 50, 50);
      const data = ctx.getImageData(0, 0, 50, 50).data;

      // Sample colors from different regions
      let colors = [];
      const samplePoints = [[10, 10], [40, 10], [10, 40], [40, 40], [25, 25]];

      for (const [x, y] of samplePoints) {
        const i = (y * 50 + x) * 4;
        colors.push({ r: data[i], g: data[i + 1], b: data[i + 2] });
      }

      // Find dominant dark color for gradient
      const avgColor = colors.reduce((acc, c) => {
        acc.r += c.r / colors.length;
        acc.g += c.g / colors.length;
        acc.b += c.b / colors.length;
        return acc;
      }, { r: 0, g: 0, b: 0 });

      // Darken for background
      const darkColor = `rgb(${Math.floor(avgColor.r * 0.3)}, ${Math.floor(avgColor.g * 0.3)}, ${Math.floor(avgColor.b * 0.3)})`;
      const midColor = `rgb(${Math.floor(avgColor.r * 0.15)}, ${Math.floor(avgColor.g * 0.15)}, ${Math.floor(avgColor.b * 0.15)})`;

      return { top: darkColor, bottom: midColor };
    } catch (e) {
      return { top: '#1a1a2e', bottom: '#0a0a0a' };
    }
  };

  const updateAdaptiveBackground = () => {
    if (!el.expArt.complete || !el.expArt.naturalWidth) {
      // Image not loaded yet, use default
      el.expanded.style.setProperty('--exp-color1', '#1a1a2e');
      el.expanded.style.setProperty('--exp-color2', '#0a0a0a');
      return;
    }

    try {
      const colors = extractColors(el.expArt);
      el.expanded.style.setProperty('--exp-color1', colors.top);
      el.expanded.style.setProperty('--exp-color2', colors.bottom);
    } catch (e) {
      // CORS or other error - use defaults
      el.expanded.style.setProperty('--exp-color1', '#1a1a2e');
      el.expanded.style.setProperty('--exp-color2', '#0a0a0a');
    }
  };

  el.expArt.onload = updateAdaptiveBackground;

  // Swipe on artwork for variable seeking
  let swipeState = { active: false, startX: 0, startTime: 0, lastSkip: 0 };

  const handleSwipeStart = (e) => {
    const touch = e.touches ? e.touches[0] : e;
    swipeState = {
      active: true,
      startX: touch.clientX,
      startTime: el.audio.currentTime,
      lastSkip: 0
    };
    el.expArt.classList.add('swiping');
  };

  const handleSwipeMove = (e) => {
    if (!swipeState.active || !state.currentEp) return;
    const touch = e.touches ? e.touches[0] : e;
    const diff = touch.clientX - swipeState.startX;

    // Variable skip: more distance = bigger skip
    // Short swipe (< 50px) = 5s, medium (50-100px) = 15s, long (> 100px) = 30s+
    const absDiff = Math.abs(diff);
    let skipSeconds;
    if (absDiff < 30) {
      skipSeconds = 0;
    } else if (absDiff < 60) {
      skipSeconds = 5;
    } else if (absDiff < 100) {
      skipSeconds = 15;
    } else if (absDiff < 150) {
      skipSeconds = 30;
    } else {
      skipSeconds = 60;
    }

    // Right swipe = rewind (negative), Left swipe = forward (positive)
    // Note: Libby uses right=rewind, left=forward
    if (diff > 0) {
      skipSeconds = -skipSeconds; // Swipe right = rewind
    }

    swipeState.lastSkip = skipSeconds;

    // Update visual feedback
    const translateX = Math.max(-50, Math.min(50, diff * 0.2));
    el.expArt.style.transform = `translateX(${translateX}px)`;

    // Show swipe indicator
    if (skipSeconds !== 0) {
      if (skipSeconds < 0) {
        el.swipeIndicatorLeft.textContent = `${skipSeconds}s`;
        el.swipeIndicatorLeft.classList.add('visible');
        el.swipeIndicatorRight.classList.remove('visible');
      } else {
        el.swipeIndicatorRight.textContent = `+${skipSeconds}s`;
        el.swipeIndicatorRight.classList.add('visible');
        el.swipeIndicatorLeft.classList.remove('visible');
      }
    } else {
      el.swipeIndicatorLeft.classList.remove('visible');
      el.swipeIndicatorRight.classList.remove('visible');
    }
  };

  const handleSwipeEnd = () => {
    if (!swipeState.active) return;
    swipeState.active = false;
    el.expArt.classList.remove('swiping');
    el.expArt.style.transform = '';
    el.swipeIndicatorLeft.classList.remove('visible');
    el.swipeIndicatorRight.classList.remove('visible');

    if (swipeState.lastSkip !== 0 && state.currentEp) {
      skip(swipeState.lastSkip);
      // Haptic feedback if available
      if (navigator.vibrate) {
        navigator.vibrate(10);
      }
    }
  };

  // Progress bar scrubbing with preview
  let isScrubbing = false;

  const handleScrubStart = (e) => {
    isScrubbing = true;
    handleScrubMove(e);
  };

  const handleScrubMove = (e) => {
    if (!isScrubbing || !state.currentEp) return;
    const bar = el.expTopBar;
    const rect = bar.getBoundingClientRect();
    const touch = e.touches ? e.touches[0] : e;
    const x = Math.max(0, Math.min(rect.width, touch.clientX - rect.left));
    const pct = x / rect.width;
    const duration = el.audio.duration || state.currentEp.duration;
    const previewTime = pct * duration;

    // Show preview
    el.expScrubPreview.textContent = fmt(previewTime);
    el.expScrubPreview.style.left = `${(x / rect.width) * 100}%`;
    el.expScrubPreview.classList.add('visible');

    // Visual feedback on fill
    el.expTopFill.style.width = `${pct * 100}%`;
  };

  const handleScrubEnd = (e) => {
    if (!isScrubbing || !state.currentEp) return;
    isScrubbing = false;
    el.expScrubPreview.classList.remove('visible');

    const bar = el.expTopBar;
    const rect = bar.getBoundingClientRect();
    const touch = e.changedTouches ? e.changedTouches[0] : e;
    const x = Math.max(0, Math.min(rect.width, touch.clientX - rect.left));
    const pct = x / rect.width;
    const duration = el.audio.duration || state.currentEp.duration;

    seekTo(pct * duration);
  };

  // Sleep Timer
  const setSleepTimer = (minutes) => {
    clearSleepTimer();

    if (minutes === 'off' || !minutes) {
      el.expSleepBtn.classList.remove('active');
      updateSleepTimerDisplay();
      toast('Sleep timer off');
      return;
    }

    if (minutes === 'end') {
      // End of episode
      state.sleepTimer = { type: 'end', endTime: null };
      el.expSleepBtn.classList.add('active');
      toast('Will pause at end of episode');
      updateSleepTimerDisplay();
      return;
    }

    const mins = parseInt(minutes);
    if (isNaN(mins)) return;

    const endTime = Date.now() + mins * 60 * 1000;
    const fadeStart = endTime - 15000; // Start fading 15 seconds before

    state.sleepTimer = { type: 'minutes', endTime, fadeStart, originalVolume: el.audio.volume };
    el.expSleepBtn.classList.add('active');

    // Start timer interval
    state.sleepTimerInterval = setInterval(() => {
      const now = Date.now();

      if (now >= state.sleepTimer.endTime) {
        el.audio.pause();
        clearSleepTimer();
        el.audio.volume = state.sleepTimer.originalVolume || 1;
        toast('Sleep timer: Paused');
      } else if (now >= state.sleepTimer.fadeStart) {
        // Gradual fade out
        const remaining = (state.sleepTimer.endTime - now) / 15000;
        el.audio.volume = Math.max(0, (state.sleepTimer.originalVolume || 1) * remaining);
      }

      updateSleepTimerDisplay();
    }, 1000);

    toast(`Sleep timer: ${mins} minutes`);
    updateSleepTimerDisplay();
  };

  const clearSleepTimer = () => {
    if (state.sleepTimerInterval) {
      clearInterval(state.sleepTimerInterval);
      state.sleepTimerInterval = null;
    }
    if (state.sleepTimer?.originalVolume) {
      el.audio.volume = state.sleepTimer.originalVolume;
    }
    state.sleepTimer = null;
    el.expSleepBtn.classList.remove('active');
    // Remove countdown badge
    const badge = el.expSleepBtn.querySelector('.countdown-badge');
    if (badge) badge.remove();
  };

  const updateSleepTimerDisplay = () => {
    // Remove existing badge
    const existingBadge = el.expSleepBtn.querySelector('.countdown-badge');
    if (existingBadge) existingBadge.remove();

    if (!state.sleepTimer) return;

    if (state.sleepTimer.type === 'end') {
      const badge = document.createElement('span');
      badge.className = 'countdown-badge';
      badge.textContent = 'END';
      el.expSleepBtn.appendChild(badge);
    } else if (state.sleepTimer.endTime) {
      const remaining = Math.max(0, Math.ceil((state.sleepTimer.endTime - Date.now()) / 60000));
      if (remaining > 0) {
        const badge = document.createElement('span');
        badge.className = 'countdown-badge';
        badge.textContent = remaining + 'm';
        el.expSleepBtn.appendChild(badge);
      }
    }
  };

  // Check for end-of-episode sleep timer
  el.audio.addEventListener('ended', () => {
    if (state.sleepTimer?.type === 'end') {
      clearSleepTimer();
      toast('Sleep timer: Paused at end');
    }
  });

  // Bookmarks
  const addBookmark = (note = '') => {
    if (!state.currentEp) return;

    const epId = state.currentEp.id;
    const time = el.audio.currentTime;

    if (!state.bookmarks[epId]) {
      state.bookmarks[epId] = [];
    }

    // Check if bookmark already exists near this time (within 3 seconds)
    const existing = state.bookmarks[epId].find(b => Math.abs(b.time - time) < 3);
    if (existing) {
      toast('Bookmark already exists here');
      return;
    }

    state.bookmarks[epId].push({
      time,
      note,
      created: new Date().toISOString()
    });

    // Sort by time
    state.bookmarks[epId].sort((a, b) => a.time - b.time);

    save();
    renderBookmarkMarkers();
    toast(`Bookmark added at ${fmt(time)}`);

    // Haptic feedback
    if (navigator.vibrate) navigator.vibrate(15);
  };

  const deleteBookmark = (time) => {
    if (!state.currentEp) return;

    const epId = state.currentEp.id;
    if (!state.bookmarks[epId]) return;

    state.bookmarks[epId] = state.bookmarks[epId].filter(b => b.time !== time);
    save();
    renderBookmarkMarkers();
    renderBookmarksList();
  };

  const jumpToBookmark = (time) => {
    seekTo(time);
    closeBookmarksPanel();
  };

  const renderBookmarkMarkers = () => {
    // Remove existing markers
    el.expTopBar.querySelectorAll('.bookmark-marker').forEach(m => m.remove());

    if (!state.currentEp) return;

    const bookmarks = state.bookmarks[state.currentEp.id] || [];
    const duration = el.audio.duration || state.currentEp.duration;

    bookmarks.forEach(b => {
      const marker = document.createElement('div');
      marker.className = 'bookmark-marker';
      marker.style.left = `${(b.time / duration) * 100}%`;
      marker.title = `${fmt(b.time)}${b.note ? ': ' + b.note : ''}`;
      marker.onclick = (e) => {
        e.stopPropagation();
        seekTo(b.time);
      };
      el.expTopBar.appendChild(marker);
    });
  };

  const renderBookmarksList = () => {
    if (!state.currentEp) {
      el.bookmarksList.innerHTML = '<div class="bookmarks-empty">No episode playing</div>';
      return;
    }

    const bookmarks = state.bookmarks[state.currentEp.id] || [];

    if (!bookmarks.length) {
      el.bookmarksList.innerHTML = '<div class="bookmarks-empty">No bookmarks yet. Tap the + bookmark icon to add one.</div>';
      return;
    }

    el.bookmarksList.innerHTML = bookmarks.map(b => `
      <div class="bookmark-item" data-time="${b.time}">
        <div class="bookmark-item-info">
          <div class="bookmark-item-time">${fmt(b.time)}</div>
          ${b.note ? `<div class="bookmark-item-note">${b.note}</div>` : ''}
        </div>
        <button class="bookmark-item-delete" data-time="${b.time}">
          <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2" transform="scale(0.67)"/></svg>
        </button>
      </div>
    `).join('');
  };

  const openSleepPanel = () => {
    el.sleepBackdrop.classList.add('active');
    el.sleepPanel.classList.add('active');
    // Update active state
    document.querySelectorAll('.sleep-option').forEach(opt => opt.classList.remove('active'));
    if (!state.sleepTimer) {
      document.querySelector('.sleep-option[data-minutes="off"]')?.classList.add('active');
    } else if (state.sleepTimer.type === 'end') {
      document.querySelector('.sleep-option[data-minutes="end"]')?.classList.add('active');
    }
  };

  const closeSleepPanel = () => {
    el.sleepBackdrop.classList.remove('active');
    el.sleepPanel.classList.remove('active');
  };

  const openBookmarksPanel = () => {
    renderBookmarksList();
    el.bookmarksPanel.classList.add('active');
    el.sleepBackdrop.classList.add('active');
  };

  const closeBookmarksPanel = () => {
    el.bookmarksPanel.classList.remove('active');
    el.sleepBackdrop.classList.remove('active');
  };

  // Media Session API for lock screen controls
  const updateMediaSession = () => {
    if (!('mediaSession' in navigator)) return;
    if (!state.currentEp) return;

    const show = state.feeds.find(f => f.id === state.currentEp.feedId);
    const artworkUrl = state.currentEp.image || show?.image || '';

    try {
      navigator.mediaSession.metadata = new MediaMetadata({
        title: state.currentEp.title,
        artist: show?.name || 'Unknown',
        album: show?.name || 'Podcast',
        artwork: artworkUrl ? [
          { src: artworkUrl, sizes: '96x96', type: 'image/png' },
          { src: artworkUrl, sizes: '128x128', type: 'image/png' },
          { src: artworkUrl, sizes: '192x192', type: 'image/png' },
          { src: artworkUrl, sizes: '256x256', type: 'image/png' },
          { src: artworkUrl, sizes: '512x512', type: 'image/png' }
        ] : []
      });

      navigator.mediaSession.playbackState = state.playing ? 'playing' : 'paused';
    } catch (e) {
      console.warn('Media Session metadata error:', e);
    }
  };

  const updatePositionState = () => {
    if (!('mediaSession' in navigator)) return;
    if (!state.currentEp) return;
    if (!el.audio.duration || isNaN(el.audio.duration)) return;

    try {
      navigator.mediaSession.setPositionState({
        duration: el.audio.duration,
        playbackRate: el.audio.playbackRate,
        position: el.audio.currentTime
      });
    } catch (e) {
      // Ignore position state errors
    }
  };

  const initMediaSession = () => {
    if (!('mediaSession' in navigator)) return;

    const actions = [
      ['play', () => { el.audio.play(); }],
      ['pause', () => { el.audio.pause(); }],
      ['seekbackward', (details) => { skip(-(details.seekOffset || 15)); }],
      ['seekforward', (details) => { skip(details.seekOffset || 30); }],
      ['seekto', (details) => { if (details.seekTime !== undefined) seekTo(details.seekTime); }],
      ['previoustrack', () => { playPreviousEpisode(); }],
      ['nexttrack', () => { playNextEpisode(); }]
    ];

    for (const [action, handler] of actions) {
      try {
        navigator.mediaSession.setActionHandler(action, handler);
      } catch (e) {
        console.log(`Media Session action "${action}" not supported`);
      }
    }
  };

  // Episode navigation
  const playNextEpisode = () => {
    if (!state.currentEp) return;
    const idx = state.podcasts.findIndex(p => p.id === state.currentEp.id);
    if (idx > 0) {
      playEp(state.podcasts[idx - 1].id); // Next is earlier in sorted list
    } else {
      toast('No next episode');
    }
  };

  const playPreviousEpisode = () => {
    if (!state.currentEp) return;
    const idx = state.podcasts.findIndex(p => p.id === state.currentEp.id);
    if (idx < state.podcasts.length - 1) {
      playEp(state.podcasts[idx + 1].id); // Previous is later in sorted list
    } else {
      toast('No previous episode');
    }
  };

  // Initialize Media Session
  initMediaSession();

  // === EVENTS ===
  document.querySelector('.main-toggle').onclick = e => {
    const btn = e.target.closest('.toggle-btn');
    if (!btn) return;
    document.querySelectorAll('.toggle-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    const prev = state.view;
    state.view = btn.dataset.view;
    Mem.log('view_changed', 'view_' + state.view, { prev });
    el.newsView.classList.toggle('active', state.view === 'news');
    el.podcastView.classList.toggle('active', state.view === 'podcasts');
    if (state.view === 'podcasts') renderPodcasts();
  };
  
  el.newsSources.onclick = e => {
    const src = e.target.closest('.source-item');
    if (!src) return;
    const id = src.dataset.id;
    state.selectedSource = id === 'all' ? null : parseInt(id);
    el.newsTitle.textContent = id === 'all' ? 'All Articles' : state.feeds.find(f => f.id === state.selectedSource)?.name || '';
    renderNewsSources(); renderNews();
  };
  
  el.categoryChips.onclick = e => {
    const chip = e.target.closest('.chip');
    if (!chip) return;
    const prev = state.selectedCat;
    state.selectedCat = chip.dataset.cat;
    Mem.log('category_changed', 'cat_' + state.selectedCat, { prev });
    renderCategories(); renderNews();
  };
  
  el.newsList.onclick = e => {
    const item = e.target.closest('.article');
    if (!item) return;
    const id = parseInt(item.dataset.id);
    const art = state.articles.find(a => a.id === id);
    if (art) { Mem.log('article_opened', 'art_' + id, { source: art.feedId }); toast('Opening article...'); }
  };
  
  document.querySelector('.podcast-nav').onclick = e => {
    const btn = e.target.closest('.nav-btn');
    if (!btn) return;
    document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    state.tab = btn.dataset.tab;
    el.showPage.classList.remove('active');
    renderPodcasts();
  };
  
  el.podcastContent.onclick = e => {
    const card = e.target.closest('.show-card');
    if (card) { renderShowPage(parseInt(card.dataset.show)); return; }
    const playBtn = e.target.closest('.ep-play');
    if (playBtn) { playEp(parseInt(playBtn.dataset.ep)); return; }
    const ep = e.target.closest('.episode');
    if (ep && !e.target.closest('.ep-dl')) { playEp(parseInt(ep.dataset.ep)); return; }
    const dl = e.target.closest('.ep-dl');
    if (dl) { const id = parseInt(dl.dataset.dl); const p = state.podcasts.find(x => x.id === id); if (p) { p.downloaded = !p.downloaded; if (p.downloaded) Mem.log('download_requested', 'ep_' + id); save(); renderPodcasts(); toast(p.downloaded ? 'Downloaded' : 'Removed'); } }
  };
  
  el.showPage.onclick = e => {
    const playBtn = e.target.closest('.ep-play');
    if (playBtn) { playEp(parseInt(playBtn.dataset.ep)); return; }
    const showPlay = e.target.closest('.show-play');
    if (showPlay) { const eps = state.podcasts.filter(p => p.feedId === parseInt(showPlay.dataset.show)); if (eps.length) playEp(eps[0].id); return; }
    const ep = e.target.closest('.episode');
    if (ep && !e.target.closest('.ep-dl')) { playEp(parseInt(ep.dataset.ep)); return; }
    const dl = e.target.closest('.ep-dl');
    if (dl) { const id = parseInt(dl.dataset.dl); const p = state.podcasts.find(x => x.id === id); if (p) { p.downloaded = !p.downloaded; save(); renderShowPage(p.feedId); toast(p.downloaded ? 'Downloaded' : 'Removed'); } }
  };
  
  el.pPlay.onclick = togglePlay;
  el.expPlay.onclick = togglePlay;
  el.pSpeed.onclick = cycleSpeed;
  $('pSkipBack').onclick = () => skip(-15);
  $('pSkipFwd').onclick = () => skip(30);
  $('expBack').onclick = () => skip(-15);
  $('expFwd').onclick = () => skip(30);
  el.pBar.onclick = e => { if (!state.currentEp) return; const r = el.pBar.getBoundingClientRect(); seekTo((e.clientX - r.left) / r.width * state.currentEp.duration); };
  $('pExpand').onclick = () => el.expanded.classList.add('active');
  $('expClose').onclick = () => el.expanded.classList.remove('active');
  el.playerArt.onclick = () => el.expanded.classList.add('active');

  // === FULLSCREEN PLAYER EVENT HANDLERS ===

  // Swipe gestures on artwork
  el.expArtContainer.addEventListener('mousedown', handleSwipeStart);
  el.expArtContainer.addEventListener('touchstart', handleSwipeStart, { passive: true });
  document.addEventListener('mousemove', handleSwipeMove);
  document.addEventListener('touchmove', handleSwipeMove, { passive: true });
  document.addEventListener('mouseup', handleSwipeEnd);
  document.addEventListener('touchend', handleSwipeEnd);

  // Progress bar scrubbing
  el.expTopBar.addEventListener('mousedown', handleScrubStart);
  el.expTopBar.addEventListener('touchstart', handleScrubStart, { passive: true });
  document.addEventListener('mousemove', handleScrubMove);
  document.addEventListener('touchmove', handleScrubMove, { passive: true });
  document.addEventListener('mouseup', handleScrubEnd);
  document.addEventListener('touchend', handleScrubEnd);

  // Triple-tap on percentage to toggle time/percentage display
  let pctTapCount = 0;
  let pctTapTimeout = null;
  el.expTopPct.onclick = () => {
    pctTapCount++;
    if (pctTapCount >= 3) {
      state.showTimeAsPercent = !state.showTimeAsPercent;
      updatePlayer();
      toast(state.showTimeAsPercent ? 'Showing percentage' : 'Showing time remaining');
      pctTapCount = 0;
    }
    clearTimeout(pctTapTimeout);
    pctTapTimeout = setTimeout(() => { pctTapCount = 0; }, 500);
  };

  // Speed control button and slider
  el.expSpeedBtn.onclick = () => {
    const isVisible = el.expSpeedSection.style.display !== 'none';
    el.expSpeedSection.style.display = isVisible ? 'none' : 'block';
    el.expSpeedBtn.classList.toggle('active', !isVisible);
  };

  el.expSpeedSlider.oninput = (e) => {
    setSpeed(parseFloat(e.target.value));
  };

  // Speed preset buttons
  document.querySelectorAll('.speed-preset').forEach(btn => {
    btn.onclick = () => setSpeed(parseFloat(btn.dataset.speed));
  });

  // Sleep timer button and panel
  el.expSleepBtn.onclick = openSleepPanel;
  $('sleepPanelClose').onclick = closeSleepPanel;
  el.sleepBackdrop.onclick = () => {
    closeSleepPanel();
    closeBookmarksPanel();
  };

  // Sleep timer options
  document.querySelectorAll('.sleep-option').forEach(opt => {
    opt.onclick = () => {
      setSleepTimer(opt.dataset.minutes);
      closeSleepPanel();
    };
  });

  // Custom sleep timer
  el.sleepCustomSet.onclick = () => {
    const mins = parseInt(el.sleepCustomMin.value);
    if (mins > 0) {
      setSleepTimer(mins);
      el.sleepCustomMin.value = '';
      closeSleepPanel();
    }
  };

  // Bookmarks buttons and panel
  el.expBookmarksBtn.onclick = openBookmarksPanel;
  el.expAddBookmarkBtn.onclick = () => addBookmark();
  $('bookmarksPanelClose').onclick = closeBookmarksPanel;

  // Bookmarks list interactions
  el.bookmarksList.onclick = (e) => {
    const deleteBtn = e.target.closest('.bookmark-item-delete');
    if (deleteBtn) {
      e.stopPropagation();
      deleteBookmark(parseFloat(deleteBtn.dataset.time));
      return;
    }
    const item = e.target.closest('.bookmark-item');
    if (item) {
      jumpToBookmark(parseFloat(item.dataset.time));
    }
  };

  // Chapter skip buttons (prev/next episode)
  $('expPrevChapter').onclick = playPreviousEpisode;
  $('expNextChapter').onclick = playNextEpisode;
  
  $('refreshBtn').onclick = () => refreshAllFeeds();
  $('addBtn').onclick = () => el.modal.classList.add('active');
  $('addNewsBtn').onclick = () => { $('tNews').click(); el.modal.classList.add('active'); };
  $('modalClose').onclick = () => el.modal.classList.remove('active');
  el.modal.onclick = e => { if (e.target === el.modal) el.modal.classList.remove('active'); };
  $('tNews').onclick = () => { state.feedType = 'news'; $('tNews').classList.add('active'); $('tPodcast').classList.remove('active'); };
  $('tPodcast').onclick = () => { state.feedType = 'podcast'; $('tPodcast').classList.add('active'); $('tNews').classList.remove('active'); };

  // Form validation and state
  let metadataFetched = false;
  const validateForm = () => {
    const hasUrl = el.fUrl.value.trim().length > 0;
    el.fFetch.disabled = !hasUrl;
    el.fSubmit.disabled = !hasUrl;
  };

  const setFetchStatus = (message, type) => {
    el.fStatus.textContent = message;
    el.fStatus.className = 'fetch-status ' + (type || '');
  };

  const setFormDisabled = (disabled) => {
    el.fUrl.disabled = disabled;
    el.fName.disabled = disabled;
    el.fAuthor.disabled = disabled;
    el.fCat.disabled = disabled;
    el.fFetch.disabled = disabled;
  };

  // Fetch metadata when button is clicked
  el.fFetch.onclick = async () => {
    const url = el.fUrl.value.trim();
    if (!url) return;

    // Show loading state
    el.fFetch.disabled = true;
    el.fFetch.textContent = 'Fetching...';
    el.fFetch.classList.add('loading');
    setFetchStatus('Fetching feed metadata...', 'loading');

    const result = await fetchFeedMetadata(url);

    el.fFetch.textContent = 'Fetch';
    el.fFetch.classList.remove('loading');
    el.fFetch.disabled = false;

    if (result.success) {
      // Pre-populate form fields with fetched metadata
      if (result.title && !el.fName.value.trim()) {
        el.fName.value = result.title;
      }
      if (result.author && !el.fAuthor.value.trim()) {
        el.fAuthor.value = result.author;
      }

      // Auto-select feed type based on content
      if (result.suggestedType === 'podcast') {
        state.feedType = 'podcast';
        $('tPodcast').classList.add('active');
        $('tNews').classList.remove('active');
      } else {
        state.feedType = 'news';
        $('tNews').classList.add('active');
        $('tPodcast').classList.remove('active');
      }

      metadataFetched = true;
      setFetchStatus('Metadata loaded! You can edit the fields below.', 'success');
    } else {
      setFetchStatus('Failed to fetch: ' + (result.error || 'Unknown error'), 'error');
    }
  };

  // Also fetch on URL blur if we haven't fetched yet
  el.fUrl.onblur = () => {
    const url = el.fUrl.value.trim();
    if (url && !metadataFetched && url.startsWith('http')) {
      el.fFetch.click();
    }
  };

  el.fUrl.oninput = () => {
    metadataFetched = false; // Reset when URL changes
    setFetchStatus('', '');
    validateForm();
  };
  el.fName.oninput = validateForm;
  el.fAuthor.oninput = validateForm;

  el.fSubmit.onclick = async () => {
    const url = el.fUrl.value.trim();
    const name = el.fName.value.trim();
    const author = el.fAuthor.value.trim();
    const cat = el.fCat.value.trim() || 'Uncategorized';
    if (!url) return;

    // Disable form while adding
    el.fSubmit.disabled = true;
    el.fSubmit.textContent = 'Adding...';
    setFormDisabled(true);

    await addFeed(url, name, state.feedType, cat, author);

    // Reset form
    el.fUrl.value = '';
    el.fName.value = '';
    el.fAuthor.value = '';
    el.fCat.value = '';
    el.fSubmit.textContent = 'Add Feed';
    el.fSubmit.disabled = true;
    setFormDisabled(false);
    setFetchStatus('', '');
    metadataFetched = false;
    el.modal.classList.remove('active');
  };
  
  let searchTO;
  el.searchInput.oninput = e => { clearTimeout(searchTO); searchTO = setTimeout(() => { state.query = e.target.value; if (state.view === 'news') renderNews(); }, 200); };
  
  // Keyboard shortcuts
  document.onkeydown = e => {
    if (e.target.tagName === 'INPUT') return;

    // Basic playback
    if (e.code === 'Space') { e.preventDefault(); togglePlay(); }
    if (e.code === 'ArrowLeft') skip(-15);
    if (e.code === 'ArrowRight') skip(30);

    // Fullscreen player shortcuts
    if (e.code === 'KeyF' || e.code === 'Escape') {
      if (e.code === 'KeyF' && !el.expanded.classList.contains('active')) {
        el.expanded.classList.add('active');
      } else if (el.expanded.classList.contains('active')) {
        el.expanded.classList.remove('active');
      }
    }
    if (e.code === 'KeyB' && state.currentEp) { addBookmark(); }
    if (e.code === 'KeyS') {
      // Toggle speed section in fullscreen
      if (el.expanded.classList.contains('active')) {
        el.expSpeedBtn.click();
      }
    }
    if (e.code === 'KeyM') {
      // Open sleep timer panel
      if (el.expanded.classList.contains('active')) {
        openSleepPanel();
      }
    }
    // Speed presets
    if (e.key >= '1' && e.key <= '5' && e.ctrlKey) {
      e.preventDefault();
      const speeds = [0.75, 1, 1.25, 1.5, 2];
      setSpeed(speeds[parseInt(e.key) - 1]);
    }
    // Fine speed adjustment
    if (e.code === 'BracketLeft') setSpeed(state.speed - 0.05);
    if (e.code === 'BracketRight') setSpeed(state.speed + 0.05);
    // Episode navigation
    if (e.code === 'KeyN' && e.shiftKey) playNextEpisode();
    if (e.code === 'KeyP' && e.shiftKey) playPreviousEpisode();
  };
  
  // === INIT ===
  load();
  renderNewsSources();
  renderCategories();
  renderNews();
  
  console.log('Feedr loaded');
  console.log('Memory API: Memory.setEndpoint(url), Memory.getLocal()');
})();
</script>
</body>
</html>
