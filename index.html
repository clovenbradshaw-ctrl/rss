<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#0a0a0a">
  <title>BURSST</title>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/@phosphor-icons/web"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    :root {
      /* Dark mode palette - cozy, not harsh */
      --bg: #0a0a0a; --bg2: #111111; --bg3: #1a1a1a; --bg4: #1f1f1f;
      /* Soft borders using opacity for depth */
      --border: rgba(255,255,255,0.06); --border2: rgba(255,255,255,0.1);
      /* Text hierarchy */
      --text: #ffffff; --text2: #a1a1a1; --text3: #666;
      /* Accent colors */
      --orange: #FF6B35; --orange2: #FF8E72;
      --blue: #3b82f6; --blue2: #60a5fa;
      /* Legacy compatibility */
      --green: var(--orange); --green2: var(--orange2);

      /* Mobile-specific spacing scale */
      --mobile-space-xs: 8px;
      --mobile-space-sm: 12px;
      --mobile-space-md: 16px;
      --mobile-space-lg: 20px;
      --mobile-space-xl: 24px;
      --mobile-space-2xl: 32px;

      /* Mobile touch targets */
      --mobile-touch-min: 44px;
      --mobile-touch-comfortable: 48px;
      --mobile-touch-large: 56px;

      /* Mobile typography scale */
      --mobile-text-xs: 12px;
      --mobile-text-sm: 13px;
      --mobile-text-base: 15px;
      --mobile-text-md: 16px;
      --mobile-text-lg: 17px;
      --mobile-text-xl: 18px;
      --mobile-text-2xl: 20px;
      --mobile-text-3xl: 24px;
      --mobile-text-4xl: 28px;

      /* Safe area insets (iOS notch/home indicator) */
      --sat: env(safe-area-inset-top);
      --sar: env(safe-area-inset-right);
      --sab: env(safe-area-inset-bottom);
      --sal: env(safe-area-inset-left);

      /* Mobile-specific z-index layers */
      --z-mobile-header: 100;
      --z-mobile-nav: 90;
      --z-mobile-player: 95;
      --z-mobile-drawer: 150;
      --z-mobile-modal: 200;
      --z-mobile-toast: 300;
    }
    html, body { height: 100%; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; background: var(--bg); color: var(--text); overflow: hidden; }
    ::-webkit-scrollbar { width: 8px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.15); border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.25); }
    
    .app { display: flex; flex-direction: column; height: 100vh; }
    
    /* Header - Soft dark with subtle border */
    .header { background: var(--bg3); border-bottom: 1px solid var(--border2); padding: 16px 24px; display: flex; align-items: center; gap: 16px; }
    .logo { font-size: 24px; font-weight: 800; letter-spacing: -0.03em; color: var(--text); }
    .logo-rss { color: var(--orange); }
    .main-toggle { display: flex; background: var(--bg4); border-radius: 28px; padding: 4px; border: 1px solid var(--border2); }
    .toggle-btn { padding: 10px 20px; background: transparent; border: none; border-radius: 24px; color: var(--text2); font-size: 14px; font-weight: 600; cursor: pointer; font-family: inherit; display: flex; align-items: center; gap: 8px; transition: all 0.2s ease-out; }
    .toggle-btn.active { background: var(--blue); color: #fff; box-shadow: 0 2px 8px rgba(59,130,246,0.3); }
    .toggle-btn:not(.active):hover { background: rgba(255,255,255,0.05); color: var(--text); }
    .spacer { flex: 1; }
    .search-box { max-width: 280px; flex: 1; position: relative; }
    .search-box input { width: 100%; padding: 10px 16px 10px 40px; background: var(--bg4); border: 1px solid var(--border2); border-radius: 24px; color: var(--text); font-size: 14px; font-family: inherit; transition: all 0.2s; }
    .search-box input:focus { outline: none; border-color: var(--blue); background: var(--bg); }
    .search-box input::placeholder { color: var(--text3); }
    .search-box svg { position: absolute; left: 14px; top: 50%; transform: translateY(-50%); color: var(--text3); }
    .icon-btn { background: none; border: none; color: var(--text2); cursor: pointer; padding: 10px; border-radius: 50%; transition: all 0.15s ease-out; display: flex; align-items: center; justify-content: center; }
    .icon-btn:hover { background: rgba(255,255,255,0.05); color: var(--text); }
    
    /* Main */
    .main { flex: 1; overflow: hidden; }
    
    /* === NEWS VIEW === */
    .news-view { display: none; height: 100%; }
    .news-view.active { display: flex; }

    .news-sidebar { width: 260px; background: var(--bg2); border-right: 1px solid var(--border2); display: flex; flex-direction: column; }
    .sidebar-header { padding: 16px 20px; border-bottom: 1px solid var(--border2); display: flex; align-items: center; justify-content: space-between; }
    .sidebar-header h2 { font-size: 12px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text2); }
    .add-btn { background: var(--blue); border: none; color: #fff; width: 28px; height: 28px; border-radius: 50%; cursor: pointer; font-size: 18px; transition: all 0.15s; box-shadow: 0 2px 6px rgba(59,130,246,0.3); }
    .add-btn:hover { background: var(--blue2); transform: scale(1.05); }
    .sidebar-content { flex: 1; overflow-y: auto; padding: 12px; }

    .source-item { display: flex; align-items: center; gap: 12px; padding: 12px; border-radius: 12px; cursor: pointer; margin-bottom: 4px; transition: all 0.15s ease-out; }
    .source-item:hover { background: rgba(255,255,255,0.04); }
    .source-item:hover .source-name { color: var(--blue); }
    .source-item.active { background: var(--bg4); border: 1px solid var(--border2); }
    .source-icon { width: 36px; height: 36px; border-radius: 10px; background: var(--bg3); display: flex; align-items: center; justify-content: center; font-size: 18px; overflow: hidden; flex-shrink: 0; box-shadow: 0 2px 8px rgba(0,0,0,0.2); }
    .source-icon img { width: 100%; height: 100%; object-fit: cover; }
    .source-name { flex: 1; font-size: 14px; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; transition: color 0.15s; }
    .source-badge { background: var(--orange); color: #fff; font-size: 10px; font-weight: 700; padding: 3px 8px; border-radius: 12px; flex-shrink: 0; box-shadow: 0 2px 6px rgba(255,107,53,0.3); }
    .source-arrow { color: var(--text3); opacity: 0; transition: opacity 0.15s; }
    .source-item:hover .source-arrow { opacity: 1; }

    /* New content indicator styles */
    .source-item { position: relative; }
    .source-info { flex: 1; min-width: 0; }
    .source-info .source-name { flex: none; }
    .source-subtitle { font-size: 11px; color: var(--blue); font-weight: 500; margin-top: 2px; }
    .new-indicator { position: absolute; left: 4px; top: 50%; transform: translateY(-50%); width: 6px; height: 6px; background: var(--blue); border-radius: 50%; box-shadow: 0 0 8px var(--blue); }
    .source-item.has-new { padding-left: 16px; }
    .source-item.has-new .source-name { color: var(--text); }

    /* Show card new content indicator */
    .show-card { position: relative; }
    .show-card.has-new .new-indicator { position: absolute; top: 8px; right: 8px; width: 10px; height: 10px; z-index: 1; }
    .show-card .show-new-indicator { color: var(--blue); font-weight: 500; }

    .news-content { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
    .news-list-view { display: flex; flex-direction: column; gap: 12px; }
    .news-header { padding: 16px 24px; border-bottom: 1px solid var(--border2); display: flex; align-items: center; gap: 16px; }
    .news-title { font-size: 20px; font-weight: 600; margin-right: 16px; letter-spacing: -0.02em; }
    .category-chips { display: flex; gap: 8px; overflow-x: auto; flex: 1; }
    .chip { padding: 8px 16px; background: var(--bg4); border: 1px solid var(--border2); border-radius: 20px; color: var(--text2); font-size: 13px; font-weight: 500; cursor: pointer; white-space: nowrap; font-family: inherit; transition: all 0.2s ease-out; }
    .chip:hover { background: rgba(255,255,255,0.08); color: var(--text); border-color: var(--border2); }
    .chip.active { background: var(--blue); border-color: var(--blue); color: #fff; box-shadow: 0 2px 8px rgba(59,130,246,0.3); }

    /* Tag Filter Styles */
    .tag-filter-section { padding: 12px 24px; border-bottom: 1px solid var(--border2); background: var(--bg2); }
    .tag-filter-header { display: flex; align-items: center; gap: 8px; margin-bottom: 10px; }
    .tag-filter-title { font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text3); }
    .tag-chips { display: flex; gap: 8px; overflow-x: auto; padding-bottom: 4px; -webkit-overflow-scrolling: touch; scrollbar-width: none; }
    .tag-chips::-webkit-scrollbar { display: none; }
    .tag-chip { padding: 6px 12px; background: var(--bg4); border: 1px solid var(--border2); border-radius: 16px; color: var(--text2); font-size: 12px; font-weight: 500; cursor: pointer; white-space: nowrap; font-family: inherit; transition: all 0.2s ease-out; display: flex; align-items: center; gap: 5px; }
    .tag-chip:hover { background: rgba(255,255,255,0.08); color: var(--text); border-color: var(--border2); }
    .tag-chip.active { background: var(--blue); border-color: var(--blue); color: #fff; box-shadow: 0 2px 8px rgba(59,130,246,0.3); }
    .tag-chip .tag-icon { font-size: 12px; }
    .tag-chip .tag-count { background: rgba(0,0,0,0.2); padding: 2px 6px; border-radius: 10px; font-size: 10px; margin-left: 2px; }
    .tag-chip.active .tag-count { background: rgba(255,255,255,0.2); }

    /* Item Tags Display */
    .item-tags { display: flex; gap: 4px; margin-top: 6px; flex-wrap: wrap; }
    .item-tag { font-size: 10px; padding: 3px 8px; background: var(--bg4); border-radius: 8px; color: var(--text3); display: flex; align-items: center; gap: 4px; }
    .item-tag-icon { font-size: 10px; }

    .news-list { flex: 1; overflow-y: auto; padding: 16px 24px 120px; }
    .article { display: flex; gap: 16px; padding: 20px; background: var(--bg3); border-radius: 16px; margin-bottom: 12px; cursor: pointer; border: 1px solid var(--border2); transition: all 0.2s ease-out; }
    .article:hover { background: rgba(255,255,255,0.04); border-color: rgba(255,255,255,0.15); box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
    .article.unread { position: relative; }
    .article.unread::after { content: ''; position: absolute; top: 50%; right: 16px; transform: translateY(-50%); width: 8px; height: 8px; background: var(--orange); border-radius: 50%; }
    .article-icon { width: 48px; height: 48px; border-radius: 12px; background: var(--bg4); display: flex; align-items: center; justify-content: center; font-size: 22px; overflow: hidden; flex-shrink: 0; box-shadow: 0 2px 8px rgba(0,0,0,0.15); }
    .article-icon img { width: 100%; height: 100%; object-fit: cover; }
    .article-body { flex: 1; min-width: 0; }
    .article-meta { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; font-size: 13px; }
    .article-source { color: var(--blue); font-weight: 500; cursor: pointer; }
    .article-source:hover { color: var(--blue2); }
    .article-time { color: var(--text3); }
    .article-new { color: var(--orange); font-weight: 600; font-size: 10px; text-transform: uppercase; letter-spacing: 0.5px; }
    .article-title { font-size: 16px; font-weight: 600; line-height: 1.4; margin-bottom: 6px; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
    .article:not(.unread) .article-title { font-weight: 400; color: var(--text2); }
    .article-summary { font-size: 14px; color: var(--text2); line-height: 1.5; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
    .article-image { width: 100px; height: 70px; border-radius: 10px; object-fit: cover; flex-shrink: 0; }
    
    /* === PODCAST VIEW === */
    .podcast-view { display: none; height: 100%; }
    .podcast-view.active { display: flex; }

    /* Podcast Inbox Layout (similar to news) */
    .podcast-sidebar { width: 260px; background: var(--bg2); border-right: 1px solid var(--border2); display: flex; flex-direction: column; }
    .podcast-inbox-content { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
    .podcast-inbox-header { padding: 16px 24px; border-bottom: 1px solid var(--border2); display: flex; align-items: center; gap: 16px; }
    .podcast-inbox-title { font-size: 20px; font-weight: 600; margin-right: 16px; letter-spacing: -0.02em; }
    .podcast-inbox-list { flex: 1; overflow-y: auto; padding: 16px 24px 120px; }

    /* Podcast Episode Item (inbox style) */
    .podcast-episode-item { display: flex; gap: 16px; padding: 20px; background: var(--bg3); border-radius: 16px; margin-bottom: 12px; cursor: pointer; border: 1px solid var(--border2); transition: all 0.2s ease-out; }
    .podcast-episode-item:hover { background: rgba(255,255,255,0.04); border-color: rgba(255,255,255,0.15); box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
    .podcast-episode-item.in-progress { position: relative; }
    .podcast-episode-item.in-progress::after { content: ''; position: absolute; top: 50%; right: 16px; transform: translateY(-50%); width: 8px; height: 8px; background: var(--blue); border-radius: 50%; }
    .podcast-episode-icon { width: 64px; height: 64px; border-radius: 12px; background: var(--bg4); display: flex; align-items: center; justify-content: center; font-size: 28px; overflow: hidden; flex-shrink: 0; box-shadow: 0 2px 8px rgba(0,0,0,0.15); }
    .podcast-episode-icon img { width: 100%; height: 100%; object-fit: cover; }
    .podcast-episode-body { flex: 1; min-width: 0; display: flex; flex-direction: column; justify-content: center; }
    .podcast-episode-meta { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; font-size: 13px; }
    .podcast-episode-show { color: var(--blue); font-weight: 500; cursor: pointer; }
    .podcast-episode-show:hover { color: var(--blue2); }
    .podcast-episode-time { color: var(--text3); }
    .podcast-episode-new { color: var(--orange); font-weight: 600; font-size: 10px; text-transform: uppercase; letter-spacing: 0.5px; }
    .podcast-episode-title { font-size: 16px; font-weight: 600; line-height: 1.4; margin-bottom: 6px; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
    .podcast-episode-item:not(.in-progress) .podcast-episode-title { font-weight: 400; color: var(--text2); }
    .podcast-episode-desc { font-size: 14px; color: var(--text2); line-height: 1.5; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; margin-bottom: 8px; }
    .podcast-episode-footer { display: flex; align-items: center; gap: 12px; }
    .podcast-episode-duration { font-size: 12px; color: var(--text3); display: flex; align-items: center; gap: 4px; }
    .podcast-episode-progress { flex: 1; max-width: 120px; height: 4px; background: var(--bg4); border-radius: 2px; overflow: hidden; }
    .podcast-episode-progress-fill { height: 100%; background: linear-gradient(90deg, var(--blue), var(--blue2)); border-radius: 2px; }
    .podcast-episode-play { width: 36px; height: 36px; border-radius: 50%; background: var(--blue); border: none; color: #fff; cursor: pointer; display: flex; align-items: center; justify-content: center; flex-shrink: 0; transition: all 0.15s; box-shadow: 0 2px 8px rgba(59,130,246,0.3); }
    .podcast-episode-play:hover { background: var(--blue2); transform: scale(1.05); }
    .podcast-episode-image { width: 100px; height: 70px; border-radius: 10px; object-fit: cover; flex-shrink: 0; }

    /* === ALL VIEW === */
    .all-view { display: none; height: 100%; flex-direction: column; }
    .all-view.active { display: flex; }
    .all-content { flex: 1; overflow-y: auto; padding: 24px 32px; padding-bottom: 140px; }
    .all-section { margin-bottom: 36px; }
    .all-section-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px; }
    .all-section-title { font-size: 20px; font-weight: 600; display: flex; align-items: center; gap: 10px; letter-spacing: -0.02em; }
    .all-feed-list { display: flex; flex-direction: column; gap: 12px; }
    .all-item { display: flex; gap: 16px; padding: 20px; background: var(--bg3); border-radius: 16px; cursor: pointer; border: 1px solid var(--border2); transition: all 0.2s ease-out; }
    .all-item:hover { background: rgba(255,255,255,0.04); border-color: rgba(255,255,255,0.15); box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
    .all-item-icon { width: 52px; height: 52px; border-radius: 12px; object-fit: cover; flex-shrink: 0; display: flex; align-items: center; justify-content: center; font-size: 26px; background: var(--bg4); box-shadow: 0 2px 8px rgba(0,0,0,0.2); }
    .all-item-icon img { width: 100%; height: 100%; object-fit: cover; border-radius: 12px; }
    .all-item-body { flex: 1; min-width: 0; display: flex; flex-direction: column; justify-content: center; }
    .all-item-meta { font-size: 13px; color: var(--blue); font-weight: 500; margin-bottom: 4px; display: flex; align-items: center; gap: 8px; }
    .all-item-type { background: var(--bg4); color: var(--text2); padding: 3px 8px; border-radius: 6px; font-size: 10px; text-transform: uppercase; font-weight: 600; letter-spacing: 0.5px; }
    .all-item-title { font-size: 15px; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .all-item-summary { font-size: 13px; color: var(--text3); margin-top: 6px; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; line-height: 1.5; }
    .all-item-time { font-size: 12px; color: var(--text3); }
    .all-item-image { width: 100px; height: 70px; border-radius: 12px; object-fit: cover; flex-shrink: 0; box-shadow: 0 2px 8px rgba(0,0,0,0.2); }

    /* All Content View Modes */
    .all-cards { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 20px; }
    .all-card { background: var(--bg3); border-radius: 16px; overflow: hidden; cursor: pointer; border: 1px solid var(--border2); transition: all 0.2s ease-out; display: flex; flex-direction: column; }
    .all-card:hover { background: rgba(255,255,255,0.04); border-color: rgba(255,255,255,0.15); transform: translateY(-2px); box-shadow: 0 8px 24px rgba(0,0,0,0.2); }
    .all-card-image { width: 100%; height: 180px; object-fit: cover; background: var(--bg4); display: flex; align-items: center; justify-content: center; font-size: 52px; }
    .all-card-image img { width: 100%; height: 100%; object-fit: cover; }
    .all-card-body { padding: 18px; flex: 1; display: flex; flex-direction: column; }
    .all-card-meta { display: flex; align-items: center; gap: 8px; margin-bottom: 10px; font-size: 13px; }
    .all-card-type { background: var(--bg4); color: var(--text2); padding: 3px 8px; border-radius: 6px; font-size: 10px; text-transform: uppercase; font-weight: 600; }
    .all-card-source { color: var(--blue); font-weight: 500; }
    .all-card-time { color: var(--text3); }
    .all-card-title { font-size: 16px; font-weight: 600; line-height: 1.4; margin-bottom: 10px; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
    .all-card-summary { font-size: 14px; color: var(--text2); line-height: 1.5; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden; flex: 1; }

    .all-masonry { column-count: 3; column-gap: 20px; }
    .all-masonry-item { break-inside: avoid; margin-bottom: 20px; background: var(--bg3); border-radius: 16px; overflow: hidden; cursor: pointer; border: 1px solid var(--border2); transition: all 0.2s ease-out; }
    .all-masonry-item:hover { background: rgba(255,255,255,0.04); border-color: rgba(255,255,255,0.15); box-shadow: 0 4px 16px rgba(0,0,0,0.2); }
    .all-masonry-image { width: 100%; object-fit: cover; }
    .all-masonry-body { padding: 18px; }
    .all-masonry-meta { display: flex; align-items: center; gap: 8px; margin-bottom: 10px; font-size: 13px; }
    .all-masonry-type { background: var(--bg4); color: var(--text2); padding: 3px 8px; border-radius: 6px; font-size: 10px; text-transform: uppercase; font-weight: 600; }
    .all-masonry-source { color: var(--blue); font-weight: 500; }
    .all-masonry-time { color: var(--text3); }
    .all-masonry-title { font-size: 16px; font-weight: 600; line-height: 1.4; margin-bottom: 10px; }
    .all-masonry-summary { font-size: 14px; color: var(--text2); line-height: 1.5; }

    .all-table { width: 100%; border-collapse: collapse; }
    .all-table th { text-align: left; padding: 14px 16px; font-size: 12px; font-weight: 600; color: var(--text3); text-transform: uppercase; letter-spacing: 0.5px; border-bottom: 1px solid var(--border2); }
    .all-table td { padding: 14px 16px; border-bottom: 1px solid var(--border); vertical-align: middle; }
    .all-table tr { cursor: pointer; transition: all 0.15s; }
    .all-table tbody tr:hover { background: rgba(255,255,255,0.03); }
    .all-table .table-title { font-weight: 500; max-width: 400px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .all-table .table-type { font-size: 10px; text-transform: uppercase; padding: 3px 8px; border-radius: 6px; background: var(--bg4); color: var(--text2); font-weight: 600; }
    .all-table .table-source { color: var(--blue); font-weight: 500; font-size: 13px; }
    .all-table .table-time { color: var(--text3); font-size: 13px; white-space: nowrap; }

    @media (max-width: 1024px) {
      .all-masonry { column-count: 2; }
    }
    @media (max-width: 640px) {
      .all-masonry { column-count: 1; }
      .all-cards { grid-template-columns: 1fr; }
    }

    /* Social Media Feed Styles */
    .feed-nav { display: flex; background: var(--bg2); border-bottom: 1px solid var(--border2); padding: 0 24px; gap: 4px; }
    .feed-nav-btn { padding: 14px 20px; background: none; border: none; border-bottom: 3px solid transparent; color: var(--text2); font-size: 14px; font-weight: 600; cursor: pointer; font-family: inherit; transition: all 0.2s; display: flex; align-items: center; gap: 8px; }
    .feed-nav-btn:hover { color: var(--text); background: rgba(255,255,255,0.03); }
    .feed-nav-btn.active { color: var(--text); border-bottom-color: var(--blue); }
    .feed-nav-btn .feed-nav-icon { font-size: 16px; }
    .feed-nav-btn .feed-nav-count { font-size: 11px; background: var(--bg4); padding: 2px 8px; border-radius: 10px; color: var(--text3); }
    .feed-nav-btn.active .feed-nav-count { background: rgba(59,130,246,0.2); color: var(--blue); }

    .feed-container { flex: 1; overflow-y: auto; display: flex; justify-content: center; background: var(--bg); }
    .feed-scroll { max-width: 600px; width: 100%; padding: 0; padding-bottom: 140px; }

    /* Social Media Post Card */
    .feed-post { background: var(--bg2); border-bottom: 1px solid var(--border); cursor: pointer; transition: background 0.15s; }
    .feed-post:hover { background: var(--bg3); }
    .feed-post-inner { padding: 16px 20px; }
    .feed-post-header { display: flex; align-items: flex-start; gap: 12px; margin-bottom: 10px; }
    .feed-post-avatar { width: 48px; height: 48px; border-radius: 50%; background: var(--bg4); display: flex; align-items: center; justify-content: center; font-size: 22px; overflow: hidden; flex-shrink: 0; }
    .feed-post-avatar img { width: 100%; height: 100%; object-fit: cover; }
    .feed-post-meta { flex: 1; min-width: 0; }
    .feed-post-source { font-weight: 600; font-size: 15px; color: var(--text); display: flex; align-items: center; gap: 6px; }
    .feed-post-source-name { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .feed-post-type-badge { font-size: 10px; padding: 2px 8px; border-radius: 4px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; }
    .feed-post-type-badge.podcast { background: rgba(139, 92, 246, 0.2); color: #a78bfa; }
    .feed-post-type-badge.news { background: rgba(59, 130, 246, 0.2); color: #60a5fa; }
    .feed-post-handle { font-size: 13px; color: var(--text3); display: flex; align-items: center; gap: 4px; margin-top: 2px; }
    .feed-post-handle span { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .feed-post-dot { color: var(--text3); }
    .feed-post-time { white-space: nowrap; }
    .feed-post-body { padding-left: 60px; }
    .feed-post-title { font-size: 16px; font-weight: 600; line-height: 1.4; margin-bottom: 8px; color: var(--text); display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden; }
    .feed-post-summary { font-size: 15px; color: var(--text2); line-height: 1.5; margin-bottom: 12px; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden; }
    .feed-post-media { border-radius: 16px; overflow: hidden; border: 1px solid var(--border); margin-bottom: 12px; }
    .feed-post-media img { width: 100%; max-height: 300px; object-fit: cover; display: block; }
    .feed-post-actions { display: flex; align-items: center; gap: 24px; padding-top: 8px; }
    .feed-post-action { display: flex; align-items: center; gap: 6px; color: var(--text3); font-size: 13px; transition: color 0.15s; padding: 6px 0; }
    .feed-post-action:hover { color: var(--blue); }
    .feed-post-action svg { width: 18px; height: 18px; }
    .feed-post-tags { display: flex; gap: 6px; flex-wrap: wrap; margin-top: 8px; }
    .feed-post-tag { font-size: 13px; color: var(--blue); }
    .feed-post-tag:hover { text-decoration: underline; }

    /* Podcast-specific post elements */
    .feed-post-duration { display: flex; align-items: center; gap: 6px; font-size: 13px; color: var(--text3); margin-top: 8px; }
    .feed-post-duration svg { width: 16px; height: 16px; }
    .feed-post-play { display: inline-flex; align-items: center; gap: 8px; padding: 10px 20px; background: var(--blue); border-radius: 24px; color: #fff; font-size: 14px; font-weight: 600; margin-top: 12px; transition: all 0.15s; }
    .feed-post-play:hover { background: var(--blue2); transform: scale(1.02); }
    .feed-post-play svg { width: 16px; height: 16px; }

    /* Unread indicator */
    .feed-post.unread .feed-post-source::after { content: ''; width: 8px; height: 8px; background: var(--orange); border-radius: 50%; flex-shrink: 0; }

    /* Empty feed state */
    .feed-empty { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 80px 32px; text-align: center; color: var(--text3); }
    .feed-empty-icon { font-size: 56px; margin-bottom: 16px; }
    .feed-empty-title { font-size: 18px; font-weight: 600; color: var(--text); margin-bottom: 8px; }
    .feed-empty-desc { font-size: 14px; color: var(--text3); }

    @media (max-width: 768px) {
      .feed-nav { padding: 0 12px; overflow-x: auto; }
      .feed-nav-btn { padding: 12px 16px; font-size: 13px; }
      .feed-nav-btn span:not(.feed-nav-icon):not(.feed-nav-count) { display: none; }
      .feed-scroll { padding: 0; }
      .feed-post-inner { padding: 14px 16px; }
      .feed-post-avatar { width: 40px; height: 40px; font-size: 18px; }
      .feed-post-body { padding-left: 52px; }
      .feed-post-title { font-size: 15px; }
      .feed-post-summary { font-size: 14px; }
    }

    .podcast-nav { display: flex; background: var(--bg2); border-bottom: 1px solid var(--border2); padding: 0 24px; }
    .nav-btn { padding: 16px 20px; background: none; border: none; border-bottom: 2px solid transparent; color: var(--text2); font-size: 14px; font-weight: 500; cursor: pointer; font-family: inherit; transition: all 0.15s; }
    .nav-btn:hover { color: var(--text); }
    .nav-btn.active { color: var(--blue); border-bottom-color: var(--blue); }

    .podcast-content { flex: 1; overflow-y: auto; padding: 24px 32px; padding-bottom: 140px; }

    .section { margin-bottom: 36px; }
    .section-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px; }
    .section-title { font-size: 20px; font-weight: 600; letter-spacing: -0.02em; }

    .shows-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 160px)); gap: 24px; }
    .show-card { cursor: pointer; transition: all 0.2s ease-out; max-width: 160px; }
    .show-card:hover { transform: translateY(-4px); }
    .show-art { width: 100%; aspect-ratio: 1; border-radius: 16px; object-fit: cover; margin-bottom: 12px; box-shadow: 0 8px 20px rgba(0,0,0,0.35); }
    .show-name { font-size: 14px; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; line-height: 1.4; }
    .show-author { font-size: 12px; color: var(--text3); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

    .episode-list { display: flex; flex-direction: column; gap: 12px; }
    .episode { display: flex; gap: 16px; padding: 16px; background: var(--bg3); border-radius: 16px; cursor: pointer; border: 1px solid var(--border2); transition: all 0.2s ease-out; }
    .episode:hover { background: rgba(255,255,255,0.04); border-color: rgba(255,255,255,0.15); box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
    .episode-art { width: 64px; height: 64px; border-radius: 12px; object-fit: cover; flex-shrink: 0; box-shadow: 0 2px 8px rgba(0,0,0,0.2); }
    .episode-body { flex: 1; min-width: 0; display: flex; flex-direction: column; justify-content: center; }
    .episode-show { font-size: 13px; color: var(--blue); font-weight: 500; margin-bottom: 4px; cursor: pointer; }
    .episode-show:hover { color: var(--blue2); }
    .episode-title { font-size: 15px; font-weight: 600; margin-bottom: 8px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .episode-footer { display: flex; align-items: center; gap: 12px; }
    .ep-play { width: 32px; height: 32px; border-radius: 50%; background: var(--blue); border: none; color: #fff; cursor: pointer; display: flex; align-items: center; justify-content: center; flex-shrink: 0; transition: all 0.15s; box-shadow: 0 2px 8px rgba(59,130,246,0.3); }
    .ep-play:hover { background: var(--blue2); transform: scale(1.05); }
    .ep-progress { flex: 1; display: flex; align-items: center; gap: 10px; }
    .ep-bar { flex: 1; height: 4px; background: var(--bg4); border-radius: 2px; overflow: hidden; }
    .ep-fill { height: 100%; background: linear-gradient(90deg, var(--blue), var(--blue2)); border-radius: 2px; }
    .ep-time { font-size: 12px; color: var(--text3); white-space: nowrap; font-family: -apple-system, system-ui, monospace; }
    .ep-dl { background: none; border: none; color: var(--text3); cursor: pointer; padding: 6px; min-width: 28px; display: flex; align-items: center; justify-content: center; border-radius: 50%; transition: all 0.15s; }
    .ep-dl:hover { color: var(--text); background: rgba(255,255,255,0.05); }
    .ep-dl.active { color: var(--blue); }
    .ep-dl.downloading { color: var(--blue); cursor: wait; animation: pulse 1.5s ease-in-out infinite; }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    
    /* Show Page & Source Page */
    .show-page, .source-page { display: none; overflow-y: auto; height: 100%; }
    .show-page.active, .source-page.active { display: block; flex: 1; }
    .show-hero, .source-hero { padding: 32px; background: linear-gradient(180deg, rgba(59,130,246,0.15) 0%, var(--bg) 100%); display: flex; gap: 28px; align-items: flex-end; }
    .show-hero-art, .source-hero-art { width: 200px; height: 200px; border-radius: 16px; object-fit: cover; box-shadow: 0 12px 32px rgba(0,0,0,0.5); }
    .show-hero-info, .source-hero-info { flex: 1; }
    .show-hero-type, .source-hero-type { font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 1px; color: var(--blue); margin-bottom: 8px; }
    .show-hero-title, .source-hero-title { font-size: 36px; font-weight: 700; line-height: 1.1; margin-bottom: 12px; letter-spacing: -0.02em; }
    .show-hero-author, .source-hero-author { font-size: 15px; color: var(--text2); }
    .show-actions, .source-actions { padding: 20px 32px; display: flex; gap: 16px; align-items: center; }
    .show-play { width: 52px; height: 52px; border-radius: 50%; background: var(--blue); border: none; color: #fff; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s; box-shadow: 0 4px 16px rgba(59,130,246,0.4); }
    .show-play:hover { transform: scale(1.05); background: var(--blue2); }
    .show-episodes, .source-articles { padding: 0 32px 140px; }
    .show-episodes-title, .source-articles-title { font-size: 20px; font-weight: 600; margin-bottom: 20px; letter-spacing: -0.02em; }

    /* Back Button */
    .back-btn { background: rgba(255,255,255,0.05); border: 1px solid var(--border2); color: var(--text2); cursor: pointer; padding: 10px 16px; border-radius: 12px; display: flex; align-items: center; gap: 8px; font-size: 14px; font-weight: 500; font-family: inherit; transition: all 0.15s; }
    .back-btn:hover { background: rgba(255,255,255,0.08); color: var(--text); border-color: rgba(255,255,255,0.15); }

    /* View Options */
    .view-options { display: flex; gap: 6px; margin-left: auto; }
    .view-btn { background: var(--bg4); border: 1px solid var(--border2); color: var(--text2); cursor: pointer; padding: 10px 14px; border-radius: 10px; font-size: 12px; font-weight: 500; font-family: inherit; transition: all 0.15s; display: flex; align-items: center; gap: 6px; }
    .view-btn:hover { background: rgba(255,255,255,0.08); color: var(--text); }
    .view-btn.active { background: var(--blue); border-color: var(--blue); color: #fff; box-shadow: 0 2px 8px rgba(59,130,246,0.3); }

    /* Cards View */
    .articles-cards { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 20px; }
    .article-card { background: var(--bg3); border-radius: 16px; overflow: hidden; cursor: pointer; border: 1px solid var(--border2); transition: all 0.2s ease-out; display: flex; flex-direction: column; }
    .article-card:hover { background: rgba(255,255,255,0.04); border-color: rgba(255,255,255,0.15); transform: translateY(-2px); box-shadow: 0 8px 24px rgba(0,0,0,0.2); }
    .article-card.unread { position: relative; }
    .article-card.unread::after { content: ''; position: absolute; top: 12px; right: 12px; width: 8px; height: 8px; background: var(--orange); border-radius: 50%; }
    .article-card-image { width: 100%; height: 180px; object-fit: cover; background: var(--bg4); }
    .article-card-body { padding: 18px; flex: 1; display: flex; flex-direction: column; }
    .article-card-meta { display: flex; align-items: center; gap: 8px; margin-bottom: 10px; font-size: 13px; }
    .article-card-source { color: var(--blue); font-weight: 500; }
    .article-card-time { color: var(--text3); }
    .article-card-title { font-size: 16px; font-weight: 600; line-height: 1.4; margin-bottom: 10px; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
    .article-card:not(.unread) .article-card-title { font-weight: 400; color: var(--text2); }
    .article-card-summary { font-size: 14px; color: var(--text2); line-height: 1.5; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden; flex: 1; }

    /* Masonry View */
    .articles-masonry { column-count: 3; column-gap: 20px; }
    .article-masonry { break-inside: avoid; margin-bottom: 20px; background: var(--bg3); border-radius: 16px; overflow: hidden; cursor: pointer; border: 1px solid var(--border2); transition: all 0.2s ease-out; }
    .article-masonry:hover { background: rgba(255,255,255,0.04); border-color: rgba(255,255,255,0.15); box-shadow: 0 4px 16px rgba(0,0,0,0.2); }
    .article-masonry.unread { position: relative; }
    .article-masonry.unread::after { content: ''; position: absolute; top: 12px; right: 12px; width: 8px; height: 8px; background: var(--orange); border-radius: 50%; }
    .article-masonry-image { width: 100%; object-fit: cover; }
    .article-masonry-body { padding: 18px; }
    .article-masonry-meta { display: flex; align-items: center; gap: 8px; margin-bottom: 10px; font-size: 13px; }
    .article-masonry-source { color: var(--blue); font-weight: 500; }
    .article-masonry-time { color: var(--text3); }
    .article-masonry-title { font-size: 16px; font-weight: 600; line-height: 1.4; margin-bottom: 10px; }
    .article-masonry:not(.unread) .article-masonry-title { font-weight: 400; color: var(--text2); }
    .article-masonry-summary { font-size: 14px; color: var(--text2); line-height: 1.5; }

    /* Table View */
    .articles-table { width: 100%; border-collapse: collapse; }
    .articles-table th { text-align: left; padding: 14px 16px; font-size: 12px; font-weight: 600; color: var(--text3); text-transform: uppercase; letter-spacing: 0.5px; border-bottom: 1px solid var(--border2); }
    .articles-table td { padding: 14px 16px; border-bottom: 1px solid var(--border); vertical-align: middle; }
    .articles-table tr { cursor: pointer; transition: all 0.15s; }
    .articles-table tbody tr:hover { background: rgba(255,255,255,0.03); }
    .articles-table .table-title { font-weight: 500; max-width: 400px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .articles-table .table-source { color: var(--blue); font-weight: 500; font-size: 13px; }
    .articles-table .table-time { color: var(--text3); font-size: 13px; white-space: nowrap; }
    .articles-table .table-new { color: var(--orange); font-size: 10px; font-weight: 600; text-transform: uppercase; }
    .articles-table tr.unread .table-title { color: var(--text); font-weight: 600; }
    .articles-table tr:not(.unread) .table-title { color: var(--text2); font-weight: 400; }

    /* Episode Views */
    .episodes-cards { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 20px; }
    .episode-card { background: var(--bg3); border-radius: 16px; overflow: hidden; cursor: pointer; border: 1px solid var(--border2); transition: all 0.2s ease-out; }
    .episode-card:hover { background: rgba(255,255,255,0.04); border-color: rgba(255,255,255,0.15); transform: translateY(-2px); box-shadow: 0 8px 24px rgba(0,0,0,0.2); }
    .episode-card-art { width: 100%; aspect-ratio: 1; object-fit: cover; }
    .episode-card-body { padding: 18px; }
    .episode-card-title { font-size: 15px; font-weight: 600; margin-bottom: 8px; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
    .episode-card-meta { display: flex; align-items: center; gap: 10px; font-size: 13px; color: var(--text3); }

    .episodes-masonry { column-count: 3; column-gap: 20px; }
    .episode-masonry { break-inside: avoid; margin-bottom: 20px; background: var(--bg3); border-radius: 16px; overflow: hidden; cursor: pointer; border: 1px solid var(--border2); transition: all 0.2s ease-out; }
    .episode-masonry:hover { background: rgba(255,255,255,0.04); border-color: rgba(255,255,255,0.15); box-shadow: 0 4px 16px rgba(0,0,0,0.2); }
    .episode-masonry-art { width: 100%; object-fit: cover; }
    .episode-masonry-body { padding: 18px; }
    .episode-masonry-title { font-size: 15px; font-weight: 600; margin-bottom: 8px; }
    .episode-masonry-desc { font-size: 13px; color: var(--text2); line-height: 1.5; margin-bottom: 10px; }
    .episode-masonry-meta { font-size: 12px; color: var(--text3); }

    .episodes-table { width: 100%; border-collapse: collapse; }
    .episodes-table th { text-align: left; padding: 14px 16px; font-size: 12px; font-weight: 600; color: var(--text3); text-transform: uppercase; letter-spacing: 0.5px; border-bottom: 1px solid var(--border2); }
    .episodes-table td { padding: 14px 16px; border-bottom: 1px solid var(--border); vertical-align: middle; }
    .episodes-table tr { cursor: pointer; transition: all 0.15s; }
    .episodes-table tbody tr:hover { background: rgba(255,255,255,0.03); }
    .episodes-table .table-title { font-weight: 500; }
    .episodes-table .table-duration { color: var(--text3); font-size: 13px; font-family: -apple-system, system-ui, monospace; }
    .episodes-table .table-date { color: var(--text3); font-size: 13px; }
    .episodes-table .table-play { width: 36px; }
    .episodes-table .table-play-btn { width: 32px; height: 32px; border-radius: 50%; background: var(--blue); border: none; color: #fff; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.15s; box-shadow: 0 2px 6px rgba(59,130,246,0.3); }
    .episodes-table .table-play-btn:hover { background: var(--blue2); transform: scale(1.05); }

    @media (max-width: 1024px) {
      .articles-masonry, .episodes-masonry { column-count: 2; }
    }
    @media (max-width: 640px) {
      .articles-masonry, .episodes-masonry { column-count: 1; }
      .articles-cards, .episodes-cards { grid-template-columns: 1fr; }
    }

    /* === PLAYER - Mini player like the design === */
    .player { position: fixed; bottom: 0; left: 0; right: 0; background: var(--bg3); border-top: 1px solid var(--border2); display: none; flex-direction: column; padding: 16px 24px; z-index: 100; border-radius: 16px 16px 0 0; box-shadow: 0 -8px 32px rgba(0,0,0,0.4); }
    .player.active { display: flex; }
    .player-main { display: flex; align-items: center; gap: 16px; }
    .player-left { display: flex; align-items: center; gap: 16px; flex: 1; min-width: 0; }
    .player-art { width: 56px; height: 56px; border-radius: 12px; object-fit: cover; cursor: pointer; box-shadow: 0 4px 12px rgba(0,0,0,0.3); flex-shrink: 0; }
    .player-info { min-width: 0; flex: 1; }
    .player-title { font-size: 14px; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-bottom: 2px; }
    .player-show { font-size: 12px; color: var(--text2); cursor: pointer; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .player-show:hover { color: var(--blue); }
    .player-center { display: flex; align-items: center; gap: 12px; flex-shrink: 0; }
    .player-controls { display: flex; align-items: center; gap: 12px; }
    .player-skip { background: none; border: none; color: var(--text2); cursor: pointer; font-size: 12px; font-weight: 600; padding: 8px; font-family: inherit; border-radius: 50%; transition: all 0.15s; }
    .player-skip:hover { color: var(--text); background: rgba(255,255,255,0.05); }
    .player-play { width: 48px; height: 48px; border-radius: 50%; background: var(--blue); border: none; color: #fff; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.15s; box-shadow: 0 4px 12px rgba(59,130,246,0.4); flex-shrink: 0; }
    .player-play:hover { background: var(--blue2); transform: scale(1.05); }
    .player-progress { width: 100%; display: flex; align-items: center; gap: 10px; margin-top: 12px; }
    .player-time { font-size: 12px; color: var(--text3); font-family: -apple-system, system-ui, monospace; min-width: 44px; }
    .player-time.right { text-align: right; }
    .player-bar { flex: 1; height: 6px; background: var(--bg4); border-radius: 3px; cursor: pointer; position: relative; overflow: hidden; }
    .player-bar:hover { height: 8px; }
    .player-fill { height: 100%; background: linear-gradient(90deg, var(--blue), var(--blue2)); border-radius: 3px; position: relative; z-index: 1; }
    .scrub-tooltip { position: absolute; bottom: 24px; background: var(--bg4); border: 1px solid var(--border2); border-radius: 8px; padding: 6px 10px; font-family: -apple-system, system-ui, monospace; font-size: 12px; font-weight: 600; white-space: nowrap; pointer-events: none; transform: translateX(-50%); display: none; z-index: 10; }
    .player-bar:hover .scrub-tooltip { display: block; }
    .player-right { display: flex; align-items: center; gap: 8px; flex-shrink: 0; }
    .speed-btn { font-size: 12px; font-weight: 600; padding: 8px 12px; background: var(--bg4); border: 1px solid var(--border2); border-radius: 8px; color: var(--text2); cursor: pointer; font-family: inherit; transition: all 0.15s; }
    .speed-btn:hover { color: var(--text); background: rgba(255,255,255,0.08); }
    
    /* Expanded */
    .expanded { position: fixed; inset: 0; background: var(--bg); z-index: 200; display: none; flex-direction: column; }
    .expanded.active { display: flex; }
    .expanded-header { padding: 20px 24px; display: flex; justify-content: space-between; align-items: center; }
    .expanded-label { font-size: 12px; text-transform: uppercase; letter-spacing: 1px; color: var(--text3); font-weight: 600; }
    .expanded-body { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 32px; }
    .expanded-art { width: 280px; height: 280px; border-radius: 16px; object-fit: cover; box-shadow: 0 20px 60px rgba(0,0,0,0.5); margin-bottom: 32px; }
    .expanded-info { text-align: center; margin-bottom: 32px; max-width: 400px; }
    .expanded-title { font-size: 22px; font-weight: 700; margin-bottom: 8px; letter-spacing: -0.02em; }
    .expanded-show { font-size: 15px; color: var(--text2); }
    .expanded-progress { width: 100%; max-width: 400px; margin-bottom: 32px; }
    .expanded-bar { width: 100%; height: 6px; background: var(--bg4); border-radius: 3px; cursor: pointer; margin-bottom: 10px; overflow: hidden; }
    .expanded-fill { height: 100%; background: linear-gradient(90deg, var(--blue), var(--blue2)); border-radius: 3px; }
    .expanded-times { display: flex; justify-content: space-between; font-size: 13px; color: var(--text3); font-family: -apple-system, system-ui, monospace; }
    .expanded-controls { display: flex; align-items: center; gap: 32px; }
    .expanded-skip { width: 48px; height: 48px; border-radius: 50%; background: rgba(255,255,255,0.05); border: none; color: var(--text); cursor: pointer; font-size: 14px; font-weight: 600; font-family: inherit; transition: all 0.15s; }
    .expanded-skip:hover { background: rgba(255,255,255,0.1); }
    .expanded-play { width: 64px; height: 64px; border-radius: 50%; background: var(--blue); border: none; color: #fff; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.15s; box-shadow: 0 6px 20px rgba(59,130,246,0.4); }
    .expanded-play:hover { background: var(--blue2); transform: scale(1.05); }

    /* Swipe Seeking */
    .swipe-container { position: relative; touch-action: pan-y; user-select: none; -webkit-user-select: none; }
    .swipe-indicator { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.8); border-radius: 16px; opacity: 0; pointer-events: none; transition: opacity 0.15s; }
    .swipe-indicator.active { opacity: 1; }
    .swipe-indicator-content { display: flex; flex-direction: column; align-items: center; gap: 10px; }
    .swipe-indicator-icon { font-size: 36px; color: var(--text); }
    .swipe-indicator-text { font-size: 32px; font-weight: 700; color: var(--text); }
    .swipe-indicator-label { font-size: 12px; color: var(--text2); text-transform: uppercase; letter-spacing: 1px; font-weight: 600; }
    .swipe-indicator.rewind .swipe-indicator-icon { color: var(--blue); }
    .swipe-indicator.forward .swipe-indicator-icon { color: var(--blue); }

    /* Modal */
    .modal { position: fixed; inset: 0; background: rgba(0,0,0,0.8); display: none; align-items: center; justify-content: center; z-index: 300; backdrop-filter: blur(4px); }
    .modal.active { display: flex; }
    .modal-box { background: var(--bg3); border-radius: 20px; width: 90%; max-width: 420px; border: 1px solid var(--border2); box-shadow: 0 20px 60px rgba(0,0,0,0.5); }
    .modal-header { padding: 20px 24px; border-bottom: 1px solid var(--border2); display: flex; align-items: center; justify-content: space-between; }
    .modal-header h2 { font-size: 20px; font-weight: 600; letter-spacing: -0.02em; }
    .modal-close { background: rgba(255,255,255,0.05); border: none; color: var(--text2); cursor: pointer; padding: 8px; border-radius: 50%; transition: all 0.15s; }
    .modal-close:hover { background: rgba(255,255,255,0.1); color: var(--text); }
    .modal-body { padding: 24px; }
    .form-group { margin-bottom: 20px; }
    .form-label { display: block; font-size: 13px; font-weight: 600; color: var(--text2); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px; }
    .form-input { width: 100%; padding: 14px 16px; background: var(--bg4); border: 1px solid var(--border2); border-radius: 12px; color: var(--text); font-size: 15px; font-family: inherit; transition: all 0.15s; }
    .form-input:focus { outline: none; border-color: var(--blue); background: var(--bg); }
    .type-sel { display: flex; gap: 12px; }
    .type-btn { flex: 1; padding: 16px; background: var(--bg4); border: 2px solid var(--border2); border-radius: 14px; color: var(--text); cursor: pointer; display: flex; flex-direction: column; align-items: center; gap: 6px; font-family: inherit; transition: all 0.15s; }
    .type-btn:hover { border-color: rgba(255,255,255,0.2); }
    .type-btn.active { border-color: var(--blue); background: rgba(59,130,246,0.1); }
    .type-btn .icon { font-size: 26px; }
    .type-btn .label { font-size: 14px; font-weight: 500; }
    .submit-btn { width: 100%; padding: 16px; background: var(--blue); border: none; border-radius: 14px; color: #fff; font-size: 16px; font-weight: 600; cursor: pointer; font-family: inherit; transition: all 0.15s; box-shadow: 0 4px 12px rgba(59,130,246,0.3); }
    .submit-btn:hover { background: var(--blue2); }
    .submit-btn:disabled { background: var(--bg4); color: var(--text3); cursor: not-allowed; box-shadow: none; }
    .fetch-btn { padding: 14px 18px; background: var(--bg4); border: 1px solid var(--border2); border-radius: 12px; color: var(--text); font-size: 14px; font-weight: 500; cursor: pointer; font-family: inherit; white-space: nowrap; transition: all 0.15s; }
    .fetch-btn:hover:not(:disabled) { background: var(--blue); color: #fff; border-color: var(--blue); }
    .fetch-btn:disabled { background: var(--bg3); color: var(--text3); cursor: not-allowed; }
    .fetch-btn.loading { background: var(--bg3); color: var(--text2); }
    .fetch-status { font-size: 12px; margin-top: 8px; min-height: 16px; }
    .fetch-status.success { color: var(--blue); }
    .fetch-status.error { color: #ef4444; }
    .fetch-status.loading { color: var(--text2); }

    .toast { position: fixed; bottom: 120px; left: 50%; transform: translateX(-50%); background: var(--bg3); color: var(--text); padding: 14px 28px; border-radius: 14px; font-size: 14px; font-weight: 500; z-index: 400; opacity: 0; transition: opacity 0.3s; pointer-events: none; border: 1px solid var(--border2); box-shadow: 0 8px 24px rgba(0,0,0,0.4); }
    .toast.show { opacity: 1; }

    /* Mobile Hamburger & Drawer */
    .hamburger { display: none; background: none; border: none; color: var(--text); cursor: pointer; padding: 10px; border-radius: 50%; transition: all 0.15s; }
    .hamburger:hover { background: rgba(255,255,255,0.05); }
    @media (max-width: 768px) { .hamburger { display: flex; } }
    .drawer-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 150; opacity: 0; pointer-events: none; transition: opacity 0.3s; backdrop-filter: blur(4px); }
    .drawer-overlay.active { opacity: 1; pointer-events: auto; }
    .drawer { position: fixed; top: 0; left: 0; bottom: 0; width: 300px; background: var(--bg2); z-index: 160; transform: translateX(-100%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); display: flex; flex-direction: column; border-right: 1px solid var(--border2); }
    .drawer.active { transform: translateX(0); }
    .drawer-header { padding: 20px; border-bottom: 1px solid var(--border2); display: flex; align-items: center; justify-content: space-between; }
    .drawer-header .logo { font-size: 22px; }
    .drawer-close { background: rgba(255,255,255,0.05); border: none; color: var(--text2); cursor: pointer; padding: 10px; border-radius: 50%; transition: all 0.15s; }
    .drawer-close:hover { background: rgba(255,255,255,0.1); color: var(--text); }
    .drawer-content { flex: 1; overflow-y: auto; padding: 16px; }
    .drawer-section { margin-bottom: 20px; }
    .drawer-section-title { font-size: 11px; font-weight: 600; text-transform: uppercase; color: var(--text3); padding: 10px 14px; letter-spacing: 0.5px; }
    .drawer-item { display: flex; align-items: center; gap: 14px; padding: 14px; border-radius: 12px; cursor: pointer; transition: all 0.15s; }
    .drawer-item:hover { background: rgba(255,255,255,0.04); }
    .drawer-item.active { background: var(--bg4); border: 1px solid var(--border2); }
    .drawer-item-icon { width: 36px; height: 36px; border-radius: 10px; background: var(--bg3); display: flex; align-items: center; justify-content: center; font-size: 18px; box-shadow: 0 2px 6px rgba(0,0,0,0.2); }
    .drawer-item-icon img { width: 100%; height: 100%; object-fit: cover; border-radius: 10px; }
    .drawer-item-name { flex: 1; font-size: 14px; font-weight: 500; }
    .drawer-item-badge { background: var(--orange); color: #fff; font-size: 10px; font-weight: 700; padding: 3px 8px; border-radius: 12px; box-shadow: 0 2px 6px rgba(255,107,53,0.3); }

    /* Sleep Timer */
    .sleep-timer-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.8); display: none; align-items: center; justify-content: center; z-index: 350; backdrop-filter: blur(4px); }
    .sleep-timer-modal.active { display: flex; }
    .sleep-timer-box { background: var(--bg3); border-radius: 20px; width: 90%; max-width: 380px; padding: 24px; border: 1px solid var(--border2); box-shadow: 0 20px 60px rgba(0,0,0,0.5); }
    .sleep-timer-title { font-size: 20px; font-weight: 600; margin-bottom: 20px; display: flex; align-items: center; gap: 10px; letter-spacing: -0.02em; }
    .sleep-timer-presets { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 20px; }
    .sleep-preset { padding: 14px; background: var(--bg4); border: 2px solid var(--border2); border-radius: 12px; color: var(--text); cursor: pointer; font-size: 14px; font-weight: 500; font-family: inherit; transition: all 0.15s; text-align: center; }
    .sleep-preset:hover { background: rgba(255,255,255,0.08); border-color: rgba(255,255,255,0.2); }
    .sleep-preset.active { border-color: var(--blue); background: rgba(59,130,246,0.15); }
    .sleep-custom { display: flex; gap: 10px; margin-bottom: 20px; }
    .sleep-custom input { flex: 1; padding: 14px 16px; background: var(--bg4); border: 1px solid var(--border2); border-radius: 12px; color: var(--text); font-size: 15px; font-family: inherit; transition: all 0.15s; }
    .sleep-custom input:focus { outline: none; border-color: var(--blue); background: var(--bg); }
    .sleep-custom button { padding: 14px 20px; background: var(--blue); border: none; border-radius: 12px; color: #fff; font-weight: 600; cursor: pointer; font-family: inherit; transition: all 0.15s; box-shadow: 0 2px 8px rgba(59,130,246,0.3); }
    .sleep-custom button:hover { background: var(--blue2); }
    .sleep-timer-active { background: rgba(59,130,246,0.1); border: 1px solid var(--blue); border-radius: 14px; padding: 16px; display: flex; align-items: center; justify-content: space-between; }
    .sleep-timer-countdown { font-size: 28px; font-weight: 700; font-family: -apple-system, system-ui, monospace; color: var(--blue); }
    .sleep-timer-cancel { background: rgba(255,255,255,0.05); border: 1px solid var(--border2); border-radius: 10px; padding: 10px 16px; color: var(--text); cursor: pointer; font-size: 14px; font-family: inherit; transition: all 0.15s; }
    .sleep-timer-cancel:hover { background: rgba(255,255,255,0.1); }
    .sleep-badge { position: absolute; top: -4px; right: -4px; background: var(--blue); color: #fff; font-size: 9px; font-weight: 700; padding: 3px 6px; border-radius: 10px; min-width: 18px; text-align: center; }

    /* Settings Modal */
    .settings-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.8); display: none; align-items: center; justify-content: center; z-index: 350; backdrop-filter: blur(4px); }
    .settings-modal.active { display: flex; }
    .settings-box { background: var(--bg3); border-radius: 20px; width: 90%; max-width: 420px; border: 1px solid var(--border2); box-shadow: 0 20px 60px rgba(0,0,0,0.5); }
    .settings-header { padding: 20px 24px; border-bottom: 1px solid var(--border2); display: flex; align-items: center; justify-content: space-between; }
    .settings-header h2 { font-size: 20px; font-weight: 600; letter-spacing: -0.02em; display: flex; align-items: center; gap: 10px; }
    .settings-close { background: rgba(255,255,255,0.05); border: none; color: var(--text2); cursor: pointer; padding: 8px; border-radius: 50%; transition: all 0.15s; }
    .settings-close:hover { background: rgba(255,255,255,0.1); color: var(--text); }
    .settings-body { padding: 24px; }
    .settings-section { margin-bottom: 24px; }
    .settings-section:last-child { margin-bottom: 0; }
    .settings-section-title { font-size: 12px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text2); margin-bottom: 12px; }
    .settings-item { display: flex; align-items: center; justify-content: space-between; padding: 14px 16px; background: var(--bg4); border-radius: 12px; margin-bottom: 8px; }
    .settings-item:last-child { margin-bottom: 0; }
    .settings-item-label { font-size: 14px; font-weight: 500; }
    .settings-item-desc { font-size: 12px; color: var(--text2); margin-top: 2px; }
    .toggle-switch { position: relative; width: 48px; height: 28px; cursor: pointer; }
    .toggle-switch input { opacity: 0; width: 0; height: 0; }
    .toggle-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--bg); border: 1px solid var(--border2); border-radius: 14px; transition: 0.3s; }
    .toggle-slider:before { position: absolute; content: ""; height: 22px; width: 22px; left: 2px; bottom: 2px; background-color: var(--text2); border-radius: 50%; transition: 0.3s; }
    .toggle-switch input:checked + .toggle-slider { background-color: var(--blue); border-color: var(--blue); }
    .toggle-switch input:checked + .toggle-slider:before { transform: translateX(20px); background-color: #fff; }

    /* Snapshot List */
    .snapshot-list { max-height: 400px; overflow-y: auto; }
    .snapshot-item { display: flex; align-items: center; gap: 12px; padding: 14px; background: var(--bg4); border-radius: 12px; margin-bottom: 8px; border: 1px solid var(--border); transition: all 0.15s; }
    .snapshot-item:hover { background: rgba(255,255,255,0.04); border-color: var(--border2); }
    .snapshot-icon { width: 40px; height: 40px; background: rgba(59,130,246,0.1); border-radius: 10px; display: flex; align-items: center; justify-content: center; color: var(--blue); font-size: 18px; flex-shrink: 0; }
    .snapshot-info { flex: 1; min-width: 0; }
    .snapshot-date { font-size: 14px; font-weight: 500; margin-bottom: 2px; }
    .snapshot-reason { font-size: 12px; color: var(--text2); text-transform: capitalize; }
    .snapshot-stats { font-size: 11px; color: var(--text3); margin-top: 2px; }
    .snapshot-actions-row { display: flex; gap: 6px; flex-shrink: 0; }
    .snapshot-btn { padding: 8px 12px; border-radius: 8px; font-size: 12px; font-weight: 500; cursor: pointer; border: 1px solid var(--border2); background: var(--bg3); color: var(--text); transition: all 0.15s; font-family: inherit; }
    .snapshot-btn:hover { background: rgba(255,255,255,0.08); }
    .snapshot-btn.restore { background: var(--blue); border-color: var(--blue); color: #fff; }
    .snapshot-btn.restore:hover { background: var(--blue2); }
    .snapshot-btn.delete { color: var(--text2); }
    .snapshot-btn.delete:hover { background: rgba(239,68,68,0.1); border-color: rgba(239,68,68,0.3); color: #ef4444; }

    /* Speed Control Panel */
    .speed-panel { position: absolute; bottom: 100%; right: 0; background: var(--bg3); border: 1px solid var(--border2); border-radius: 16px; padding: 20px; width: 300px; display: none; z-index: 110; box-shadow: 0 -8px 32px rgba(0,0,0,0.4); }
    .speed-panel.active { display: block; }
    .speed-panel-title { font-size: 15px; font-weight: 600; margin-bottom: 16px; }
    .speed-slider-container { margin-bottom: 20px; }
    .speed-value { font-size: 32px; font-weight: 700; text-align: center; margin-bottom: 12px; color: var(--blue); }
    .speed-slider { width: 100%; height: 6px; -webkit-appearance: none; background: var(--bg4); border-radius: 3px; outline: none; }
    .speed-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; background: var(--blue); border-radius: 50%; cursor: pointer; box-shadow: 0 2px 8px rgba(59,130,246,0.4); }
    .speed-slider::-moz-range-thumb { width: 20px; height: 20px; background: var(--blue); border-radius: 50%; cursor: pointer; border: none; box-shadow: 0 2px 8px rgba(59,130,246,0.4); }
    .speed-presets { display: flex; gap: 8px; flex-wrap: wrap; }
    .speed-preset-btn { padding: 10px 14px; background: var(--bg4); border: 1px solid var(--border2); border-radius: 10px; color: var(--text2); cursor: pointer; font-size: 13px; font-weight: 500; font-family: inherit; transition: all 0.15s; }
    .speed-preset-btn:hover { background: rgba(255,255,255,0.08); color: var(--text); }
    .speed-preset-btn.active { background: var(--blue); border-color: var(--blue); color: #fff; box-shadow: 0 2px 6px rgba(59,130,246,0.3); }

    /* Bookmarks */
    .bookmarks-panel { position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); background: var(--bg3); border: 1px solid var(--border2); border-radius: 16px; padding: 20px; width: 340px; max-height: 320px; display: none; z-index: 110; box-shadow: 0 -8px 32px rgba(0,0,0,0.4); overflow-y: auto; }
    .bookmarks-panel.active { display: block; }
    .bookmarks-title { font-size: 15px; font-weight: 600; margin-bottom: 16px; display: flex; align-items: center; justify-content: space-between; }
    .bookmark-add-btn { background: var(--blue); border: none; color: #fff; width: 28px; height: 28px; border-radius: 50%; cursor: pointer; font-size: 16px; transition: all 0.15s; box-shadow: 0 2px 6px rgba(59,130,246,0.3); }
    .bookmark-add-btn:hover { background: var(--blue2); transform: scale(1.05); }
    .bookmark-item { display: flex; align-items: center; gap: 12px; padding: 12px; background: var(--bg4); border-radius: 12px; margin-bottom: 8px; cursor: pointer; transition: all 0.15s; border: 1px solid var(--border); }
    .bookmark-item:hover { background: rgba(255,255,255,0.06); border-color: var(--border2); }
    .bookmark-time { font-family: -apple-system, system-ui, monospace; font-size: 13px; font-weight: 600; color: var(--blue); min-width: 54px; }
    .bookmark-note { flex: 1; font-size: 13px; color: var(--text2); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .bookmark-delete { background: none; border: none; color: var(--text3); cursor: pointer; padding: 6px; opacity: 0; transition: all 0.15s; border-radius: 50%; }
    .bookmark-item:hover .bookmark-delete { opacity: 1; }
    .bookmark-delete:hover { color: #ef4444; background: rgba(239,68,68,0.1); }
    .bookmark-marker { position: absolute; top: -4px; width: 10px; height: 10px; background: var(--orange); border-radius: 50%; transform: translateX(-50%); cursor: pointer; z-index: 5; box-shadow: 0 2px 6px rgba(255,107,53,0.4); }
    .bookmark-marker:hover { transform: translateX(-50%) scale(1.3); }
    .bookmarks-empty { text-align: center; color: var(--text3); padding: 24px; font-size: 14px; }

    /* Scrubbing Preview */
    .scrub-preview { position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); background: var(--bg3); border: 1px solid var(--border2); border-radius: 10px; padding: 8px 14px; font-family: -apple-system, system-ui, monospace; font-size: 14px; font-weight: 600; display: none; white-space: nowrap; pointer-events: none; }
    .scrub-preview.active { display: block; }

    /* Adaptive Background */
    .expanded.adaptive-bg { background: linear-gradient(180deg, var(--adaptive-color, var(--bg)) 0%, var(--bg) 60%); }

    /* Player enhancements */
    .player-right { display: flex; align-items: center; gap: 8px; flex-shrink: 0; position: relative; }
    .player-btn { background: rgba(255,255,255,0.05); border: none; color: var(--text2); cursor: pointer; padding: 10px; border-radius: 50%; transition: all 0.15s; position: relative; }
    .player-btn:hover { background: rgba(255,255,255,0.1); color: var(--text); }
    .player-btn.active { color: var(--blue); background: rgba(59,130,246,0.1); }

    .empty { display: flex; flex-direction: column; align-items: center; padding: 60px 32px; text-align: center; color: var(--text3); }
    .empty-icon { font-size: 56px; margin-bottom: 16px; }
    .empty-title { font-size: 18px; font-weight: 600; color: var(--text); letter-spacing: -0.02em; }

    @media (max-width: 768px) {
      .toggle-btn span:last-child { display: none; }
      .search-box { display: none; }
      .news-sidebar { display: none; }
      .podcast-sidebar { display: none; }
      .show-hero, .source-hero { flex-direction: column; align-items: center; text-align: center; padding: 24px; }
      .show-hero-art, .source-hero-art { width: 160px; height: 160px; }
      .show-hero-title, .source-hero-title { font-size: 26px; }
      .player { padding: 12px 16px; }
      .player-art { width: 48px; height: 48px; }
      .player-play { width: 44px; height: 44px; }
    }

    /* ============================================
       MOBILE OPTIMIZATION
       ============================================ */

    /* Breakpoint Strategy:
       - 640px and below: Phone portrait/landscape
       - 641px to 1024px: Tablet
       - 1025px+: Desktop (existing styles)
    */

    @media (max-width: 1024px) {
      /* Tablet adjustments - moderate changes */
      html {
        font-size: 15px;
      }

      .header {
        padding: 14px 20px;
      }

      .main-toggle {
        gap: 8px;
      }

      .toggle-btn {
        padding: 10px 16px;
        font-size: 14px;
      }
    }

    @media (max-width: 640px) {
      /* ==================
         PHASE 1: FOUNDATION
         ================== */

      /* Reset box model for consistent sizing */
      * {
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
      }

      html {
        /* Base font size affects all rem units */
        font-size: 16px;
        /* Prevent zoom on input focus in iOS Safari */
        -webkit-text-size-adjust: 100%;
      }

      body {
        /* Ensure body doesn't overflow horizontally */
        overflow-x: hidden;
        /* Smoother scrolling on iOS */
        -webkit-overflow-scrolling: touch;
      }

      /* ==================
         PHASE 2: TYPOGRAPHY
         ================== */

      /* Headers */
      .logo {
        font-size: 20px;
      }

      .news-title,
      .section-title,
      .all-section-title {
        font-size: var(--mobile-text-3xl);
        letter-spacing: -0.03em;
        line-height: 1.2;
      }

      .section-header h2,
      .sidebar-header h2 {
        font-size: var(--mobile-text-xs);
      }

      /* Article/Episode Titles */
      .article-title {
        font-size: var(--mobile-text-xl);
        line-height: 1.4;
        -webkit-line-clamp: 3;
      }

      .episode-title {
        font-size: var(--mobile-text-lg);
        line-height: 1.4;
      }

      .article-card-title,
      .episode-card-title,
      .all-card-title {
        font-size: var(--mobile-text-lg);
        line-height: 1.4;
      }

      /* Body Text */
      .article-summary,
      .episode-desc,
      .article-card-summary {
        font-size: var(--mobile-text-base);
        line-height: 1.6;
        -webkit-line-clamp: 3;
      }

      /* Meta Text */
      .article-meta,
      .episode-card-meta,
      .all-item-meta {
        font-size: var(--mobile-text-sm);
      }

      .article-source,
      .episode-show {
        font-size: var(--mobile-text-sm);
      }

      .article-time {
        font-size: var(--mobile-text-xs);
      }

      /* ==================
         PHASE 3: TOUCH TARGETS
         ================== */

      /* All interactive elements must meet 44x44px minimum */

      .toggle-btn {
        min-height: var(--mobile-touch-min);
        padding: 12px 20px;
        font-size: var(--mobile-text-base);
        gap: 6px;
      }

      .chip,
      .tag-chip {
        min-height: var(--mobile-touch-min);
        padding: 12px 20px;
        font-size: var(--mobile-text-base);
      }

      .tag-chip {
        padding: 10px 16px;
      }

      .icon-btn {
        min-width: var(--mobile-touch-min);
        min-height: var(--mobile-touch-min);
        padding: 12px;
      }

      .add-btn {
        width: 36px;
        height: 36px;
        font-size: 20px;
      }

      .back-btn {
        min-height: var(--mobile-touch-min);
        padding: 12px 20px;
        font-size: var(--mobile-text-base);
      }

      /* Source/Show items in sidebar/drawer */
      .source-item,
      .drawer-item {
        min-height: var(--mobile-touch-comfortable);
        padding: 12px 16px;
      }

      .source-icon,
      .drawer-item-icon {
        width: 40px;
        height: 40px;
        font-size: 20px;
      }

      .source-name,
      .drawer-item-name {
        font-size: var(--mobile-text-base);
      }

      /* ==================
         PHASE 4: SPACING & LAYOUT
         ================== */

      /* Header */
      .header {
        padding: var(--mobile-space-md) var(--mobile-space-md);
        padding-top: max(var(--mobile-space-md), var(--sat));
        gap: var(--mobile-space-sm);
        /* Make header fixed and add padding to content */
        position: sticky;
        top: 0;
        z-index: var(--z-mobile-header);
        backdrop-filter: blur(12px);
        background: rgba(26, 26, 26, 0.95);
      }

      .main {
        /* Add top padding to account for sticky header */
        padding-top: 0;
      }

      /* Toggle moved to bottom navigation */
      .main-toggle {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: var(--bg2);
        border-top: 1px solid var(--border2);
        border-radius: 0;
        padding: 8px;
        padding-bottom: max(8px, var(--sab));
        z-index: var(--z-mobile-nav);
        justify-content: space-around;
        /* Shadow for elevation */
        box-shadow: 0 -4px 16px rgba(0, 0, 0, 0.3);
      }

      .toggle-btn {
        flex: 1;
        flex-direction: column;
        gap: 4px;
        padding: 8px 4px;
        border-radius: 12px;
      }

      .toggle-btn span:first-child {
        font-size: 24px;
        line-height: 1;
      }

      .toggle-btn span:last-child {
        display: block !important;
        font-size: 11px;
        font-weight: 600;
      }

      /* Content areas need bottom padding for nav */
      .news-list,
      .podcast-content,
      .all-content {
        padding: var(--mobile-space-md);
        padding-bottom: calc(80px + var(--sab));
      }

      /* Articles */
      .article {
        padding: var(--mobile-space-lg);
        gap: var(--mobile-space-md);
        margin-bottom: var(--mobile-space-md);
        border-radius: 16px;
      }

      .article-icon {
        width: 52px;
        height: 52px;
        font-size: 24px;
      }

      .article-meta {
        gap: 6px;
        margin-bottom: 8px;
      }

      .article-title {
        margin-bottom: 8px;
      }

      .article-image {
        width: 100px;
        height: 80px;
      }

      /* Episodes */
      .episode {
        padding: var(--mobile-space-lg);
        gap: var(--mobile-space-md);
        margin-bottom: var(--mobile-space-md);
      }

      .episode-art {
        width: 72px;
        height: 72px;
      }

      .ep-play {
        width: var(--mobile-touch-min);
        height: var(--mobile-touch-min);
      }

      .ep-play svg {
        width: 14px;
        height: 14px;
      }

      /* Cards */
      .articles-cards,
      .episodes-cards,
      .all-cards {
        grid-template-columns: 1fr;
        gap: var(--mobile-space-md);
      }

      .article-card-image,
      .episode-card-art,
      .all-card-image {
        height: 200px;
      }

      .article-card-body,
      .episode-card-body,
      .all-card-body {
        padding: var(--mobile-space-lg);
      }

      /* Masonry - single column */
      .articles-masonry,
      .episodes-masonry,
      .all-masonry {
        column-count: 1;
        gap: var(--mobile-space-md);
      }

      /* Section spacing */
      .section {
        margin-bottom: var(--mobile-space-2xl);
      }

      .section-header {
        margin-bottom: var(--mobile-space-lg);
      }

      /* ==================
         PHASE 5: PLAYER REDESIGN
         ================== */

      .player {
        position: fixed;
        bottom: calc(70px + var(--sab));
        left: 0;
        right: 0;
        padding: var(--mobile-space-lg) var(--mobile-space-md);
        border-radius: 20px 20px 0 0;
        z-index: var(--z-mobile-player);
        /* Enhanced shadow for elevation */
        box-shadow: 0 -8px 32px rgba(0, 0, 0, 0.5);
      }

      .player-main {
        gap: var(--mobile-space-md);
        margin-bottom: var(--mobile-space-sm);
      }

      .player-art {
        width: 64px;
        height: 64px;
        border-radius: 12px;
        /* Prevent tiny tap area */
        cursor: pointer;
      }

      .player-info {
        flex: 1;
        min-width: 0;
      }

      .player-title {
        font-size: var(--mobile-text-base);
        font-weight: 600;
        margin-bottom: 4px;
      }

      .player-show {
        font-size: var(--mobile-text-sm);
      }

      .player-controls {
        gap: var(--mobile-space-md);
      }

      .player-skip {
        min-width: var(--mobile-touch-min);
        min-height: var(--mobile-touch-min);
        padding: 10px 14px;
        font-size: var(--mobile-text-base);
        font-weight: 700;
      }

      .player-play {
        width: var(--mobile-touch-large);
        height: var(--mobile-touch-large);
      }

      .player-play svg {
        width: 20px;
        height: 20px;
      }

      .player-progress {
        margin-top: var(--mobile-space-sm);
      }

      .player-bar {
        height: 8px;
        border-radius: 4px;
        /* Increase tap area with padding */
        padding: 8px 0;
        margin: -8px 0;
      }

      .player-bar:active {
        height: 10px;
      }

      .player-fill {
        border-radius: 4px;
      }

      .player-time {
        font-size: var(--mobile-text-sm);
        font-weight: 500;
      }

      .player-right {
        gap: 6px;
      }

      .player-btn {
        min-width: var(--mobile-touch-min);
        min-height: var(--mobile-touch-min);
        padding: 12px;
      }

      .speed-btn {
        min-width: var(--mobile-touch-min);
        min-height: var(--mobile-touch-min);
        padding: 10px 14px;
        font-size: var(--mobile-text-sm);
        font-weight: 700;
      }

      /* ==================
         PHASE 6: EXPANDED PLAYER
         ================== */

      .expanded-header {
        padding: var(--mobile-space-lg) var(--mobile-space-md);
        padding-top: max(var(--mobile-space-lg), var(--sat));
      }

      .expanded-body {
        padding: var(--mobile-space-2xl) var(--mobile-space-lg);
      }

      .expanded-art {
        width: min(320px, 80vw);
        height: min(320px, 80vw);
        margin-bottom: var(--mobile-space-2xl);
      }

      .expanded-info {
        margin-bottom: var(--mobile-space-2xl);
      }

      .expanded-title {
        font-size: var(--mobile-text-3xl);
        line-height: 1.3;
        margin-bottom: var(--mobile-space-sm);
      }

      .expanded-show {
        font-size: var(--mobile-text-lg);
      }

      .expanded-progress {
        max-width: 100%;
        margin-bottom: var(--mobile-space-2xl);
      }

      .expanded-bar {
        height: 8px;
        margin-bottom: var(--mobile-space-sm);
      }

      .expanded-times {
        font-size: var(--mobile-text-sm);
      }

      .expanded-controls {
        gap: var(--mobile-space-2xl);
      }

      .expanded-skip {
        width: 56px;
        height: 56px;
        font-size: var(--mobile-text-base);
      }

      .expanded-play {
        width: 72px;
        height: 72px;
      }

      .expanded-play svg {
        width: 28px;
        height: 28px;
      }

      /* ==================
         PHASE 7: PANELS & MODALS
         ================== */

      .speed-panel,
      .bookmarks-panel {
        /* Make panels full-width bottom sheets on mobile */
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        top: auto;
        transform: translateY(100%);
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        width: 100%;
        max-height: 60vh;
        border-radius: 20px 20px 0 0;
        padding: var(--mobile-space-xl) var(--mobile-space-lg);
        padding-bottom: max(var(--mobile-space-xl), var(--sab));
        overflow-y: auto;
      }

      .speed-panel.active,
      .bookmarks-panel.active {
        display: block;
        transform: translateY(0);
      }

      .speed-panel-title,
      .bookmarks-title {
        font-size: var(--mobile-text-2xl);
        margin-bottom: var(--mobile-space-lg);
      }

      .speed-value {
        font-size: 48px;
        margin-bottom: var(--mobile-space-md);
      }

      .speed-slider {
        height: 8px;
      }

      .speed-slider::-webkit-slider-thumb {
        width: 28px;
        height: 28px;
      }

      .speed-slider::-moz-range-thumb {
        width: 28px;
        height: 28px;
      }

      .speed-preset-btn {
        min-height: var(--mobile-touch-min);
        padding: 12px 16px;
        font-size: var(--mobile-text-base);
      }

      .bookmark-item {
        min-height: var(--mobile-touch-comfortable);
        padding: var(--mobile-space-md);
        margin-bottom: var(--mobile-space-sm);
      }

      .bookmark-time {
        font-size: var(--mobile-text-base);
      }

      .bookmark-note {
        font-size: var(--mobile-text-sm);
      }

      .bookmark-delete {
        min-width: var(--mobile-touch-min);
        min-height: var(--mobile-touch-min);
        padding: 12px;
        opacity: 1;
      }

      /* Modal */
      .modal-box {
        width: calc(100% - 32px);
        max-width: none;
        margin: var(--mobile-space-md);
      }

      .modal-header {
        padding: var(--mobile-space-lg) var(--mobile-space-lg);
      }

      .modal-header h2 {
        font-size: var(--mobile-text-2xl);
      }

      .modal-body {
        padding: var(--mobile-space-lg);
      }

      .form-input {
        min-height: var(--mobile-touch-comfortable);
        padding: 14px 16px;
        font-size: var(--mobile-text-md);
      }

      .type-btn {
        min-height: 80px;
        padding: var(--mobile-space-lg);
      }

      .type-btn .icon {
        font-size: 32px;
      }

      .type-btn .label {
        font-size: var(--mobile-text-base);
      }

      .submit-btn,
      .fetch-btn {
        min-height: var(--mobile-touch-comfortable);
        padding: 14px 20px;
        font-size: var(--mobile-text-md);
      }

      /* Sleep Timer Modal */
      .sleep-timer-box {
        width: calc(100% - 32px);
        padding: var(--mobile-space-xl) var(--mobile-space-lg);
        padding-bottom: max(var(--mobile-space-xl), var(--sab));
      }

      .sleep-timer-title {
        font-size: var(--mobile-text-2xl);
        margin-bottom: var(--mobile-space-lg);
      }

      .sleep-preset {
        min-height: var(--mobile-touch-comfortable);
        padding: 14px;
        font-size: var(--mobile-text-base);
      }

      .sleep-custom input {
        min-height: var(--mobile-touch-comfortable);
        padding: 14px 16px;
        font-size: var(--mobile-text-md);
      }

      .sleep-custom button {
        min-height: var(--mobile-touch-comfortable);
        padding: 14px 24px;
      }

      /* ==================
         PHASE 8: DRAWER
         ================== */

      .drawer {
        width: 85vw;
        max-width: 320px;
      }

      .drawer-header {
        padding: var(--mobile-space-lg);
        padding-top: max(var(--mobile-space-lg), var(--sat));
      }

      .drawer-content {
        padding: var(--mobile-space-md);
      }

      .drawer-section {
        margin-bottom: var(--mobile-space-lg);
      }

      .drawer-section-title {
        padding: var(--mobile-space-sm) var(--mobile-space-md);
      }

      /* ==================
         PHASE 9: SHOW/SOURCE PAGES
         ================== */

      .show-hero,
      .source-hero {
        flex-direction: column;
        align-items: center;
        text-align: center;
        padding: var(--mobile-space-xl) var(--mobile-space-lg);
      }

      .show-hero-art,
      .source-hero-art {
        width: 180px;
        height: 180px;
        margin-bottom: var(--mobile-space-lg);
      }

      .show-hero-title,
      .source-hero-title {
        font-size: var(--mobile-text-4xl);
        line-height: 1.2;
        margin-bottom: var(--mobile-space-sm);
      }

      .show-hero-author,
      .source-hero-author {
        font-size: var(--mobile-text-base);
      }

      .show-actions,
      .source-actions {
        padding: var(--mobile-space-lg) var(--mobile-space-md);
        flex-wrap: wrap;
      }

      .show-play {
        width: 60px;
        height: 60px;
      }

      .show-play svg {
        width: 24px;
        height: 24px;
      }

      .show-episodes,
      .source-articles {
        padding: 0 var(--mobile-space-md);
        padding-bottom: calc(150px + var(--sab));
      }

      .show-episodes-title,
      .source-articles-title {
        font-size: var(--mobile-text-2xl);
        margin-bottom: var(--mobile-space-lg);
      }

      /* ==================
         PHASE 10: SHOWS GRID
         ================== */

      .shows-grid {
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        gap: var(--mobile-space-lg);
      }

      .show-card {
        max-width: none;
      }

      .show-art {
        margin-bottom: var(--mobile-space-md);
      }

      .show-name {
        font-size: var(--mobile-text-base);
        line-height: 1.3;
      }

      .show-author {
        font-size: var(--mobile-text-sm);
      }

      /* ==================
         PHASE 11: TAG FILTERS
         ================== */

      .tag-filter-section {
        padding: var(--mobile-space-md);
      }

      .tag-filter-header {
        margin-bottom: var(--mobile-space-sm);
      }

      .tag-chips {
        gap: 8px;
        padding-bottom: 8px;
      }

      /* ==================
         PHASE 12: CATEGORY CHIPS
         ================== */

      .category-chips {
        gap: 8px;
      }

      .news-header {
        padding: var(--mobile-space-lg) var(--mobile-space-md);
        flex-wrap: wrap;
      }

      .news-title {
        flex: 1 0 100%;
        margin-bottom: var(--mobile-space-sm);
      }

      /* ==================
         PHASE 13: TABLE VIEWS
         ================== */

      /* Tables are problematic on mobile - consider hiding or using cards instead */
      .articles-table,
      .episodes-table,
      .all-table {
        display: none;
      }

      /* Or alternatively, make tables scroll horizontally */
      .table-wrapper {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
      }

      /* ==================
         PHASE 14: TOAST
         ================== */

      .toast {
        bottom: calc(80px + var(--sab));
        padding: var(--mobile-space-md) var(--mobile-space-xl);
        font-size: var(--mobile-text-base);
        max-width: calc(100% - 32px);
      }

      /* ==================
         PHASE 15: SEARCH
         ================== */

      .search-box {
        display: block;
        max-width: none;
        flex: 1;
      }

      .search-box input {
        font-size: var(--mobile-text-md);
        padding: 10px 16px 10px 38px;
      }

      /* ==================
         PHASE 16: EMPTY STATES
         ================== */

      .empty {
        padding: calc(var(--mobile-space-2xl) * 2) var(--mobile-space-lg);
      }

      .empty-icon {
        font-size: 72px;
        margin-bottom: var(--mobile-space-lg);
      }

      .empty-title {
        font-size: var(--mobile-text-2xl);
        margin-bottom: var(--mobile-space-sm);
      }

      /* ==================
         PHASE 17: PERFORMANCE
         ================== */

      /* Reduce animations on mobile for better performance */
      @media (prefers-reduced-motion: no-preference) {
        .article:active,
        .episode:active,
        .show-card:active {
          /* Instant feedback on tap */
          transform: scale(0.98);
          transition-duration: 0.1s;
        }
      }

      /* Reduce motion for accessibility */
      @media (prefers-reduced-motion: reduce) {
        *,
        *::before,
        *::after {
          animation-duration: 0.01ms !important;
          animation-iteration-count: 1 !important;
          transition-duration: 0.01ms !important;
          scroll-behavior: auto !important;
        }
      }

      /* ==================
         PHASE 18: SWIPE IMPROVEMENTS
         ================== */

      .swipe-indicator {
        border-radius: 20px;
      }

      .swipe-indicator-icon {
        font-size: 48px;
      }

      .swipe-indicator-text {
        font-size: 40px;
      }

      .swipe-indicator-label {
        font-size: var(--mobile-text-sm);
      }

      /* ==================
         PHASE 19: FEED VIEW
         ================== */

      .feed-container {
        padding-bottom: calc(80px + var(--sab));
      }

      .feed-scroll {
        padding-bottom: calc(80px + var(--sab));
      }

      .feed-nav {
        padding: 0 var(--mobile-space-sm);
      }

      .feed-nav-btn {
        padding: var(--mobile-space-sm) var(--mobile-space-md);
        min-height: var(--mobile-touch-min);
      }

      .feed-post-inner {
        padding: var(--mobile-space-md);
      }

      .feed-post-avatar {
        width: 44px;
        height: 44px;
      }

      .feed-post-body {
        padding-left: 56px;
      }

      .feed-post-title {
        font-size: var(--mobile-text-lg);
      }

      .feed-post-summary {
        font-size: var(--mobile-text-base);
      }

      .feed-post-play {
        min-height: var(--mobile-touch-min);
        padding: 12px 24px;
      }
    }

    /* ==================
       LANDSCAPE MOBILE ADJUSTMENTS
       ================== */

    @media (max-width: 896px) and (orientation: landscape) {
      /* Optimize for landscape phone viewing */

      .expanded-art {
        width: 200px;
        height: 200px;
        margin-bottom: var(--mobile-space-lg);
      }

      .expanded-body {
        padding: var(--mobile-space-lg);
      }

      .expanded-controls {
        gap: var(--mobile-space-lg);
      }

      .expanded-skip {
        width: 48px;
        height: 48px;
      }

      .expanded-play {
        width: 60px;
        height: 60px;
      }

      /* Make show grid denser */
      .shows-grid {
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
        gap: var(--mobile-space-md);
      }
    }

    /* Skeleton loading animation */
    .skeleton {
      background: linear-gradient(
        90deg,
        var(--bg3) 25%,
        var(--bg4) 50%,
        var(--bg3) 75%
      );
      background-size: 200% 100%;
      animation: shimmer 1.5s ease-in-out infinite;
      border-radius: 8px;
    }

    @keyframes shimmer {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }

    .skeleton-wrapper {
      opacity: 0.6;
    }

    /* Ripple animation */
    @keyframes ripple {
      to {
        transform: scale(2.5);
        opacity: 0;
      }
    }

    /* Pull to refresh indicator */
    .pull-to-refresh-indicator {
      position: fixed;
      top: -80px;
      left: 0;
      right: 0;
      height: 80px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 8px;
      background: var(--bg2);
      z-index: 99;
      transition: transform 0.2s ease-out;
      color: var(--text2);
    }

    .pull-spinner {
      animation: spin 1s linear infinite;
    }

    .pull-spinner.ready {
      animation: none;
      transform: rotate(180deg);
    }

    .pull-text {
      font-size: 13px;
      font-weight: 500;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Swipe delete button */
    .swipe-delete-btn {
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      width: 80px;
      background: #ef4444;
      border: none;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    /* Bottom sheet backdrop */
    .bottom-sheet-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.6);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease-out;
      z-index: 109;
      backdrop-filter: blur(4px);
    }
  </style>
</head>
<body>
<div class="app">
  <header class="header">
    <button class="hamburger" id="hamburgerBtn"><svg width="24" height="24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 6h16M4 12h16M4 18h16"/></svg></button>
    <div class="logo">BU<span class="logo-rss">RSS</span>T</div>
    <div class="main-toggle">
      <button class="toggle-btn" data-view="all"><span><i class="ph ph-books"></i></span><span>All</span></button>
      <button class="toggle-btn" data-view="news"><span><i class="ph ph-newspaper"></i></span><span>News</span></button>
      <button class="toggle-btn active" data-view="podcasts"><span><i class="ph ph-headphones"></i></span><span>Podcasts</span></button>
    </div>
    <div class="spacer"></div>
    <div class="search-box">
      <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2"><circle cx="7" cy="7" r="5"/><path d="M12 12l3 3"/></svg>
      <input type="text" id="searchInput" placeholder="Search...">
    </div>
    <button class="icon-btn" id="refreshBtn" title="Refresh feeds"><svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M1 4v6h6M23 20v-6h-6"/><path d="M20.49 9A9 9 0 005.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 013.51 15"/></svg></button>
    <button class="icon-btn" id="settingsBtn" title="Settings"><svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M12 15a3 3 0 100-6 3 3 0 000 6z"/><path d="M19.4 15a1.65 1.65 0 00.33 1.82l.06.06a2 2 0 010 2.83 2 2 0 01-2.83 0l-.06-.06a1.65 1.65 0 00-1.82-.33 1.65 1.65 0 00-1 1.51V21a2 2 0 01-2 2 2 2 0 01-2-2v-.09A1.65 1.65 0 009 19.4a1.65 1.65 0 00-1.82.33l-.06.06a2 2 0 01-2.83 0 2 2 0 010-2.83l.06-.06a1.65 1.65 0 00.33-1.82 1.65 1.65 0 00-1.51-1H3a2 2 0 01-2-2 2 2 0 012-2h.09A1.65 1.65 0 004.6 9a1.65 1.65 0 00-.33-1.82l-.06-.06a2 2 0 010-2.83 2 2 0 012.83 0l.06.06a1.65 1.65 0 001.82.33H9a1.65 1.65 0 001-1.51V3a2 2 0 012-2 2 2 0 012 2v.09a1.65 1.65 0 001 1.51 1.65 1.65 0 001.82-.33l.06-.06a2 2 0 012.83 0 2 2 0 010 2.83l-.06.06a1.65 1.65 0 00-.33 1.82V9a1.65 1.65 0 001.51 1H21a2 2 0 012 2 2 2 0 01-2 2h-.09a1.65 1.65 0 00-1.51 1z"/></svg></button>
    <button class="icon-btn" id="addBtn"><svg width="22" height="22" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12h14"/></svg></button>
  </header>
  
  <div class="main">
    <!-- NEWS VIEW -->
    <div class="news-view active" id="newsView">
      <aside class="news-sidebar">
        <div class="sidebar-header"><h2>Sources</h2><button class="add-btn" id="addNewsBtn">+</button></div>
        <div class="sidebar-content" id="newsSources"></div>
      </aside>
      <div class="news-content" id="newsContent">
        <div class="news-header">
          <div class="news-title" id="newsTitle">All Articles</div>
          <div class="category-chips" id="categoryChips"></div>
        </div>
        <div class="tag-filter-section" id="tagFilterSection">
          <div class="tag-filter-header">
            <span class="tag-filter-title">Filter by Topic</span>
          </div>
          <div class="tag-chips" id="tagChips"></div>
        </div>
        <div class="news-list" id="newsList"></div>
      </div>
      <div class="source-page" id="sourcePage"></div>
    </div>
    
    <!-- PODCAST VIEW -->
    <div class="podcast-view" id="podcastView">
      <aside class="podcast-sidebar">
        <div class="sidebar-header"><h2>Shows</h2><button class="add-btn" id="addPodcastBtn">+</button></div>
        <div class="sidebar-content" id="podcastSources"></div>
      </aside>
      <div class="podcast-inbox-content" id="podcastInboxContent">
        <div class="podcast-inbox-header">
          <div class="podcast-inbox-title" id="podcastInboxTitle">All Episodes</div>
          <div class="category-chips" id="podcastCategoryChips"></div>
        </div>
        <div class="tag-filter-section" id="podcastTagFilterSection">
          <div class="tag-filter-header">
            <span class="tag-filter-title">Filter by Topic</span>
          </div>
          <div class="tag-chips" id="podcastTagChips"></div>
        </div>
        <div class="podcast-inbox-list" id="podcastInboxList"></div>
      </div>
      <div class="show-page" id="showPage"></div>
    </div>

    <!-- ALL VIEW -->
    <div class="all-view" id="allView">
      <nav class="feed-nav" id="feedNav">
        <button class="feed-nav-btn active" data-filter="all">
          <span class="feed-nav-icon"><i class="ph ph-books"></i></span>
          <span>All</span>
          <span class="feed-nav-count" id="feedCountAll">0</span>
        </button>
        <button class="feed-nav-btn" data-filter="news">
          <span class="feed-nav-icon"><i class="ph ph-newspaper"></i></span>
          <span>News</span>
          <span class="feed-nav-count" id="feedCountNews">0</span>
        </button>
        <button class="feed-nav-btn" data-filter="podcast">
          <span class="feed-nav-icon"><i class="ph ph-headphones"></i></span>
          <span>Podcasts</span>
          <span class="feed-nav-count" id="feedCountPodcast">0</span>
        </button>
      </nav>
      <div class="feed-container">
        <div class="feed-scroll" id="feedScroll"></div>
      </div>
    </div>
  </div>
  
  <!-- PLAYER -->
  <div class="player" id="player">
    <div class="player-main">
      <div class="player-left">
        <img class="player-art" id="playerArt" src="">
        <div class="player-info">
          <div class="player-title" id="playerTitle"></div>
          <div class="player-show" id="playerShow"></div>
        </div>
      </div>
      <div class="player-center">
        <div class="player-controls">
          <button class="player-skip" id="pSkipBack">-15</button>
          <button class="player-play" id="pPlay"><svg width="18" height="18" fill="currentColor" viewBox="0 0 24 24" id="pPlayIcon"><path d="M8 5v14l11-7z"/></svg></button>
          <button class="player-skip" id="pSkipFwd">+30</button>
        </div>
      </div>
      <div class="player-right">
        <button class="player-btn" id="pBookmark" title="Bookmarks (B)"><svg width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M19 21l-7-5-7 5V5a2 2 0 012-2h10a2 2 0 012 2z"/></svg></button>
        <button class="player-btn" id="pSleep" title="Sleep Timer (M)"><svg width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><span class="sleep-badge" id="sleepBadge" style="display:none"></span></button>
        <button class="speed-btn" id="pSpeed" title="Speed (S)">1x</button>
        <button class="icon-btn" id="pExpand" title="Fullscreen (F)"><svg width="16" height="16" fill="currentColor" viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg></button>
      </div>
    </div>
    <div class="player-progress">
      <span class="player-time" id="pCur">0:00</span>
      <div class="player-bar" id="pBar"><div class="player-fill" id="pFill"></div><div class="scrub-tooltip" id="scrubTooltip">0:00</div></div>
      <span class="player-time right" id="pDur">0:00</span>
    </div>
    <div class="player-panels" style="position: relative;">
      <!-- Speed Panel -->
      <div class="speed-panel" id="speedPanel">
        <div class="speed-panel-title">Playback Speed</div>
        <div class="speed-slider-container">
          <div class="speed-value" id="speedValue">1.00x</div>
          <input type="range" class="speed-slider" id="speedSlider" min="0.5" max="3" step="0.05" value="1">
        </div>
        <div class="speed-presets">
          <button class="speed-preset-btn" data-speed="0.75">0.75x</button>
          <button class="speed-preset-btn active" data-speed="1">1x</button>
          <button class="speed-preset-btn" data-speed="1.25">1.25x</button>
          <button class="speed-preset-btn" data-speed="1.5">1.5x</button>
          <button class="speed-preset-btn" data-speed="2">2x</button>
        </div>
      </div>
      <!-- Bookmarks Panel -->
      <div class="bookmarks-panel" id="bookmarksPanel">
        <div class="bookmarks-title">
          <span>Bookmarks</span>
          <button class="bookmark-add-btn" id="addBookmarkBtn" title="Add bookmark at current position">+</button>
        </div>
        <div id="bookmarksList"></div>
      </div>
    </div>
  </div>
  
  <!-- EXPANDED PLAYER -->
  <div class="expanded" id="expanded">
    <div class="expanded-header">
      <button class="icon-btn" id="expClose"><svg width="24" height="24" fill="none" stroke="currentColor" stroke-width="2"><path d="M6 9l6 6 6-6"/></svg></button>
      <span class="expanded-label">Now Playing</span>
      <div style="width:44px"></div>
    </div>
    <div class="expanded-body">
      <div class="swipe-container" id="swipeContainer">
        <img class="expanded-art" id="expArt" src="">
        <div class="swipe-indicator" id="swipeIndicator">
          <div class="swipe-indicator-content">
            <div class="swipe-indicator-icon" id="swipeIcon"><i class="ph ph-rewind"></i></div>
            <div class="swipe-indicator-text" id="swipeText">-15s</div>
            <div class="swipe-indicator-label" id="swipeLabel">Rewind</div>
          </div>
        </div>
      </div>
      <div class="expanded-info">
        <div class="expanded-title" id="expTitle"></div>
        <div class="expanded-show" id="expShow"></div>
      </div>
      <div class="expanded-progress">
        <div class="expanded-bar" id="expBar"><div class="expanded-fill" id="expFill"></div></div>
        <div class="expanded-times"><span id="expCur">0:00</span><span id="expDur">0:00</span></div>
      </div>
      <div class="expanded-controls">
        <button class="expanded-skip" id="expBack">-15</button>
        <button class="expanded-play" id="expPlay"><svg width="24" height="24" fill="currentColor" viewBox="0 0 24 24" id="expPlayIcon"><path d="M8 5v14l11-7z"/></svg></button>
        <button class="expanded-skip" id="expFwd">+30</button>
      </div>
    </div>
  </div>
</div>

<!-- MODAL -->
<div class="modal" id="modal">
  <div class="modal-box">
    <div class="modal-header">
      <h2>Add Feed</h2>
      <button class="modal-close" id="modalClose"><svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 5L5 15M5 5l10 10"/></svg></button>
    </div>
    <div class="modal-body">
      <div class="form-group">
        <label class="form-label">Feed URL</label>
        <div style="display:flex;gap:8px">
          <input type="url" class="form-input" id="fUrl" placeholder="https://..." style="flex:1">
          <button class="fetch-btn" id="fFetch" disabled>Fetch</button>
        </div>
        <div class="fetch-status" id="fStatus"></div>
      </div>
      <div class="form-group"><label class="form-label">Name</label><input type="text" class="form-input" id="fName" placeholder="Auto-detected from feed..."></div>
      <div class="form-group"><label class="form-label">Creator / Author</label><input type="text" class="form-input" id="fAuthor" placeholder="Auto-detected from feed..."></div>
      <div class="form-group"><label class="form-label">Type</label>
        <div class="type-sel">
          <button class="type-btn active" id="tNews"><span class="icon"><i class="ph ph-newspaper"></i></span><span class="label">News</span></button>
          <button class="type-btn" id="tPodcast"><span class="icon"><i class="ph ph-microphone-stage"></i></span><span class="label">Podcast</span></button>
        </div>
      </div>
      <div class="form-group"><label class="form-label">Category</label><input type="text" class="form-input" id="fCat" placeholder="Tech, News..."></div>
      <button class="submit-btn" id="fSubmit" disabled>Add Feed</button>
    </div>
  </div>
</div>
<div class="toast" id="toast"></div>

<!-- Mobile Drawer -->
<div class="drawer-overlay" id="drawerOverlay"></div>
<div class="drawer" id="drawer">
  <div class="drawer-header">
    <div class="logo">BU<span class="logo-rss">RSS</span>T</div>
    <button class="drawer-close" id="drawerClose"><svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 5L5 15M5 5l10 10"/></svg></button>
  </div>
  <div class="drawer-content" id="drawerContent"></div>
</div>

<!-- Sleep Timer Modal -->
<div class="sleep-timer-modal" id="sleepTimerModal">
  <div class="sleep-timer-box">
    <div class="sleep-timer-title"><svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg> Sleep Timer</div>
    <div id="sleepTimerContent">
      <div class="sleep-timer-presets" id="sleepPresets">
        <button class="sleep-preset" data-minutes="5">5 min</button>
        <button class="sleep-preset" data-minutes="10">10 min</button>
        <button class="sleep-preset" data-minutes="15">15 min</button>
        <button class="sleep-preset" data-minutes="30">30 min</button>
        <button class="sleep-preset" data-minutes="45">45 min</button>
        <button class="sleep-preset" data-minutes="60">60 min</button>
        <button class="sleep-preset" data-minutes="episode" style="grid-column: span 3">End of Episode</button>
      </div>
      <div class="sleep-custom">
        <input type="number" id="sleepCustomInput" placeholder="Custom minutes" min="1" max="999">
        <button id="sleepCustomBtn">Set</button>
      </div>
    </div>
    <div id="sleepTimerActive" class="sleep-timer-active" style="display:none">
      <div>
        <div style="font-size:12px;color:var(--text2);margin-bottom:4px">Stopping in</div>
        <div class="sleep-timer-countdown" id="sleepCountdown">00:00</div>
      </div>
      <button class="sleep-timer-cancel" id="sleepCancelBtn">Cancel</button>
    </div>
  </div>
</div>

<!-- Settings Modal -->
<div class="settings-modal" id="settingsModal">
  <div class="settings-box">
    <div class="settings-header">
      <h2><svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M12 15a3 3 0 100-6 3 3 0 000 6z"/><path d="M19.4 15a1.65 1.65 0 00.33 1.82l.06.06a2 2 0 010 2.83 2 2 0 01-2.83 0l-.06-.06a1.65 1.65 0 00-1.82-.33 1.65 1.65 0 00-1 1.51V21a2 2 0 01-2 2 2 2 0 01-2-2v-.09A1.65 1.65 0 009 19.4a1.65 1.65 0 00-1.82.33l-.06.06a2 2 0 01-2.83 0 2 2 0 010-2.83l.06-.06a1.65 1.65 0 00.33-1.82 1.65 1.65 0 00-1.51-1H3a2 2 0 01-2-2 2 2 0 012-2h.09A1.65 1.65 0 004.6 9a1.65 1.65 0 00-.33-1.82l-.06-.06a2 2 0 010-2.83 2 2 0 012.83 0l.06.06a1.65 1.65 0 001.82.33H9a1.65 1.65 0 001-1.51V3a2 2 0 012-2 2 2 0 012 2v.09a1.65 1.65 0 001 1.51 1.65 1.65 0 001.82-.33l.06-.06a2 2 0 012.83 0 2 2 0 010 2.83l-.06.06a1.65 1.65 0 00-.33 1.82V9a1.65 1.65 0 001.51 1H21a2 2 0 012 2 2 2 0 01-2 2h-.09a1.65 1.65 0 00-1.51 1z"/></svg> Settings</h2>
      <button class="settings-close" id="settingsClose"><svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 5L5 15M5 5l10 10"/></svg></button>
    </div>
    <div class="settings-body">
      <div class="settings-section">
        <div class="settings-section-title">Article Behavior</div>
        <div class="settings-item">
          <div>
            <div class="settings-item-label">Open links in new tab</div>
            <div class="settings-item-desc">When disabled, articles open in the current tab</div>
          </div>
          <label class="toggle-switch">
            <input type="checkbox" id="openLinksToggle" checked>
            <span class="toggle-slider"></span>
          </label>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Snapshot/History Modal -->
<div class="modal" id="snapshotModal">
  <div class="modal-box" style="max-width:500px">
    <div class="modal-header">
      <h2><i class="ph ph-clock-counter-clockwise"></i> History Snapshots</h2>
      <button class="modal-close" id="snapshotModalClose"><svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 5L5 15M5 5l10 10"/></svg></button>
    </div>
    <div class="modal-body">
      <div class="snapshot-actions" style="display:flex;gap:8px;margin-bottom:16px">
        <button class="submit-btn" id="createSnapshotBtn" style="flex:1"><i class="ph ph-camera"></i> Create Snapshot</button>
      </div>
      <div class="snapshot-list" id="snapshotList">
        <div class="snapshot-empty" style="text-align:center;padding:32px;color:var(--text2)">
          <i class="ph ph-clock-counter-clockwise" style="font-size:48px;opacity:0.3"></i>
          <p style="margin-top:12px">No snapshots yet</p>
          <p style="font-size:13px">Create a snapshot to save your current state</p>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Audio element for actual playback -->
<audio id="audioPlayer" preload="metadata"></audio>

<script>
(function() {
  'use strict';

  // === GUID GENERATION UTILITIES ===
  // Generates stable, deterministic GUIDs based on content
  // These persist across deletion/re-addition of feeds
  const GUID = {
    // FNV-1a hash - produces consistent 32-bit hash
    hash32(str) {
      let h = 0x811c9dc5;
      for (let i = 0; i < str.length; i++) {
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 0x01000193);
      }
      return h >>> 0;
    },

    // Generate 64-bit hash as two 32-bit values combined
    hash64(str) {
      const h1 = this.hash32(str);
      const h2 = this.hash32(str + '_salt_' + h1);
      return h1.toString(16).padStart(8, '0') + h2.toString(16).padStart(8, '0');
    },

    // Normalize URL for consistent hashing
    normalizeUrl(url) {
      try {
        const u = new URL(url);
        // Remove trailing slashes, normalize to lowercase host
        return (u.protocol + '//' + u.host.toLowerCase() + u.pathname.replace(/\/+$/, '') + u.search).toLowerCase();
      } catch {
        return url.toLowerCase().trim();
      }
    },

    // Generate feed GUID from URL - same URL always = same GUID
    forFeed(feedUrl) {
      const normalized = this.normalizeUrl(feedUrl);
      return 'feed_' + this.hash64(normalized);
    },

    // Generate article GUID - stable across feed re-adds
    // Uses: feedUrl + (link OR title+pubDate)
    forArticle(feedUrl, link, title, pubDate) {
      const feedPart = this.normalizeUrl(feedUrl);
      // Prefer link as it's most stable, fallback to title+date
      const contentPart = link
        ? this.normalizeUrl(link)
        : (title + '|' + (pubDate || '')).toLowerCase();
      return 'art_' + this.hash64(feedPart + '::' + contentPart);
    },

    // Generate episode GUID - stable across feed re-adds
    // Uses: feedUrl + (audioUrl OR title+pubDate)
    forEpisode(feedUrl, audioUrl, title, pubDate) {
      const feedPart = this.normalizeUrl(feedUrl);
      // Prefer audioUrl as it's unique per episode, fallback to title+date
      const contentPart = audioUrl
        ? this.normalizeUrl(audioUrl)
        : (title + '|' + (pubDate || '')).toLowerCase();
      return 'ep_' + this.hash64(feedPart + '::' + contentPart);
    }
  };

  // === MEMORY & USER BEHAVIOR SYSTEM ===
  // Optimized tracking: only sync meaningful content interactions to Xano
  // Ephemeral UI state (view changes, filters) stays local only
  const Mem = {
    pending: [],
    session: 's_' + Date.now(),
    endpoint: 'https://xvkq-pq7i-idtl.n7d.xano.io/api:Hj4C6PGO/activity',
    syncInterval: null,
    syncing: false,

    // Actions that represent meaningful content interactions - sync to DB
    SYNC_ACTIONS: new Set([
      'article_opened',      // User engaged with article content
      'play_pressed',        // Started listening to episode
      'pause_pressed',       // Paused playback (context for session)
      'episode_completed',   // Finished an episode
      'episode_exited',      // Left episode (captures exit point)
      'playback_progress',   // Significant progress updates
      'returned_to_episode', // Resumption patterns
      'seek',                // Intentional navigation within content
      'bookmark_added',      // User marked important moment
      'download_completed',  // Content acquisition
      'download_removed',    // Content removal
      'feed_added',          // Subscription change
      'feed_removed'         // Subscription change
    ]),

    // Actions that stay local only - UI state, preferences, filtering
    // view_changed, feed_opened, feed_filter_changed, category_changed,
    // tag_filter_changed, podcast_category_changed, podcast_tag_filter_changed,
    // speed_changed, swipe_seek

    // Extract stable content_url from content
    getContentUrl(data) {
      if (data.link) return data.link;
      if (data.audioUrl) return data.audioUrl;
      if (data.url) return data.url;
      // For episodes/articles, try to find the content
      if (data.episodeId) {
        const ep = state.podcasts.find(p => p.id === data.episodeId);
        if (ep) return ep.audioUrl || ep.link;
      }
      if (data.articleId) {
        const art = state.articles.find(a => a.id === data.articleId);
        if (art) return art.link;
      }
      return null;
    },

    // Check if action should be synced to remote DB
    shouldSync(action) {
      return this.SYNC_ACTIONS.has(action);
    },

    log(action, target, data = {}) {
      const content_url = this.getContentUrl(data);
      const shouldSync = this.shouldSync(action);
      const m = {
        id: 'm_' + Date.now() + '_' + Math.random().toString(36).substr(2,4),
        ts: new Date().toISOString(),
        action,
        target,
        content_url,
        session: this.session,
        ctx: { view: state.view, tab: state.tab },
        local_only: !shouldSync,
        ...data
      };

      // Always store locally for history/stats
      try {
        const a = JSON.parse(localStorage.getItem('mem') || '[]');
        a.push(m);
        // Keep more local-only events (they're cheap), fewer synced ones cached
        if (a.length > 500) a.splice(0, a.length - 500);
        localStorage.setItem('mem', JSON.stringify(a));
      } catch(e) {}

      // Only queue for remote sync if it's a meaningful content interaction
      if (shouldSync) {
        this.pending.push(m);
        this.sync();
      }
    },

    async sync() {
      if (!this.endpoint || !this.pending.length || this.syncing) return;
      this.syncing = true;

      while (this.pending.length > 0) {
        const m = this.pending[0];
        try {
          // POST each activity individually (append-only)
          const { id, ts, session, action, target, content_url, ctx, local_only, ...rest } = m;
          await fetch(this.endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              session_id: session,
              action,
              content_url: content_url || null,
              data: {
                target,
                ctx,
                ts,
                ...rest
              }
            })
          });
          this.pending.shift(); // Remove successfully synced item
        } catch(e) {
          // On failure, stop and retry later
          console.warn('Activity sync failed, will retry:', e);
          break;
        }
      }
      this.syncing = false;
    },

    setEndpoint(u) {
      this.endpoint = u;
      // Start periodic sync every 30 seconds
      if (this.syncInterval) clearInterval(this.syncInterval);
      if (u) {
        this.syncInterval = setInterval(() => this.sync(), 30000);
      }
      this.sync();
    },

    init() {
      // Start periodic sync on load
      if (this.endpoint) {
        this.syncInterval = setInterval(() => this.sync(), 30000);
      }
    },

    getLocal() {
      try { return JSON.parse(localStorage.getItem('mem') || '[]'); }
      catch(e) { return []; }
    },

    // Get only synced (meaningful) events
    getSynced() {
      return this.getLocal().filter(l => !l.local_only);
    },

    // Get only local (ephemeral) events
    getEphemeral() {
      return this.getLocal().filter(l => l.local_only);
    },

    // Get aggregated behavior stats
    getStats() {
      const logs = this.getLocal();
      const syncedLogs = logs.filter(l => !l.local_only);
      const stats = {
        totalEvents: logs.length,
        syncedEvents: syncedLogs.length,
        localOnlyEvents: logs.length - syncedLogs.length,
        sessions: [...new Set(logs.map(l => l.session))].length,
        articleReads: logs.filter(l => l.action === 'article_opened').length,
        episodePlays: logs.filter(l => l.action === 'play_pressed').length,
        searches: logs.filter(l => l.action === 'search').length,
        tagFilters: logs.filter(l => l.action === 'tag_filter_changed').length,
        byAction: {},
        byTag: {}
      };

      // Count by action type
      logs.forEach(l => {
        stats.byAction[l.action] = (stats.byAction[l.action] || 0) + 1;
      });

      // Count tag filter usage
      logs.filter(l => l.action === 'tag_filter_changed').forEach(l => {
        const tag = l.target?.replace('tag_', '') || 'unknown';
        stats.byTag[tag] = (stats.byTag[tag] || 0) + 1;
      });

      return stats;
    },

    // Clear all local logs
    clear() {
      localStorage.removeItem('mem');
      this.pending = [];
    },

    // Export all behavior data for API sync
    exportForSync() {
      return {
        logs: this.getLocal(),
        stats: this.getStats(),
        feeds: state.feeds.map(f => ({
          id: f.id,
          name: f.name,
          type: f.type,
          tags: f.tags,
          category: f.category
        })),
        preferences: {
          viewPrefs: state.viewPrefs,
          bookmarks: Object.keys(state.bookmarks).length,
          progress: Object.keys(state.progress).length
        },
        session: this.session,
        exportedAt: new Date().toISOString()
      };
    }
  };
  window.Memory = Mem;

  // === STATE SYNC (Server-side storage for cross-device consistency) ===
  // This ensures the app shows the same data on any device by always fetching from server
  const StateSync = {
    endpoint: 'https://xvkq-pq7i-idtl.n7d.xano.io/api:Hj4C6PGO/store',
    syncing: false,
    lastSync: null,
    syncQueue: null, // Pending save operation
    syncTimeout: null, // Debounce timer

    // Fetch state from server (GET)
    async fetchState() {
      if (!this.endpoint) return null;
      try {
        const response = await fetch(this.endpoint, {
          method: 'GET',
          headers: { 'Content-Type': 'application/json' }
        });
        if (!response.ok) {
          console.warn('[StateSync] Server returned:', response.status);
          return null;
        }
        const data = await response.json();
        console.log('[StateSync] Fetched state from server');
        return data;
      } catch (e) {
        console.warn('[StateSync] Failed to fetch state:', e.message);
        return null;
      }
    },

    // Save state to server (POST) - debounced
    async saveState(stateData) {
      if (!this.endpoint) return false;

      // Queue the save and debounce
      this.syncQueue = stateData;

      if (this.syncTimeout) {
        clearTimeout(this.syncTimeout);
      }

      // Debounce: wait 2 seconds before actually syncing
      this.syncTimeout = setTimeout(() => this._doSync(), 2000);
      return true;
    },

    // Actually perform the sync
    async _doSync() {
      if (this.syncing || !this.syncQueue) return;
      this.syncing = true;

      const stateData = this.syncQueue;
      this.syncQueue = null;

      try {
        const response = await fetch(this.endpoint, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            data: stateData,
            updated_at: new Date().toISOString()
          })
        });
        if (response.ok) {
          this.lastSync = Date.now();
          console.log('[StateSync] State saved to server');
        } else {
          console.warn('[StateSync] Failed to save state:', response.status);
        }
      } catch (e) {
        console.warn('[StateSync] Sync error:', e.message);
      }
      this.syncing = false;
    },

    // Force immediate sync (e.g., before page unload)
    async flushSync() {
      if (this.syncTimeout) {
        clearTimeout(this.syncTimeout);
        this.syncTimeout = null;
      }
      if (this.syncQueue) {
        await this._doSync();
      }
    }
  };
  window.StateSync = StateSync;

  // === DOWNLOAD STORAGE (IndexedDB) ===
  const DownloadDB = {
    db: null,
    DB_NAME: 'feedr_downloads',
    STORE_NAME: 'audio_files',

    async init() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(this.DB_NAME, 1);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => { this.db = request.result; resolve(); };
        request.onupgradeneeded = (e) => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains(this.STORE_NAME)) {
            db.createObjectStore(this.STORE_NAME, { keyPath: 'id' });
          }
        };
      });
    },

    async save(id, blob, metadata = {}) {
      return new Promise((resolve, reject) => {
        const tx = this.db.transaction(this.STORE_NAME, 'readwrite');
        const store = tx.objectStore(this.STORE_NAME);
        const request = store.put({ id, blob, metadata, savedAt: Date.now() });
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    },

    async get(id) {
      return new Promise((resolve, reject) => {
        const tx = this.db.transaction(this.STORE_NAME, 'readonly');
        const store = tx.objectStore(this.STORE_NAME);
        const request = store.get(id);
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    },

    async delete(id) {
      return new Promise((resolve, reject) => {
        const tx = this.db.transaction(this.STORE_NAME, 'readwrite');
        const store = tx.objectStore(this.STORE_NAME);
        const request = store.delete(id);
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    },

    async has(id) {
      const record = await this.get(id);
      return !!record;
    },

    async getAll() {
      return new Promise((resolve, reject) => {
        const tx = this.db.transaction(this.STORE_NAME, 'readonly');
        const store = tx.objectStore(this.STORE_NAME);
        const request = store.getAllKeys();
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }
  };

  // === STATE SNAPSHOT SYSTEM (IndexedDB) ===
  // Enables historical state restoration - keeps last N snapshots
  const SnapshotDB = {
    db: null,
    DB_NAME: 'feedr_snapshots',
    STORE_NAME: 'snapshots',
    MAX_SNAPSHOTS: 20, // Keep last 20 snapshots

    async init() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(this.DB_NAME, 1);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => { this.db = request.result; resolve(); };
        request.onupgradeneeded = (e) => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains(this.STORE_NAME)) {
            const store = db.createObjectStore(this.STORE_NAME, { keyPath: 'id' });
            store.createIndex('timestamp', 'timestamp', { unique: false });
          }
        };
      });
    },

    // Create a snapshot of the current state
    async createSnapshot(reason = 'manual') {
      if (!this.db) await this.init();

      const snapshot = {
        id: 'snap_' + Date.now(),
        timestamp: Date.now(),
        reason, // 'manual', 'auto', 'before_delete', 'before_refresh', etc.
        state: {
          feeds: JSON.parse(JSON.stringify(state.feeds)),
          articles: JSON.parse(JSON.stringify(state.articles)),
          podcasts: JSON.parse(JSON.stringify(state.podcasts)),
          archivedArticles: JSON.parse(JSON.stringify(state.archivedArticles || [])),
          archivedPodcasts: JSON.parse(JSON.stringify(state.archivedPodcasts || [])),
          progress: JSON.parse(JSON.stringify(state.progress)),
          bookmarks: JSON.parse(JSON.stringify(state.bookmarks)),
          feedLastViewed: JSON.parse(JSON.stringify(state.feedLastViewed || {}))
        },
        stats: {
          feedCount: state.feeds.length,
          articleCount: state.articles.length,
          podcastCount: state.podcasts.length,
          bookmarkCount: Object.keys(state.bookmarks || {}).length
        }
      };

      return new Promise(async (resolve, reject) => {
        try {
          const tx = this.db.transaction(this.STORE_NAME, 'readwrite');
          const store = tx.objectStore(this.STORE_NAME);

          await new Promise((res, rej) => {
            const request = store.put(snapshot);
            request.onsuccess = () => res();
            request.onerror = () => rej(request.error);
          });

          // Prune old snapshots to keep only MAX_SNAPSHOTS
          await this.pruneOldSnapshots();

          resolve(snapshot.id);
        } catch (e) {
          reject(e);
        }
      });
    },

    // Get all snapshots (metadata only, not full state)
    async listSnapshots() {
      if (!this.db) await this.init();

      return new Promise((resolve, reject) => {
        const tx = this.db.transaction(this.STORE_NAME, 'readonly');
        const store = tx.objectStore(this.STORE_NAME);
        const request = store.getAll();
        request.onsuccess = () => {
          // Return metadata without full state (for UI listing)
          const snapshots = request.result.map(s => ({
            id: s.id,
            timestamp: s.timestamp,
            reason: s.reason,
            stats: s.stats,
            date: new Date(s.timestamp).toLocaleString()
          }));
          // Sort newest first
          snapshots.sort((a, b) => b.timestamp - a.timestamp);
          resolve(snapshots);
        };
        request.onerror = () => reject(request.error);
      });
    },

    // Get a specific snapshot with full state
    async getSnapshot(id) {
      if (!this.db) await this.init();

      return new Promise((resolve, reject) => {
        const tx = this.db.transaction(this.STORE_NAME, 'readonly');
        const store = tx.objectStore(this.STORE_NAME);
        const request = store.get(id);
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    },

    // Restore state from a snapshot
    async restoreSnapshot(id) {
      const snapshot = await this.getSnapshot(id);
      if (!snapshot) throw new Error('Snapshot not found');

      // Create a snapshot of current state before restoring (safety net)
      await this.createSnapshot('before_restore');

      // Restore the state
      const s = snapshot.state;
      state.feeds = s.feeds || [];
      state.articles = s.articles || [];
      state.podcasts = s.podcasts || [];
      state.archivedArticles = s.archivedArticles || [];
      state.archivedPodcasts = s.archivedPodcasts || [];
      state.progress = s.progress || {};
      state.bookmarks = s.bookmarks || {};
      state.feedLastViewed = s.feedLastViewed || {};

      // Rebuild categories from restored feeds
      state.categories.clear();
      state.feeds.forEach(f => f.category && state.categories.add(f.category));

      // Save the restored state
      save();

      return snapshot;
    },

    // Delete a specific snapshot
    async deleteSnapshot(id) {
      if (!this.db) await this.init();

      return new Promise((resolve, reject) => {
        const tx = this.db.transaction(this.STORE_NAME, 'readwrite');
        const store = tx.objectStore(this.STORE_NAME);
        const request = store.delete(id);
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    },

    // Remove old snapshots keeping only MAX_SNAPSHOTS
    async pruneOldSnapshots() {
      const snapshots = await this.listSnapshots();
      if (snapshots.length > this.MAX_SNAPSHOTS) {
        const toDelete = snapshots.slice(this.MAX_SNAPSHOTS);
        for (const snap of toDelete) {
          await this.deleteSnapshot(snap.id);
        }
      }
    },

    // Clear all snapshots
    async clearAll() {
      if (!this.db) await this.init();

      return new Promise((resolve, reject) => {
        const tx = this.db.transaction(this.STORE_NAME, 'readwrite');
        const store = tx.objectStore(this.STORE_NAME);
        const request = store.clear();
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    }
  };

  // Expose snapshot functions globally
  window.Snapshots = {
    create: (reason) => SnapshotDB.createSnapshot(reason),
    list: () => SnapshotDB.listSnapshots(),
    get: (id) => SnapshotDB.getSnapshot(id),
    restore: (id) => SnapshotDB.restoreSnapshot(id),
    delete: (id) => SnapshotDB.deleteSnapshot(id)
  };

  // Track ongoing downloads
  const downloadProgress = {}; // { episodeId: { progress: 0-100, status: 'downloading'|'done'|'error' } }
  
  // === CONTENT TAGS TAXONOMY ===
  // Comprehensive tag system for auto-categorizing content
  const CONTENT_TAGS = {
    // News Categories
    technology: {
      label: 'Technology',
      icon: '<i class="ph ph-desktop"></i>',
      keywords: ['tech', 'technology', 'software', 'hardware', 'programming', 'code', 'developer', 'app', 'startup', 'silicon valley', 'ai', 'artificial intelligence', 'machine learning', 'robotics', 'cyber', 'digital', 'computer', 'internet', 'web', 'mobile', 'gadget', 'innovation', 'blockchain', 'crypto', 'cloud', 'data', 'algorithm', 'api', 'devops', 'saas', 'fintech', 'techcrunch', 'wired', 'verge', 'ars technica', 'hacker', 'github', 'open source']
    },
    business: {
      label: 'Business',
      icon: '<i class="ph ph-briefcase"></i>',
      keywords: ['business', 'economy', 'market', 'stock', 'invest', 'finance', 'entrepreneur', 'startup', 'company', 'corporate', 'trade', 'commerce', 'industry', 'ceo', 'executive', 'revenue', 'profit', 'wall street', 'nasdaq', 'dow', 'earnings', 'merger', 'acquisition', 'ipo', 'venture capital', 'forbes', 'bloomberg', 'wsj', 'financial times', 'economist']
    },
    politics: {
      label: 'Politics',
      icon: '<i class="ph ph-bank"></i>',
      keywords: ['politics', 'political', 'government', 'election', 'congress', 'senate', 'parliament', 'president', 'minister', 'democrat', 'republican', 'liberal', 'conservative', 'policy', 'legislation', 'vote', 'campaign', 'poll', 'diplomacy', 'foreign policy', 'washington', 'capitol', 'white house', 'politico', 'axios']
    },
    science: {
      label: 'Science',
      icon: '<i class="ph ph-flask"></i>',
      keywords: ['science', 'research', 'study', 'scientist', 'discovery', 'experiment', 'physics', 'chemistry', 'biology', 'astronomy', 'space', 'nasa', 'climate', 'environment', 'nature', 'evolution', 'genetics', 'quantum', 'laboratory', 'scientific american', 'new scientist', 'phys.org']
    },
    health: {
      label: 'Health',
      icon: '<i class="ph ph-first-aid-kit"></i>',
      keywords: ['health', 'medical', 'medicine', 'doctor', 'hospital', 'disease', 'treatment', 'therapy', 'wellness', 'fitness', 'nutrition', 'diet', 'mental health', 'psychology', 'vaccine', 'pharmaceutical', 'fda', 'cdc', 'healthcare', 'patient', 'diagnosis', 'symptom']
    },
    entertainment: {
      label: 'Entertainment',
      icon: '<i class="ph ph-film-strip"></i>',
      keywords: ['entertainment', 'movie', 'film', 'tv', 'television', 'show', 'series', 'celebrity', 'actor', 'actress', 'music', 'album', 'concert', 'streaming', 'netflix', 'disney', 'hollywood', 'box office', 'award', 'oscar', 'emmy', 'grammy', 'variety', 'deadline', 'ign', 'gamespot']
    },
    sports: {
      label: 'Sports',
      icon: '<i class="ph ph-soccer-ball"></i>',
      keywords: ['sports', 'football', 'soccer', 'basketball', 'baseball', 'hockey', 'tennis', 'golf', 'olympics', 'nfl', 'nba', 'mlb', 'nhl', 'fifa', 'espn', 'athlete', 'team', 'league', 'championship', 'tournament', 'game', 'score', 'player', 'coach']
    },
    gaming: {
      label: 'Gaming',
      icon: '<i class="ph ph-game-controller"></i>',
      keywords: ['gaming', 'game', 'video game', 'playstation', 'xbox', 'nintendo', 'steam', 'pc gaming', 'esports', 'twitch', 'streamer', 'fps', 'rpg', 'mmorpg', 'indie game', 'gamer', 'console', 'gameplay', 'kotaku', 'polygon', 'ign']
    },
    world: {
      label: 'World News',
      icon: '<i class="ph ph-globe"></i>',
      keywords: ['world', 'international', 'global', 'foreign', 'abroad', 'overseas', 'europe', 'asia', 'africa', 'middle east', 'latin america', 'united nations', 'un', 'eu', 'nato', 'bbc', 'reuters', 'ap news', 'afp', 'al jazeera']
    },
    finance: {
      label: 'Finance',
      icon: '<i class="ph ph-chart-line-up"></i>',
      keywords: ['finance', 'money', 'banking', 'investment', 'trading', 'forex', 'cryptocurrency', 'bitcoin', 'ethereum', 'defi', 'personal finance', 'savings', 'retirement', 'mortgage', 'loan', 'credit', 'portfolio', 'dividend', 'bond', 'mutual fund', 'etf']
    },
    education: {
      label: 'Education',
      icon: '<i class="ph ph-books"></i>',
      keywords: ['education', 'learning', 'school', 'university', 'college', 'student', 'teacher', 'course', 'curriculum', 'academic', 'research', 'study', 'degree', 'scholarship', 'online learning', 'mooc', 'tutorial', 'lecture']
    },
    lifestyle: {
      label: 'Lifestyle',
      icon: '<i class="ph ph-sparkle"></i>',
      keywords: ['lifestyle', 'fashion', 'travel', 'food', 'cooking', 'recipe', 'home', 'interior', 'design', 'beauty', 'style', 'wellness', 'self-care', 'hobby', 'diy', 'craft', 'garden', 'pet']
    },

    // Podcast Categories
    truecrime: {
      label: 'True Crime',
      icon: '<i class="ph ph-magnifying-glass"></i>',
      keywords: ['true crime', 'murder', 'mystery', 'investigation', 'detective', 'crime', 'serial killer', 'cold case', 'forensic', 'criminal', 'unsolved', 'case file', 'dateline', 'criminal podcast']
    },
    comedy: {
      label: 'Comedy',
      icon: '<i class="ph ph-smiley"></i>',
      keywords: ['comedy', 'funny', 'humor', 'joke', 'laugh', 'comedian', 'standup', 'improv', 'sketch', 'satire', 'parody', 'hilarious']
    },
    interview: {
      label: 'Interviews',
      icon: '<i class="ph ph-microphone"></i>',
      keywords: ['interview', 'conversation', 'talk', 'chat', 'discussion', 'guest', 'host', 'q&a', 'dialogue', 'joe rogan', 'lex fridman', 'marc maron', 'tim ferriss']
    },
    history: {
      label: 'History',
      icon: '<i class="ph ph-scroll"></i>',
      keywords: ['history', 'historical', 'ancient', 'medieval', 'war', 'civilization', 'empire', 'revolution', 'documentary', 'dan carlin', 'hardcore history']
    },
    selfhelp: {
      label: 'Self-Help',
      icon: '<i class="ph ph-flower-lotus"></i>',
      keywords: ['self-help', 'self help', 'improvement', 'motivation', 'productivity', 'mindfulness', 'meditation', 'habits', 'success', 'mindset', 'growth', 'personal development', 'life coaching']
    },
    storytelling: {
      label: 'Storytelling',
      icon: '<i class="ph ph-book-open"></i>',
      keywords: ['story', 'storytelling', 'narrative', 'fiction', 'audio drama', 'serial', 'this american life', 'radiolab', 'moth', 'tale', 'anthology']
    },
    news_daily: {
      label: 'Daily News',
      icon: '<i class="ph ph-newspaper"></i>',
      keywords: ['daily', 'news', 'briefing', 'morning', 'update', 'headlines', 'today', 'current events', 'the daily', 'up first', 'news roundup']
    },
    culture: {
      label: 'Culture',
      icon: '<i class="ph ph-masks-theater"></i>',
      keywords: ['culture', 'society', 'social', 'cultural', 'art', 'literature', 'philosophy', 'ideas', 'think', 'debate', 'discourse', 'cultural commentary']
    }
  };

  // Get all tag keys for iteration
  const TAG_KEYS = Object.keys(CONTENT_TAGS);

  // === FUZZY MATCHING FOR AUTO-TAGGING ===
  // Advanced fuzzy matcher that scores content against tag keywords
  const calculateTagScore = (text, tag) => {
    if (!text || !tag) return 0;
    const textLower = text.toLowerCase();
    const keywords = CONTENT_TAGS[tag]?.keywords || [];
    let score = 0;
    let matches = 0;

    for (const keyword of keywords) {
      const keywordLower = keyword.toLowerCase();
      if (textLower.includes(keywordLower)) {
        // Longer keyword matches are worth more
        const weight = keyword.length > 10 ? 3 : keyword.length > 5 ? 2 : 1;
        score += weight;
        matches++;
      }
    }

    // Bonus for multiple matches
    if (matches > 2) score *= 1.5;
    if (matches > 5) score *= 2;

    return score;
  };

  // Auto-detect tags for a feed based on its metadata
  const autoDetectFeedTags = (feed, feedContent = '') => {
    const textToAnalyze = [
      feed.name || '',
      feed.author || '',
      feed.description || '',
      feed.category || '',
      feed.url || '',
      feedContent
    ].join(' ').toLowerCase();

    const tagScores = [];
    for (const tagKey of TAG_KEYS) {
      const score = calculateTagScore(textToAnalyze, tagKey);
      if (score > 0) {
        tagScores.push({ tag: tagKey, score });
      }
    }

    // Sort by score descending and take top 3
    tagScores.sort((a, b) => b.score - a.score);
    return tagScores.slice(0, 3).map(t => t.tag);
  };

  // Auto-detect tags for an individual content item (article/episode)
  const autoDetectItemTags = (item, feedTags = []) => {
    const textToAnalyze = [
      item.title || '',
      item.summary || item.desc || '',
    ].join(' ').toLowerCase();

    const tagScores = [];
    for (const tagKey of TAG_KEYS) {
      let score = calculateTagScore(textToAnalyze, tagKey);
      // Give bonus if feed already has this tag
      if (feedTags.includes(tagKey)) score *= 1.5;
      if (score > 0) {
        tagScores.push({ tag: tagKey, score });
      }
    }

    tagScores.sort((a, b) => b.score - a.score);

    // If no tags detected, inherit from feed
    if (tagScores.length === 0 && feedTags.length > 0) {
      return [feedTags[0]];
    }

    return tagScores.slice(0, 2).map(t => t.tag);
  };

  // Get tag info by key
  const getTagInfo = (tagKey) => CONTENT_TAGS[tagKey] || { label: tagKey, icon: '<i class="ph ph-tag"></i>', keywords: [] };

  // === FUZZY SEARCH ===
  const fuzzy = (q, items, fields) => {
    if (!q.trim()) return items;
    const ql = q.toLowerCase();
    return items.map(item => {
      let score = 0;
      for (const f of fields) {
        const v = f.split('.').reduce((o, k) => o?.[k], item);
        if (v && String(v).toLowerCase().includes(ql)) score = 1;
      }
      return { item, score };
    }).filter(x => x.score > 0).map(x => x.item);
  };

  // Filter items by tag
  const filterByTag = (items, tag) => {
    if (!tag || tag === 'all') return items;
    return items.filter(item => item.tags && item.tags.includes(tag));
  };
  
  // === STATE ===
  const state = {
    view: 'podcasts',
    tab: 'home',
    feeds: [],
    articles: [],
    podcasts: [],
    archivedArticles: [], // Historical articles no longer in feed but preserved locally
    archivedPodcasts: [], // Historical episodes no longer in feed but preserved locally
    categories: new Set(['All']),
    podcastCategories: new Set(['All']), // Categories for podcast feeds
    selectedSource: null,
    selectedCat: 'All',
    selectedTag: 'all', // Selected tag filter
    // Podcast inbox filters
    selectedPodcastSource: null, // Currently selected podcast source (null = all)
    selectedPodcastCat: 'All', // Category filter for podcasts
    selectedPodcastTag: 'all', // Tag filter for podcasts
    feedFilter: 'all', // Feed filter: 'all', 'news', 'podcast'
    query: '',
    feedType: 'news',
    currentEp: null,
    playing: false,
    speed: 1,
    progress: {},
    viewPrefs: {}, // { sourceId: 'list'|'table'|'cards'|'masonry' }
    currentSourcePage: null, // Currently viewing source page (news)
    currentShowPage: null, // Currently viewing show page (podcasts)
    bookmarks: {}, // { episodeId: [{ time, note, created }] }
    sleepTimer: null, // { endTime, intervalId, fadeIntervalId }
    speedPanelOpen: false,
    bookmarksPanelOpen: false,
    feedLastViewed: {}, // { feedId: timestamp } - when user last viewed each feed
    userBehavior: { // Track user behavior for API sync
      reads: [], // { articleId, timestamp, duration }
      plays: [], // { episodeId, timestamp, duration, completed }
      searches: [], // { query, timestamp, results }
      subscriptions: [] // { feedId, timestamp, action: 'add'|'remove' }
    },
    openLinksInNewTab: true // Whether clicking articles opens in new tab (true) or same tab (false)
  };
  
  // === DOM ===
  const $ = id => document.getElementById(id);
  const el = {
    newsView: $('newsView'), podcastView: $('podcastView'), allView: $('allView'),
    feedNav: $('feedNav'), feedScroll: $('feedScroll'),
    feedCountAll: $('feedCountAll'), feedCountNews: $('feedCountNews'), feedCountPodcast: $('feedCountPodcast'),
    newsSources: $('newsSources'), newsTitle: $('newsTitle'),
    categoryChips: $('categoryChips'), newsList: $('newsList'),
    newsContent: $('newsContent'), sourcePage: $('sourcePage'),
    tagFilterSection: $('tagFilterSection'), tagChips: $('tagChips'),
    // Podcast inbox elements
    podcastSources: $('podcastSources'), podcastInboxTitle: $('podcastInboxTitle'),
    podcastCategoryChips: $('podcastCategoryChips'), podcastInboxList: $('podcastInboxList'),
    podcastInboxContent: $('podcastInboxContent'), podcastTagFilterSection: $('podcastTagFilterSection'),
    podcastTagChips: $('podcastTagChips'),
    showPage: $('showPage'),
    player: $('player'), playerArt: $('playerArt'), playerTitle: $('playerTitle'),
    playerShow: $('playerShow'), pPlay: $('pPlay'), pPlayIcon: $('pPlayIcon'),
    pCur: $('pCur'), pDur: $('pDur'), pBar: $('pBar'), pFill: $('pFill'), pSpeed: $('pSpeed'), scrubTooltip: $('scrubTooltip'),
    pBookmark: $('pBookmark'), pSleep: $('pSleep'),
    speedPanel: $('speedPanel'), speedSlider: $('speedSlider'), speedValue: $('speedValue'),
    bookmarksPanel: $('bookmarksPanel'), bookmarksList: $('bookmarksList'), addBookmarkBtn: $('addBookmarkBtn'),
    sleepBadge: $('sleepBadge'),
    expanded: $('expanded'), expArt: $('expArt'), expTitle: $('expTitle'),
    expShow: $('expShow'), expPlay: $('expPlay'), expPlayIcon: $('expPlayIcon'),
    expCur: $('expCur'), expDur: $('expDur'), expBar: $('expBar'), expFill: $('expFill'),
    swipeContainer: $('swipeContainer'), swipeIndicator: $('swipeIndicator'),
    swipeIcon: $('swipeIcon'), swipeText: $('swipeText'), swipeLabel: $('swipeLabel'),
    modal: $('modal'), fUrl: $('fUrl'), fName: $('fName'), fAuthor: $('fAuthor'), fCat: $('fCat'),
    fFetch: $('fFetch'), fStatus: $('fStatus'), fSubmit: $('fSubmit'),
    toast: $('toast'), searchInput: $('searchInput'),
    audio: $('audioPlayer'),
    // New elements
    hamburgerBtn: $('hamburgerBtn'), drawer: $('drawer'), drawerOverlay: $('drawerOverlay'),
    drawerContent: $('drawerContent'), drawerClose: $('drawerClose'),
    sleepTimerModal: $('sleepTimerModal'), sleepTimerContent: $('sleepTimerContent'),
    sleepTimerActive: $('sleepTimerActive'), sleepCountdown: $('sleepCountdown'),
    sleepPresets: $('sleepPresets'), sleepCustomInput: $('sleepCustomInput'),
    sleepCustomBtn: $('sleepCustomBtn'), sleepCancelBtn: $('sleepCancelBtn'),
    // Settings modal
    settingsBtn: $('settingsBtn'), settingsModal: $('settingsModal'),
    settingsClose: $('settingsClose'), openLinksToggle: $('openLinksToggle'),
    // Snapshot modal
    snapshotModal: $('snapshotModal'), snapshotModalClose: $('snapshotModalClose'),
    snapshotList: $('snapshotList'), createSnapshotBtn: $('createSnapshotBtn')
  };
  
  // === UTILS ===
  const fmt = s => { if (isNaN(s) || s < 0) return '0:00'; const m = Math.floor(s / 60), sec = Math.floor(s % 60); return m + ':' + String(sec).padStart(2, '0'); };
  const fmtLong = s => { if (isNaN(s) || s < 0) return '0:00'; const h = Math.floor(s / 3600), m = Math.floor((s % 3600) / 60), sec = Math.floor(s % 60); return h > 0 ? h + ':' + String(m).padStart(2, '0') + ':' + String(sec).padStart(2, '0') : m + ':' + String(sec).padStart(2, '0'); };
  const toast = m => { el.toast.textContent = m; el.toast.classList.add('show'); setTimeout(() => el.toast.classList.remove('show'), 2500); };
  const openArticleLink = url => { if (url) state.openLinksInNewTab ? window.open(url, '_blank') : window.location.href = url; };
  const save = () => {
    const stateData = {
      feeds: state.feeds,
      articles: state.articles,
      podcasts: state.podcasts,
      archivedArticles: state.archivedArticles,
      archivedPodcasts: state.archivedPodcasts,
      progress: state.progress,
      view: state.view,
      viewPrefs: state.viewPrefs,
      bookmarks: state.bookmarks,
      userBehavior: state.userBehavior,
      feedLastViewed: state.feedLastViewed,
      openLinksInNewTab: state.openLinksInNewTab
    };
    // Save to localStorage for immediate local access
    localStorage.setItem('feedr2', JSON.stringify(stateData));
    // Also sync to server for cross-device consistency (debounced)
    StateSync.saveState(stateData);
  };

  // Helper to apply state data from either server or localStorage
  const applyStateData = (d) => {
    if (!d) return false;
    state.feeds = d.feeds || [];
    state.articles = d.articles || [];
    state.podcasts = d.podcasts || [];
    state.archivedArticles = d.archivedArticles || [];
    state.archivedPodcasts = d.archivedPodcasts || [];
    state.progress = d.progress || {};
    if (d.view) state.view = d.view;
    state.viewPrefs = d.viewPrefs || {};
    state.bookmarks = d.bookmarks || {};
    state.userBehavior = d.userBehavior || { reads: [], plays: [], searches: [], subscriptions: [] };
    state.feedLastViewed = d.feedLastViewed || {};
    if (typeof d.openLinksInNewTab === 'boolean') state.openLinksInNewTab = d.openLinksInNewTab;

    // Migrate: ensure all feeds have tags array
    state.feeds.forEach(f => {
      if (!f.tags) f.tags = [];
    });
    // Migrate: ensure all articles have tags array
    state.articles.forEach(a => {
      if (!a.tags) a.tags = [];
    });
    // Migrate: ensure all podcasts have tags array
    state.podcasts.forEach(p => {
      if (!p.tags) p.tags = [];
    });
    return true;
  };

  const load = async () => {
    let loaded = false;

    // ALWAYS try server first for cross-device consistency
    try {
      const serverData = await StateSync.fetchState();
      if (serverData && serverData.data) {
        // Server has stored state - use it as source of truth
        loaded = applyStateData(serverData.data);
        if (loaded) {
          console.log('[StateSync] Using server state for consistency');
          // Update localStorage to match server state
          localStorage.setItem('feedr2', JSON.stringify(serverData.data));
        }
      }
    } catch (e) {
      console.warn('[StateSync] Server fetch failed, will try localStorage:', e.message);
    }

    // Fallback to localStorage only if server didn't provide data
    if (!loaded) {
      try {
        const d = JSON.parse(localStorage.getItem('feedr2'));
        if (d) {
          loaded = applyStateData(d);
          console.log('[StateSync] Using localStorage (server unavailable or empty)');
        }
      } catch(e) {
        console.warn('[StateSync] localStorage parse failed:', e.message);
      }
    }

    state.feeds.forEach(f => f.category && state.categories.add(f.category));
    if (!state.feeds.length) loadDemo();
  };

  // Get/set view preference for a source
  const getViewPref = (sourceId, defaultView = 'list') => state.viewPrefs[sourceId] || defaultView;
  const setViewPref = (sourceId, viewMode) => { state.viewPrefs[sourceId] = viewMode; save(); };

  // === NEW CONTENT TRACKING ===
  // Mark a feed as viewed (user opened it)
  const markFeedViewed = (feedId) => {
    state.feedLastViewed[feedId] = Date.now();
    save();
  };

  // Get the newest content date for a feed
  const getNewestContentDate = (feedId) => {
    const feed = state.feeds.find(f => f.id === feedId);
    if (!feed) return null;

    const items = feed.type === 'podcast'
      ? state.podcasts.filter(p => p.feedId === feedId)
      : state.articles.filter(a => a.feedId === feedId);

    if (!items.length) return null;

    // Find newest pubDate
    let newest = null;
    items.forEach(item => {
      const date = item.pubDate ? new Date(item.pubDate).getTime() : null;
      if (date && (!newest || date > newest)) newest = date;
    });
    return newest;
  };

  // Check if feed has new content since last viewed
  const feedHasNewContent = (feedId) => {
    const lastViewed = state.feedLastViewed[feedId];
    const newestContent = getNewestContentDate(feedId);

    // If never viewed, it has new content (if there's any content)
    if (!lastViewed) return newestContent !== null;

    // Compare newest content to last viewed time
    return newestContent && newestContent > lastViewed;
  };

  // Get count of new items since last viewed
  const getNewItemCount = (feedId) => {
    const lastViewed = state.feedLastViewed[feedId];
    if (!lastViewed) return 0; // Don't show count if never viewed

    const feed = state.feeds.find(f => f.id === feedId);
    if (!feed) return 0;

    const items = feed.type === 'podcast'
      ? state.podcasts.filter(p => p.feedId === feedId)
      : state.articles.filter(a => a.feedId === feedId);

    return items.filter(item => {
      const date = item.pubDate ? new Date(item.pubDate).getTime() : null;
      return date && date > lastViewed;
    }).length;
  };

  // Format relative time for "Updated X ago" display
  const formatUpdatedAgo = (timestamp) => {
    if (!timestamp) return '';
    const now = Date.now();
    const diff = now - timestamp;
    const mins = Math.floor(diff / 60000);
    const hours = Math.floor(diff / 3600000);
    const days = Math.floor(diff / 86400000);

    if (mins < 1) return 'Just now';
    if (mins < 60) return `${mins}m ago`;
    if (hours < 24) return `${hours}h ago`;
    if (days < 7) return `${days}d ago`;
    return new Date(timestamp).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
  };
  
  const loadDemo = () => {
    // No sample data - users add their own feeds
    state.feeds = [];
    state.articles = [];
    state.podcasts = [];
    state.progress = {};
    save();
  };

  // === RSS FEED FETCHING ===
  // Simpler, more reliable CORS proxy configuration
  const CORS_PROXIES = [
    url => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
    url => `https://corsproxy.io/?${encodeURIComponent(url)}`,
    url => `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`
  ];

  const fetchWithTimeout = (url, options = {}, timeout = 15000) => {
    return Promise.race([
      fetch(url, options),
      new Promise((_, reject) =>
        setTimeout(() => reject(new Error('Request timeout')), timeout)
      )
    ]);
  };

  const fetchWithProxy = async (url) => {
    // Try all proxies in parallel for faster response
    const proxyAttempts = CORS_PROXIES.map(async (proxyFn, index) => {
      const proxyUrl = proxyFn(url);
      console.log(`Trying proxy ${index}:`, proxyUrl);

      const response = await fetchWithTimeout(proxyUrl, {
        headers: { 'Accept': 'application/rss+xml, application/xml, text/xml, */*' }
      }, 12000); // Shorter timeout since we're racing

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }

      const text = await response.text();

      if (!text || text.trim().length === 0) {
        throw new Error('Empty response');
      }

      // Basic validation that this looks like XML
      if (!text.trim().startsWith('<?xml') && !text.trim().startsWith('<rss') && !text.trim().startsWith('<feed')) {
        console.warn('Response does not look like XML:', text.substring(0, 100));
      }

      return text;
    });

    // Return first successful result
    try {
      const result = await Promise.any(proxyAttempts);
      return result;
    } catch (e) {
      throw new Error(`All CORS proxies failed for: ${url}`);
    }
  };

  // Download audio file with progress tracking
  const downloadAudioFile = async (episodeId, audioUrl, onProgress) => {
    // Try direct fetch first, then CORS proxies
    const urlsToTry = [
      audioUrl,
      ...CORS_PROXIES.map(p => p(audioUrl))
    ];

    for (let i = 0; i < urlsToTry.length; i++) {
      const url = urlsToTry[i];
      try {
        const response = await fetch(url);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);

        const contentLength = response.headers.get('content-length');
        const total = contentLength ? parseInt(contentLength, 10) : 0;

        if (!response.body) {
          // Fallback for browsers without ReadableStream support
          const blob = await response.blob();
          if (onProgress) onProgress(100);
          return blob;
        }

        const reader = response.body.getReader();
        const chunks = [];
        let received = 0;

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          chunks.push(value);
          received += value.length;
          if (total && onProgress) {
            onProgress(Math.round((received / total) * 100));
          }
        }

        const blob = new Blob(chunks, { type: response.headers.get('content-type') || 'audio/mpeg' });
        if (onProgress) onProgress(100);
        return blob;
      } catch (e) {
        console.warn(`Download attempt ${i + 1} failed:`, e.message);
        if (i === urlsToTry.length - 1) throw e;
      }
    }
    throw new Error('All download attempts failed');
  };

  // Start downloading an episode
  const startDownload = async (episodeId) => {
    const ep = state.podcasts.find(p => p.id === episodeId);
    if (!ep || !ep.audioUrl) {
      toast('No audio URL for this episode');
      return;
    }

    if (downloadProgress[episodeId]?.status === 'downloading') {
      toast('Already downloading...');
      return;
    }

    downloadProgress[episodeId] = { progress: 0, status: 'downloading' };
    renderPodcasts();
    if (state.currentShowPage) renderShowPage(state.currentShowPage);

    try {
      toast('Starting download...');
      const blob = await downloadAudioFile(episodeId, ep.audioUrl, (progress) => {
        downloadProgress[episodeId].progress = progress;
        // Update UI periodically (not every progress update to avoid excessive re-renders)
        if (progress % 10 === 0 || progress === 100) {
          renderPodcasts();
          if (state.currentShowPage) renderShowPage(state.currentShowPage);
        }
      });

      // Save to IndexedDB
      await DownloadDB.save(episodeId, blob, {
        title: ep.title,
        audioUrl: ep.audioUrl,
        size: blob.size
      });

      ep.downloaded = true;
      downloadProgress[episodeId] = { progress: 100, status: 'done' };
      save();
      Mem.log('download_completed', episodeId, { size: blob.size, audioUrl: ep.audioUrl });
      toast('Download complete!');
    } catch (e) {
      console.error('Download failed:', e);
      downloadProgress[episodeId] = { progress: 0, status: 'error' };
      toast('Download failed: ' + e.message);
    }

    renderPodcasts();
    if (state.currentShowPage) renderShowPage(state.currentShowPage);
  };

  // Remove a downloaded episode
  const removeDownload = async (episodeId) => {
    const ep = state.podcasts.find(p => p.id === episodeId);
    if (!ep) return;

    try {
      await DownloadDB.delete(episodeId);
      ep.downloaded = false;
      delete downloadProgress[episodeId];
      save();
      Mem.log('download_removed', episodeId, { audioUrl: ep.audioUrl });
      toast('Download removed');
    } catch (e) {
      console.error('Failed to remove download:', e);
      toast('Failed to remove download');
    }

    renderPodcasts();
    if (state.currentShowPage) renderShowPage(state.currentShowPage);
  };

  const parseRSSDate = dateStr => {
    if (!dateStr) return new Date();
    const d = new Date(dateStr);
    return isNaN(d.getTime()) ? new Date() : d;
  };

  const formatTimeAgo = date => {
    const now = new Date();
    const diff = Math.floor((now - date) / 1000);
    if (diff < 60) return 'just now';
    if (diff < 3600) return Math.floor(diff / 60) + 'm ago';
    if (diff < 86400) return Math.floor(diff / 3600) + 'h ago';
    if (diff < 604800) return Math.floor(diff / 86400) + 'd ago';
    return Math.floor(diff / 604800) + 'w ago';
  };

  const parseDuration = dur => {
    if (!dur) return 0;
    // Handle HH:MM:SS or MM:SS format
    if (dur.includes(':')) {
      const parts = dur.split(':').map(Number);
      if (parts.length === 3) return parts[0] * 3600 + parts[1] * 60 + parts[2];
      if (parts.length === 2) return parts[0] * 60 + parts[1];
    }
    // Handle seconds as number
    const num = parseInt(dur, 10);
    return isNaN(num) ? 0 : num;
  };

  // Helper to find elements with namespace support (handles itunes:*, media:*, etc.)
  const findElement = (parent, tag) => {
    // Try getElementsByTagName first (works best with namespaced elements)
    let elements = parent.getElementsByTagName(tag);
    if (elements.length > 0) return elements[0];

    // Try without namespace prefix (for local names)
    const localName = tag.includes(':') ? tag.split(':')[1] : tag;
    elements = parent.getElementsByTagName(localName);
    if (elements.length > 0) return elements[0];

    // Try with wildcard namespace
    const nsElements = parent.getElementsByTagNameNS('*', localName);
    if (nsElements.length > 0) return nsElements[0];

    // Fallback to querySelector (may not work with namespaced elements in all browsers)
    try {
      const node = parent.querySelector(tag);
      if (node) return node;
    } catch(e) {
      // Selector may be invalid for namespaced tags
    }

    return null;
  };

  // Find all elements matching a tag (for items/entries)
  const findAllElements = (parent, tag) => {
    let elements = parent.getElementsByTagName(tag);
    if (elements.length > 0) return Array.from(elements);

    const localName = tag.includes(':') ? tag.split(':')[1] : tag;
    elements = parent.getElementsByTagName(localName);
    if (elements.length > 0) return Array.from(elements);

    return [];
  };

  const getNodeText = (parent, tag) => {
    const node = findElement(parent, tag);
    return node ? node.textContent?.trim() || '' : '';
  };

  const getNodeAttr = (parent, tag, attr) => {
    const node = findElement(parent, tag);
    return node ? node.getAttribute(attr) || '' : '';
  };

  // Get image from itunes:image element (has href attribute)
  const getItunesImage = (parent) => {
    // iTunes namespace URI
    const itunesNS = 'http://www.itunes.com/dtds/podcast-1.0.dtd';

    // Try getElementsByTagNameNS with iTunes namespace
    try {
      let elements = parent.getElementsByTagNameNS(itunesNS, 'image');
      if (elements.length > 0) {
        const href = elements[0].getAttribute('href');
        if (href) return href;
      }
    } catch(e) {}

    // Try itunes:image with colon
    try {
      let elements = parent.getElementsByTagName('itunes:image');
      if (elements.length > 0) {
        const href = elements[0].getAttribute('href');
        if (href) return href;
      }
    } catch(e) {}

    // Try wildcard namespace with local name 'image'
    try {
      const elements = parent.getElementsByTagNameNS('*', 'image');
      for (let i = 0; i < elements.length; i++) {
        const href = elements[i].getAttribute('href');
        if (href) return href;
      }
    } catch(e) {}

    // Try just 'image' elements with href attribute
    const imageEls = parent.getElementsByTagName('image');
    for (let i = 0; i < imageEls.length; i++) {
      const href = imageEls[i].getAttribute('href');
      if (href) return href;
    }

    return '';
  };

  // Check if URL looks like a valid image URL (not just a homepage)
  const isValidImageUrl = url => {
    if (!url) return false;
    try {
      const parsed = new URL(url);
      // Reject URLs that are just hostnames with no meaningful path
      if (parsed.pathname === '/' || parsed.pathname === '') return false;
      // Accept URLs with image extensions or meaningful paths
      const imageExtensions = /\.(jpg|jpeg|png|gif|webp|svg|bmp|ico|avif)(\?|$)/i;
      if (imageExtensions.test(parsed.pathname)) return true;
      // Accept URLs with paths that look like they could be images
      if (parsed.pathname.length > 1) return true;
      return false;
    } catch (e) {
      return false;
    }
  };

  // Check if URL looks like a tracking pixel or icon (not a main image)
  const isLikelyTrackingOrIcon = url => {
    if (!url) return true;
    const lowUrl = url.toLowerCase();
    // Common tracking pixel patterns
    if (/pixel|track|beacon|analytics|stat|count|1x1|spacer/i.test(lowUrl)) return true;
    // Favicon patterns
    if (/favicon|icon\d*\.|apple-touch/i.test(lowUrl)) return true;
    // Common ad/tracking domains
    if (/doubleclick|googlesyndication|facebook\.com\/tr|analytics/i.test(lowUrl)) return true;
    return false;
  };

  // Extract dimensions from img tag attributes or URL
  const extractImageScore = (imgTag, url) => {
    let score = 0;
    // Check for explicit dimensions in tag
    const widthMatch = imgTag.match(/width=["']?(\d+)/i);
    const heightMatch = imgTag.match(/height=["']?(\d+)/i);
    if (widthMatch) score += parseInt(widthMatch[1]);
    if (heightMatch) score += parseInt(heightMatch[1]);
    // Bonus for large images
    if (widthMatch && parseInt(widthMatch[1]) >= 400) score += 500;
    if (heightMatch && parseInt(heightMatch[1]) >= 300) score += 500;
    // Penalty for tiny images (likely icons/tracking)
    if (widthMatch && parseInt(widthMatch[1]) < 50) score -= 1000;
    if (heightMatch && parseInt(heightMatch[1]) < 50) score -= 1000;
    // Look for size hints in URL
    if (/large|big|full|hero|featured|main|og[_-]?image/i.test(url)) score += 300;
    if (/thumb|small|tiny|icon|avatar|logo/i.test(url)) score -= 200;
    // Penalty for tracking pixels
    if (isLikelyTrackingOrIcon(url)) score -= 2000;
    return score;
  };

  // Get best URL from srcset attribute
  const getBestFromSrcset = srcset => {
    if (!srcset) return null;
    const candidates = srcset.split(',').map(s => {
      const parts = s.trim().split(/\s+/);
      const url = parts[0];
      let width = 0;
      if (parts[1]) {
        const wMatch = parts[1].match(/(\d+)w/);
        if (wMatch) width = parseInt(wMatch[1]);
      }
      return { url, width };
    }).filter(c => c.url && isValidImageUrl(c.url));
    if (!candidates.length) return null;
    // Return the largest image
    candidates.sort((a, b) => b.width - a.width);
    return candidates[0].url;
  };

  const extractImage = item => {
    // 1. Try media:content - find the best one (largest image type)
    const mediaContents = item.getElementsByTagName('media:content');
    let bestMediaContent = null;
    let bestMediaScore = -1;
    for (let i = 0; i < mediaContents.length; i++) {
      const mc = mediaContents[i];
      const url = mc.getAttribute('url');
      const medium = mc.getAttribute('medium');
      const type = mc.getAttribute('type') || '';
      const width = parseInt(mc.getAttribute('width')) || 0;
      const height = parseInt(mc.getAttribute('height')) || 0;

      if (!url || !isValidImageUrl(url)) continue;
      if (isLikelyTrackingOrIcon(url)) continue;

      // Skip non-image media
      if (medium && medium !== 'image') continue;
      if (type && !type.startsWith('image/')) continue;

      const score = width + height + (medium === 'image' ? 100 : 0);
      if (score > bestMediaScore) {
        bestMediaScore = score;
        bestMediaContent = url;
      }
    }
    if (bestMediaContent) return bestMediaContent;

    // 2. Try media:thumbnail (often used for article thumbnails)
    const thumbnails = item.getElementsByTagName('media:thumbnail');
    let bestThumb = null;
    let bestThumbScore = -1;
    for (let i = 0; i < thumbnails.length; i++) {
      const t = thumbnails[i];
      const url = t.getAttribute('url');
      const width = parseInt(t.getAttribute('width')) || 0;
      const height = parseInt(t.getAttribute('height')) || 0;
      if (url && isValidImageUrl(url) && !isLikelyTrackingOrIcon(url)) {
        const score = width + height;
        if (score > bestThumbScore) {
          bestThumbScore = score;
          bestThumb = url;
        }
      }
    }
    if (bestThumb) return bestThumb;

    // 3. Try media:group (contains multiple media elements)
    const mediaGroups = item.getElementsByTagName('media:group');
    for (let i = 0; i < mediaGroups.length; i++) {
      const group = mediaGroups[i];
      const contents = group.getElementsByTagName('media:content');
      for (let j = 0; j < contents.length; j++) {
        const url = contents[j].getAttribute('url');
        const type = contents[j].getAttribute('type') || '';
        if (url && (type.startsWith('image/') || isValidImageUrl(url)) && !isLikelyTrackingOrIcon(url)) {
          return url;
        }
      }
    }

    // 4. Try enclosure with image type OR image-like URL
    const enclosures = item.getElementsByTagName('enclosure');
    for (let i = 0; i < enclosures.length; i++) {
      const enc = enclosures[i];
      const type = enc.getAttribute('type') || '';
      const url = enc.getAttribute('url') || '';
      if (type.startsWith('image/') && isValidImageUrl(url)) {
        return url;
      }
      // Also check if URL looks like an image even without proper type
      if (!type && /\.(jpg|jpeg|png|gif|webp|avif)(\?|$)/i.test(url)) {
        return url;
      }
    }

    // 5. Try image element with url attribute (some RSS 2.0 feeds)
    const imageEl = findElement(item, 'image');
    if (imageEl) {
      const urlEl = findElement(imageEl, 'url');
      if (urlEl && urlEl.textContent && isValidImageUrl(urlEl.textContent.trim())) {
        return urlEl.textContent.trim();
      }
    }

    // 6. Try to extract from description/content HTML - find best image
    const desc = getNodeText(item, 'description') || getNodeText(item, 'content:encoded') || getNodeText(item, 'content') || getNodeText(item, 'summary');
    if (desc) {
      // Find all img tags
      const imgRegex = /<img[^>]+>/gi;
      const imgTags = desc.match(imgRegex) || [];

      let bestImg = null;
      let bestScore = -Infinity;

      for (const imgTag of imgTags) {
        // Extract src
        const srcMatch = imgTag.match(/src=["']([^"']+)["']/i);
        if (!srcMatch) continue;
        let src = srcMatch[1];

        // Check srcset for better quality
        const srcsetMatch = imgTag.match(/srcset=["']([^"']+)["']/i);
        if (srcsetMatch) {
          const betterSrc = getBestFromSrcset(srcsetMatch[1]);
          if (betterSrc) src = betterSrc;
        }

        if (!isValidImageUrl(src)) continue;

        const score = extractImageScore(imgTag, src);
        if (score > bestScore) {
          bestScore = score;
          bestImg = src;
        }
      }

      if (bestImg && bestScore > -500) return bestImg;

      // Fallback: try figure > img pattern
      const figureMatch = desc.match(/<figure[^>]*>.*?<img[^>]+src=["']([^"']+)["'][^>]*>.*?<\/figure>/is);
      if (figureMatch && isValidImageUrl(figureMatch[1]) && !isLikelyTrackingOrIcon(figureMatch[1])) {
        return figureMatch[1];
      }
    }

    return '';
  };

  const parseNewsFeed = (xml, feedId, feedUrl) => {
    const parser = new DOMParser();
    const doc = parser.parseFromString(xml, 'text/xml');

    const parserError = doc.querySelector('parsererror');
    if (parserError) {
      throw new Error('Invalid RSS feed XML');
    }

    const items = doc.querySelectorAll('item, entry');
    const articles = [];

    items.forEach((item, index) => {
      const title = getNodeText(item, 'title');
      if (!title) return;

      const pubDate = parseRSSDate(
        getNodeText(item, 'pubDate') ||
        getNodeText(item, 'published') ||
        getNodeText(item, 'updated') ||
        getNodeText(item, 'dc:date')
      );

      // Get description and clean HTML
      let summary = getNodeText(item, 'description') || getNodeText(item, 'summary') || getNodeText(item, 'content:encoded') || '';
      // Strip HTML tags for summary
      const tmp = document.createElement('div');
      tmp.innerHTML = summary;
      summary = tmp.textContent?.trim().slice(0, 300) || '';

      const link = getNodeText(item, 'link') || getNodeAttr(item, 'link', 'href');
      const image = extractImage(item);

      // Create stable GUID using feed URL and article link/title
      // This ensures the same article always has the same ID even after feed deletion/re-add
      const uniqueId = GUID.forArticle(feedUrl, link, title, pubDate.toISOString());

      articles.push({
        id: uniqueId,
        feedId,
        title,
        summary,
        link,
        time: formatTimeAgo(pubDate),
        pubDate: pubDate.toISOString(),
        image,
        unread: true
      });
    });

    return articles;
  };

  const parsePodcastFeed = (xml, feedId, feedUrl) => {
    const parser = new DOMParser();
    const doc = parser.parseFromString(xml, 'text/xml');

    const parserError = doc.querySelector('parsererror');
    if (parserError) {
      console.error('XML parse error:', parserError.textContent);
      throw new Error('Invalid podcast feed XML');
    }

    // Get channel element for fallback image
    const channel = doc.querySelector('channel') || doc.querySelector('feed');
    let channelImage = '';
    if (channel) {
      channelImage = getItunesImage(channel);
      if (!channelImage) {
        // Try standard RSS image/url
        const imageEl = channel.querySelector('image');
        if (imageEl) {
          const urlEl = imageEl.querySelector('url');
          if (urlEl) channelImage = urlEl.textContent?.trim() || '';
        }
      }
    }

    // Find all items - use getElementsByTagName for better compatibility
    const items = Array.from(doc.getElementsByTagName('item'));
    if (items.length === 0) {
      // Try Atom entry format
      items.push(...Array.from(doc.getElementsByTagName('entry')));
    }

    console.log('Parsing podcast feed, found', items.length, 'items');
    const episodes = [];

    items.forEach((item, index) => {
      const title = getNodeText(item, 'title');
      if (!title) return;

      // Get audio enclosure - try multiple methods
      let audioUrl = '';
      const enclosures = item.getElementsByTagName('enclosure');
      for (let i = 0; i < enclosures.length; i++) {
        const enc = enclosures[i];
        const type = enc.getAttribute('type') || '';
        const url = enc.getAttribute('url') || '';
        if (url && (type.includes('audio') || type.includes('video') || !type)) {
          audioUrl = url;
          break;
        }
      }

      // Fallback to link with enclosure rel for Atom
      if (!audioUrl) {
        const links = item.getElementsByTagName('link');
        for (let i = 0; i < links.length; i++) {
          const link = links[i];
          if (link.getAttribute('rel') === 'enclosure') {
            audioUrl = link.getAttribute('href') || '';
            break;
          }
        }
      }

      const pubDate = parseRSSDate(
        getNodeText(item, 'pubDate') ||
        getNodeText(item, 'published') ||
        getNodeText(item, 'updated')
      );

      // Get duration from itunes:duration - try multiple approaches
      let durationStr = '';
      const durationEls = item.getElementsByTagName('itunes:duration');
      if (durationEls.length > 0) {
        durationStr = durationEls[0].textContent?.trim() || '';
      }
      if (!durationStr) {
        const durEls = item.getElementsByTagName('duration');
        if (durEls.length > 0) {
          durationStr = durEls[0].textContent?.trim() || '';
        }
      }
      const duration = parseDuration(durationStr);

      // Get description - try multiple fields
      let desc = '';
      const descFields = ['itunes:summary', 'itunes:subtitle', 'description', 'summary', 'content:encoded'];
      for (const field of descFields) {
        const els = item.getElementsByTagName(field);
        if (els.length > 0 && els[0].textContent?.trim()) {
          desc = els[0].textContent.trim();
          break;
        }
      }
      // Strip HTML
      const tmp = document.createElement('div');
      tmp.innerHTML = desc;
      desc = tmp.textContent?.trim().slice(0, 300) || '';

      // Get episode image - try multiple approaches
      let image = getItunesImage(item);
      if (!image) {
        image = extractImage(item);
      }
      // Fallback to channel image
      if (!image) {
        image = channelImage;
      }

      // Create stable GUID using feed URL and audio URL/title
      // This ensures the same episode always has the same ID even after feed deletion/re-add
      const uniqueId = GUID.forEpisode(feedUrl, audioUrl, title, pubDate.toISOString());

      episodes.push({
        id: uniqueId,
        feedId,
        title,
        desc,
        duration: duration || 1800, // Default 30 min if no duration
        date: formatTimeAgo(pubDate),
        pubDate: pubDate.toISOString(),
        image,
        audioUrl,
        downloaded: false
      });
    });

    console.log('Parsed', episodes.length, 'episodes');
    return episodes;
  };

  const extractFeedMeta = xml => {
    const parser = new DOMParser();
    const doc = parser.parseFromString(xml, 'text/xml');

    const channel = doc.querySelector('channel') || doc.querySelector('feed');
    if (!channel) return {};

    // Get image - try multiple methods
    let image = getItunesImage(channel);

    if (!image) {
      // Try standard RSS image element with url child
      const imageEl = channel.querySelector('image');
      if (imageEl) {
        const urlEl = imageEl.querySelector('url');
        if (urlEl) {
          image = urlEl.textContent?.trim() || '';
        }
        if (!image) {
          image = imageEl.getAttribute('href') || '';
        }
      }
    }

    if (!image) {
      // Try Atom logo
      const logoEl = channel.querySelector('logo');
      if (logoEl) {
        image = logoEl.textContent?.trim() || logoEl.getAttribute('src') || '';
      }
    }

    // Get author - try multiple approaches
    let author = '';
    const authorFields = ['itunes:author', 'author', 'managingEditor', 'dc:creator'];
    for (const field of authorFields) {
      const els = channel.getElementsByTagName(field);
      if (els.length > 0 && els[0].textContent?.trim()) {
        author = els[0].textContent.trim();
        break;
      }
    }

    // Get itunes category for podcasts
    let itunesCategory = '';
    const categoryEls = channel.getElementsByTagName('itunes:category');
    if (categoryEls.length > 0) {
      itunesCategory = categoryEls[0].getAttribute('text') || '';
    }

    return {
      title: getNodeText(channel, 'title'),
      description: getNodeText(channel, 'description') || getNodeText(channel, 'subtitle'),
      author,
      image,
      itunesCategory
    };
  };

  // Normalize feed URL - convert podcast://, feed://, etc. to https://
  const normalizeFeedUrl = (url) => {
    // Replace common podcast URL schemes with https
    const schemes = ['podcast://', 'pcast://', 'feed://', 'podcasts://'];
    for (const scheme of schemes) {
      if (url.toLowerCase().startsWith(scheme)) {
        return 'https://' + url.slice(scheme.length);
      }
    }
    // Handle http:// -> https:// upgrade
    if (url.toLowerCase().startsWith('http://')) {
      return 'https://' + url.slice(7);
    }
    return url;
  };

  // Fetch feed metadata without adding it - for preview/auto-detect
  const fetchFeedMetadata = async (url) => {
    try {
      const normalizedUrl = normalizeFeedUrl(url);
      const xml = await fetchWithProxy(normalizedUrl);
      const meta = extractFeedMeta(xml);

      // Also try to detect feed type based on content
      const parser = new DOMParser();
      const doc = parser.parseFromString(xml, 'text/xml');
      const hasEnclosure = doc.querySelector('enclosure[type^="audio"], enclosure[type^="video"]');
      const hasItunesNs = xml.includes('xmlns:itunes') || xml.includes('itunes:');
      const suggestedType = (hasEnclosure || hasItunesNs) ? 'podcast' : 'news';

      return {
        success: true,
        title: meta.title || '',
        author: meta.author || '',
        description: meta.description || '',
        image: meta.image || '',
        suggestedType
      };
    } catch (e) {
      console.error('Failed to fetch feed metadata:', e);
      return {
        success: false,
        error: e.message
      };
    }
  };

  const fetchAndParseFeed = async feed => {
    try {
      const normalizedUrl = normalizeFeedUrl(feed.url);
      const xml = await fetchWithProxy(normalizedUrl);
      const meta = extractFeedMeta(xml);

      // Update feed metadata if available (only if user hasn't provided values)
      if (meta.title && (!feed.name || feed.name === 'Loading...')) feed.name = meta.title;
      if (meta.image && !feed.image) feed.image = meta.image;
      if (meta.author && !feed.author) feed.author = meta.author;
      if (meta.description) feed.description = meta.description;

      // Auto-detect tags for the feed if not already set
      const feedContentSample = meta.description || meta.itunesCategory || '';
      if (!feed.tags || feed.tags.length === 0) {
        feed.tags = autoDetectFeedTags(feed, feedContentSample);
        console.log(`Auto-detected tags for ${feed.name}:`, feed.tags.map(t => getTagInfo(t).label));
      }

      if (feed.type === 'news') {
        const articles = parseNewsFeed(xml, feed.id, feed.url);

        // Auto-tag each article
        articles.forEach(article => {
          article.tags = autoDetectItemTags(article, feed.tags);
        });

        // Get all existing articles for this feed (including archived)
        const existingArticles = state.articles.filter(a => a.feedId === feed.id);
        const archivedForFeed = state.archivedArticles.filter(a => a.feedId === feed.id);

        // Create sets of existing titles (both active and archived)
        const existingTitles = new Set(existingArticles.map(a => a.title));
        const archivedTitles = new Set(archivedForFeed.map(a => a.title));

        // Find truly new articles (not in current or archived)
        const newArticles = articles.filter(a => !existingTitles.has(a.title) && !archivedTitles.has(a.title));

        // Find articles that are in current list but NOT in new feed (they're being archived)
        const currentTitlesInFeed = new Set(articles.map(a => a.title));
        const toArchive = existingArticles.filter(a => !currentTitlesInFeed.has(a.title));

        // Archive items that fell off the feed (preserve history)
        if (toArchive.length > 0) {
          toArchive.forEach(a => a.archived = true);
          state.archivedArticles = [...state.archivedArticles, ...toArchive];
          // Limit archived items per feed to prevent unbounded growth (keep last 500)
          const feedArchived = state.archivedArticles.filter(a => a.feedId === feed.id);
          if (feedArchived.length > 500) {
            const toRemove = feedArchived.slice(0, feedArchived.length - 500).map(a => a.id);
            state.archivedArticles = state.archivedArticles.filter(a => !toRemove.includes(a.id));
          }
        }

        // Update articles: new + existing that are still in feed
        const updatedArticles = articles.map(feedArticle => {
          // Check if we have an existing version with user state (read status, etc.)
          const existing = existingArticles.find(a => a.title === feedArticle.title);
          if (existing) {
            // Preserve user state but update content
            return { ...feedArticle, unread: existing.unread, tags: existing.tags?.length ? existing.tags : feedArticle.tags };
          }
          return feedArticle;
        });

        state.articles = [
          ...state.articles.filter(a => a.feedId !== feed.id),
          ...updatedArticles
        ];

        // Sort by date
        state.articles.sort((a, b) => new Date(b.pubDate || 0) - new Date(a.pubDate || 0));
        // Update unread count
        feed.unread = state.articles.filter(a => a.feedId === feed.id && a.unread).length;

      } else {
        const episodes = parsePodcastFeed(xml, feed.id, feed.url);

        // Auto-tag each episode
        episodes.forEach(episode => {
          episode.tags = autoDetectItemTags(episode, feed.tags);
        });

        // Get all existing episodes for this feed (including archived)
        const existingEpisodes = state.podcasts.filter(p => p.feedId === feed.id);
        const archivedForFeed = state.archivedPodcasts.filter(p => p.feedId === feed.id);

        // Create sets of existing titles
        const existingTitles = new Set(existingEpisodes.map(p => p.title));
        const archivedTitles = new Set(archivedForFeed.map(p => p.title));

        // Find truly new episodes
        const newEpisodes = episodes.filter(e => !existingTitles.has(e.title) && !archivedTitles.has(e.title));

        // Find episodes to archive
        const currentTitlesInFeed = new Set(episodes.map(e => e.title));
        const toArchive = existingEpisodes.filter(p => !currentTitlesInFeed.has(p.title));

        // Archive episodes that fell off the feed
        if (toArchive.length > 0) {
          toArchive.forEach(p => p.archived = true);
          state.archivedPodcasts = [...state.archivedPodcasts, ...toArchive];
          // Limit archived per feed
          const feedArchived = state.archivedPodcasts.filter(p => p.feedId === feed.id);
          if (feedArchived.length > 500) {
            const toRemove = feedArchived.slice(0, feedArchived.length - 500).map(p => p.id);
            state.archivedPodcasts = state.archivedPodcasts.filter(p => !toRemove.includes(p.id));
          }
        }

        // Update episodes: preserve user state (progress, downloaded, etc.)
        const updatedEpisodes = episodes.map(feedEp => {
          const existing = existingEpisodes.find(p => p.title === feedEp.title);
          if (existing) {
            return {
              ...feedEp,
              downloaded: existing.downloaded,
              tags: existing.tags?.length ? existing.tags : feedEp.tags
            };
          }
          return feedEp;
        });

        state.podcasts = [
          ...state.podcasts.filter(p => p.feedId !== feed.id),
          ...updatedEpisodes
        ];

        // Sort by date
        state.podcasts.sort((a, b) => new Date(b.pubDate || 0) - new Date(a.pubDate || 0));
      }

      feed.lastFetched = new Date().toISOString();
      feed.error = null;
      return true;
    } catch (e) {
      console.error(`Failed to fetch feed ${feed.name}:`, e);
      feed.error = e.message;
      return false;
    }
  };

  const refreshAllFeeds = async (silent = false) => {
    if (state.refreshing) return;
    state.refreshing = true;

    // Add spinning animation to refresh button
    const refreshBtn = $('refreshBtn');
    if (refreshBtn) {
      refreshBtn.style.animation = 'spin 1s linear infinite';
      refreshBtn.disabled = true;
    }

    if (!silent) toast('Refreshing feeds...');

    // Create snapshot before refresh (content may change)
    try {
      await SnapshotDB.createSnapshot('before_refresh');
    } catch (e) {
      console.warn('Failed to create pre-refresh snapshot:', e);
    }

    const results = await Promise.allSettled(
      state.feeds.map(feed => fetchAndParseFeed(feed))
    );

    const success = results.filter(r => r.status === 'fulfilled' && r.value).length;
    const failed = results.length - success;

    state.refreshing = false;

    // Stop spinning animation
    if (refreshBtn) {
      refreshBtn.style.animation = '';
      refreshBtn.disabled = false;
    }

    save();
    renderNewsSources();
    renderCategories();
    renderTagFilters();
    renderNews();
    if (state.view === 'podcasts') renderPodcasts();
    if (state.view === 'all') renderAll();

    if (failed > 0) {
      toast(`Refreshed ${success} feeds, ${failed} failed`);
    } else if (success > 0 && !silent) {
      toast(`Refreshed ${success} feeds`);
    }
  };

  const addFeed = async (url, name, type, category, author) => {
    const id = GUID.forFeed(url);
    const feed = {
      id,
      url,
      name: name || 'Loading...',
      type,
      category: category || 'Uncategorized',
      image: '',
      author: author || '',
      unread: 0,
      tags: [], // Will be auto-detected during fetch
      description: ''
    };

    state.feeds.push(feed);
    state.categories.add(feed.category);

    // Track subscription for user behavior API
    state.userBehavior.subscriptions.push({
      feedId: id,
      timestamp: new Date().toISOString(),
      action: 'add',
      feedType: type
    });

    save();

    toast('Adding feed...');
    const success = await fetchAndParseFeed(feed);

    if (success) {
      // Log tags that were auto-detected
      if (feed.tags.length > 0) {
        const tagLabels = feed.tags.map(t => getTagInfo(t).label).join(', ');
        console.log(`Feed ${feed.name} auto-tagged: ${tagLabels}`);
      }
      save();
      renderNewsSources();
      renderCategories();
      renderNews();
      renderTagFilters();
      if (state.view === 'podcasts') renderPodcasts();
      toast(`Added: ${feed.name}`);
    } else {
      // Keep the feed but show error
      toast(`Added ${feed.name} (fetch failed)`);
    }

    return success;
  };
  
  // === RENDER NEWS ===
  const renderNewsSources = () => {
    const news = state.feeds.filter(f => f.type === 'news');
    el.newsSources.innerHTML = `<div class="source-item ${!state.selectedSource && !state.currentSourcePage ? 'active' : ''}" data-id="all"><div class="source-icon"><i class="ph ph-books"></i></div><div class="source-name">All Sources</div></div>` +
      news.map(f => {
        const hasNew = feedHasNewContent(f.id);
        const newCount = getNewItemCount(f.id);
        const newestDate = getNewestContentDate(f.id);
        const updatedText = hasNew && newestDate ? formatUpdatedAgo(newestDate) : '';
        const subtitle = hasNew ? (newCount > 0 ? `${newCount} new` : updatedText) : '';

        return `<div class="source-item ${state.currentSourcePage === f.id ? 'active' : ''} ${hasNew ? 'has-new' : ''}" data-id="${f.id}">
          ${hasNew ? '<span class="new-indicator"></span>' : ''}
          <div class="source-icon">${f.image ? `<img src="${f.image}">` : '<i class="ph ph-newspaper"></i>'}</div>
          <div class="source-info">
            <div class="source-name">${f.name}</div>
            ${subtitle ? `<div class="source-subtitle">${subtitle}</div>` : ''}
          </div>
          <span class="source-arrow"></span>
        </div>`;
      }).join('');
  };
  
  const renderCategories = () => {
    const cats = ['All', ...Array.from(state.categories).filter(c => c !== 'All')];
    el.categoryChips.innerHTML = cats.map(c => `<button class="chip ${state.selectedCat === c ? 'active' : ''}" data-cat="${c}">${c}</button>`).join('');
  };

  // Render tag filter chips based on what tags exist in current content
  const renderTagFilters = () => {
    // Collect all tags from articles and count occurrences
    const tagCounts = {};
    state.articles.forEach(a => {
      if (a.tags) {
        a.tags.forEach(tag => {
          tagCounts[tag] = (tagCounts[tag] || 0) + 1;
        });
      }
    });

    // Also include tags from feeds
    state.feeds.filter(f => f.type === 'news').forEach(f => {
      if (f.tags) {
        f.tags.forEach(tag => {
          if (!tagCounts[tag]) tagCounts[tag] = 0;
        });
      }
    });

    // Sort tags by count descending
    const sortedTags = Object.entries(tagCounts)
      .filter(([_, count]) => count > 0)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 12); // Limit to top 12 tags

    if (sortedTags.length === 0) {
      el.tagFilterSection.style.display = 'none';
      return;
    }

    el.tagFilterSection.style.display = 'block';
    el.tagChips.innerHTML = `
      <button class="tag-chip ${state.selectedTag === 'all' ? 'active' : ''}" data-tag="all">
        <span class="tag-icon"><i class="ph ph-tag"></i></span>All
      </button>
      ${sortedTags.map(([tag, count]) => {
        const info = getTagInfo(tag);
        return `<button class="tag-chip ${state.selectedTag === tag ? 'active' : ''}" data-tag="${tag}">
          <span class="tag-icon">${info.icon}</span>${info.label}<span class="tag-count">${count}</span>
        </button>`;
      }).join('')}
    `;
  };

  // Helper to render item tags as badges
  const renderItemTags = (tags) => {
    if (!tags || tags.length === 0) return '';
    return `<div class="item-tags">${tags.slice(0, 2).map(tag => {
      const info = getTagInfo(tag);
      return `<span class="item-tag"><span class="item-tag-icon">${info.icon}</span>${info.label}</span>`;
    }).join('')}</div>`;
  };
  
  const renderNews = () => {
    let items = state.articles.map(a => ({ ...a, feed: state.feeds.find(f => f.id === a.feedId) }));
    if (state.selectedSource) items = items.filter(i => i.feedId === state.selectedSource);
    if (state.selectedCat !== 'All') items = fuzzy(state.selectedCat, items, ['feed.category']);
    // Apply tag filter
    if (state.selectedTag && state.selectedTag !== 'all') {
      items = filterByTag(items, state.selectedTag);
    }
    if (state.query) items = fuzzy(state.query, items, ['title', 'summary', 'feed.name']);

    if (!items.length) {
      const hasFeeds = state.feeds.filter(f => f.type === 'news').length > 0;
      const hasTagFilter = state.selectedTag && state.selectedTag !== 'all';
      el.newsList.innerHTML = hasFeeds
        ? `<div class="empty"><div class="empty-icon"><i class="ph ph-tray"></i></div><div class="empty-title">No articles found</div><div style="color:var(--text3);margin-top:8px">${hasTagFilter ? 'Try selecting a different topic' : 'Try refreshing your feeds'}</div></div>`
        : '<div class="empty"><div class="empty-icon"><i class="ph ph-broadcast"></i></div><div class="empty-title">No news feeds yet</div><div style="color:var(--text3);margin-top:8px">Click + to add your first RSS feed</div></div>';
      return;
    }

    el.newsList.innerHTML = items.map(i => `<div class="article ${i.unread ? 'unread' : ''}" data-id="${i.id}"><div class="article-icon">${i.feed?.image ? `<img src="${i.feed.image}">` : '<i class="ph ph-article"></i>'}</div><div class="article-body"><div class="article-meta"><span class="article-source">${i.feed?.name || ''}</span><span class="article-time"> ${i.time}</span>${i.unread ? '<span class="article-new">NEW</span>' : ''}</div><div class="article-title">${i.title}</div>${i.summary ? `<div class="article-summary">${i.summary}</div>` : ''}${renderItemTags(i.tags)}</div>${i.image ? `<img class="article-image" src="${i.image}">` : ''}</div>`).join('');
  };
  
// === RENDER PODCASTS (Inbox Style) ===
  // Placeholder SVG for broken images
  const placeholderImg = 'data:image/svg+xml,' + encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><rect fill="#1a1a1a" width="100" height="100"/><path d="M50 20c-5.5 0-10 4.5-10 10v20c0 5.5 4.5 10 10 10s10-4.5 10-10V30c0-5.5-4.5-10-10-10zm20 30c0 11-9 20-20 20s-20-9-20-20h-5c0 13.3 10.1 24.2 23 25.7V85h4V75.7c12.9-1.5 23-12.4 23-25.7h-5z" fill="#666" transform="translate(0,5)"/></svg>');

  const renderPodcastSources = () => {
    const podcasts = state.feeds.filter(f => f.type === 'podcast');
    el.podcastSources.innerHTML = `<div class="source-item ${!state.selectedPodcastSource && !state.currentShowPage ? 'active' : ''}" data-id="all"><div class="source-icon"><i class="ph ph-headphones"></i></div><div class="source-name">All Episodes</div></div>` +
      podcasts.map(f => {
        const hasNew = feedHasNewContent(f.id);
        const newCount = getNewItemCount(f.id);
        const newestDate = getNewestContentDate(f.id);
        const updatedText = hasNew && newestDate ? formatUpdatedAgo(newestDate) : '';
        const subtitle = hasNew ? (newCount > 0 ? `${newCount} new` : updatedText) : '';

        return `<div class="source-item ${state.currentShowPage === f.id ? 'active' : ''} ${hasNew ? 'has-new' : ''}" data-id="${f.id}">
          ${hasNew ? '<span class="new-indicator"></span>' : ''}
          <div class="source-icon">${f.image ? `<img src="${f.image}">` : '<i class="ph ph-microphone-stage"></i>'}</div>
          <div class="source-info">
            <div class="source-name">${f.name}</div>
            ${subtitle ? `<div class="source-subtitle">${subtitle}</div>` : ''}
          </div>
          <span class="source-arrow"></span>
        </div>`;
      }).join('');
  };

  const renderPodcastCategories = () => {
    // Collect categories from podcast feeds
    const podcastFeeds = state.feeds.filter(f => f.type === 'podcast');
    const cats = ['All', ...new Set(podcastFeeds.map(f => f.category).filter(c => c && c !== 'All'))];
    el.podcastCategoryChips.innerHTML = cats.map(c => `<button class="chip ${state.selectedPodcastCat === c ? 'active' : ''}" data-cat="${c}">${c}</button>`).join('');
  };

  const renderPodcastTagFilters = () => {
    // Collect all tags from podcast episodes and feeds
    const tagCounts = {};
    state.podcasts.forEach(p => {
      if (p.tags) {
        p.tags.forEach(tag => {
          tagCounts[tag] = (tagCounts[tag] || 0) + 1;
        });
      }
    });

    // Also include tags from podcast feeds
    state.feeds.filter(f => f.type === 'podcast').forEach(f => {
      if (f.tags) {
        f.tags.forEach(tag => {
          if (!tagCounts[tag]) tagCounts[tag] = 0;
        });
      }
    });

    // Sort tags by count descending
    const sortedTags = Object.entries(tagCounts)
      .filter(([_, count]) => count > 0)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 12);

    if (sortedTags.length === 0) {
      el.podcastTagFilterSection.style.display = 'none';
      return;
    }

    el.podcastTagFilterSection.style.display = 'block';
    el.podcastTagChips.innerHTML = `
      <button class="tag-chip ${state.selectedPodcastTag === 'all' ? 'active' : ''}" data-tag="all">
        <span class="tag-icon"><i class="ph ph-tag"></i></span>All
      </button>
      ${sortedTags.map(([tag, count]) => {
        const info = getTagInfo(tag);
        return `<button class="tag-chip ${state.selectedPodcastTag === tag ? 'active' : ''}" data-tag="${tag}">
          <span class="tag-icon">${info.icon}</span>${info.label}<span class="tag-count">${count}</span>
        </button>`;
      }).join('')}
    `;
  };

  const renderPodcastEpisodeItem = (ep) => {
    const show = state.feeds.find(f => f.id === ep.feedId);
    const pr = state.progress[ep.id] || 0;
    const pct = ep.duration ? (pr / ep.duration) * 100 : 0;
    const done = pr >= ep.duration * 0.95;
    const inProgress = pr > 0 && !done;
    const imgSrc = ep.image || show?.image || placeholderImg;

    return `<div class="podcast-episode-item ${inProgress ? 'in-progress' : ''}" data-ep="${ep.id}">
      <div class="podcast-episode-icon"><img src="${imgSrc}" onerror="this.parentElement.innerHTML='<i class=\\'ph ph-microphone-stage\\'></i>'"></div>
      <div class="podcast-episode-body">
        <div class="podcast-episode-meta">
          <span class="podcast-episode-show" data-show="${ep.feedId}">${show?.name || ''}</span>
          <span class="podcast-episode-time"> ${ep.date}</span>
          ${inProgress ? '<span class="podcast-episode-new">IN PROGRESS</span>' : ''}
        </div>
        <div class="podcast-episode-title">${ep.title}</div>
        ${ep.desc ? `<div class="podcast-episode-desc">${ep.desc}</div>` : ''}
        <div class="podcast-episode-footer">
          <button class="podcast-episode-play" data-ep="${ep.id}">
            <svg width="12" height="12" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
          </button>
          <span class="podcast-episode-duration"><i class="ph ph-clock"></i> ${done ? 'Played' : pr > 0 ? fmt(ep.duration - pr) + ' left' : fmt(ep.duration)}</span>
          ${pr > 0 && !done ? `<div class="podcast-episode-progress"><div class="podcast-episode-progress-fill" style="width:${pct}%"></div></div>` : ''}
          ${renderItemTags(ep.tags)}
        </div>
      </div>
      ${ep.image ? `<img class="podcast-episode-image" src="${ep.image}" onerror="this.style.display='none'">` : ''}
    </div>`;
  };

  const renderPodcastInbox = () => {
    let items = state.podcasts.map(p => ({ ...p, feed: state.feeds.find(f => f.id === p.feedId) }));

    // Apply source filter
    if (state.selectedPodcastSource) {
      items = items.filter(i => i.feedId === state.selectedPodcastSource);
    }

    // Apply category filter
    if (state.selectedPodcastCat !== 'All') {
      items = fuzzy(state.selectedPodcastCat, items, ['feed.category']);
    }

    // Apply tag filter
    if (state.selectedPodcastTag && state.selectedPodcastTag !== 'all') {
      items = filterByTag(items, state.selectedPodcastTag);
    }

    // Apply search query
    if (state.query) {
      items = fuzzy(state.query, items, ['title', 'desc', 'feed.name']);
    }

    if (!items.length) {
      const hasFeeds = state.feeds.filter(f => f.type === 'podcast').length > 0;
      const hasTagFilter = state.selectedPodcastTag && state.selectedPodcastTag !== 'all';
      el.podcastInboxList.innerHTML = hasFeeds
        ? `<div class="empty"><div class="empty-icon"><i class="ph ph-tray"></i></div><div class="empty-title">No episodes found</div><div style="color:var(--text3);margin-top:8px">${hasTagFilter ? 'Try selecting a different topic' : 'Try refreshing your feeds'}</div></div>`
        : '<div class="empty"><div class="empty-icon"><i class="ph ph-microphone-stage"></i></div><div class="empty-title">No podcasts yet</div><div style="color:var(--text3);margin-top:8px">Click + to add your first podcast</div></div>';
      return;
    }

    el.podcastInboxList.innerHTML = items.map(renderPodcastEpisodeItem).join('');
  };

  const renderPodcasts = () => {
    el.showPage.classList.remove('active');
    el.podcastInboxContent.style.display = 'flex';

    renderPodcastSources();
    renderPodcastCategories();
    renderPodcastTagFilters();
    renderPodcastInbox();
  };

  const renderEpisode = ep => {
    const show = state.feeds.find(f => f.id === ep.feedId);
    const pr = state.progress[ep.id] || 0;
    const pct = ep.duration ? (pr / ep.duration) * 100 : 0;
    const rem = ep.duration - pr;
    const done = pr >= ep.duration * 0.95;
    const imgSrc = ep.image || show?.image || placeholderImg;

    // Download status
    const dlStatus = downloadProgress[ep.id];
    const isDownloading = dlStatus?.status === 'downloading';
    const dlPct = dlStatus?.progress || 0;

    // Download button content
    let dlBtnContent;
    if (isDownloading) {
      dlBtnContent = `<span style="font-size:10px;font-weight:600">${dlPct}%</span>`;
    } else if (ep.downloaded) {
      dlBtnContent = `<svg width="16" height="16" fill="currentColor" stroke="none" viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>`;
    } else {
      dlBtnContent = `<svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M7 10l5 5 5-5M12 15V3"/></svg>`;
    }

    return `<div class="episode" data-ep="${ep.id}"><img class="episode-art" src="${imgSrc}" onerror="this.src='${placeholderImg}'"><div class="episode-body"><div class="episode-show">${show?.name || ''}</div><div class="episode-title">${ep.title}</div><div class="episode-footer"><button class="ep-play" data-ep="${ep.id}"><svg width="10" height="10" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg></button><div class="ep-progress"><div class="ep-bar"><div class="ep-fill" style="width:${pct}%"></div></div><span class="ep-time">${done ? 'Played' : pr > 0 ? fmt(rem) + ' left' : fmt(ep.duration)}</span></div><button class="ep-dl ${ep.downloaded ? 'active' : ''} ${isDownloading ? 'downloading' : ''}" data-dl="${ep.id}" ${isDownloading ? 'disabled' : ''}>${dlBtnContent}</button></div></div></div>`;
  };
  
  // View options HTML generator
  const renderViewOptions = (sourceId, currentView, views = ['list', 'table', 'cards', 'masonry']) => {
    const icons = {
      list: '<svg width="14" height="14" fill="currentColor" viewBox="0 0 24 24"><path d="M3 13h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2V7H3v2zm4 4h14v-2H7v2zm0 4h14v-2H7v2zM7 7v2h14V7H7z"/></svg>',
      table: '<svg width="14" height="14" fill="currentColor" viewBox="0 0 24 24"><path d="M3 3v18h18V3H3zm8 16H5v-6h6v6zm0-8H5V5h6v6zm8 8h-6v-6h6v6zm0-8h-6V5h6v6z"/></svg>',
      cards: '<svg width="14" height="14" fill="currentColor" viewBox="0 0 24 24"><path d="M4 11h5V5H4v6zm0 7h5v-6H4v6zm6 0h5v-6h-5v6zm6 0h5v-6h-5v6zm-6-7h5V5h-5v6zm6-6v6h5V5h-5z"/></svg>',
      masonry: '<svg width="14" height="14" fill="currentColor" viewBox="0 0 24 24"><path d="M3 3v8h8V3H3zm6 6H5V5h4v4zm-6 4v8h8v-8H3zm6 6H5v-4h4v4zm4-16v12h8V3h-8zm6 10h-4V5h4v8zm-6 2v8h8v-8h-8zm6 6h-4v-4h4v4z"/></svg>'
    };
    const labels = { list: 'List', table: 'Table', cards: 'Cards', masonry: 'Masonry' };
    return `<div class="view-options" data-source="${sourceId}">${views.map(v =>
      `<button class="view-btn ${currentView === v ? 'active' : ''}" data-view="${v}" title="${labels[v]}">${icons[v]}</button>`
    ).join('')}</div>`;
  };

  // Render article in different view modes
  const renderArticleCard = (article, feed) => `
    <div class="article-card ${article.unread ? 'unread' : ''}" data-id="${article.id}">
      ${article.image ? `<img class="article-card-image" src="${article.image}" onerror="this.style.display='none'">` : '<div class="article-card-image" style="background:var(--bg3);display:flex;align-items:center;justify-content:center;font-size:32px"><i class="ph ph-article"></i></div>'}
      <div class="article-card-body">
        <div class="article-card-meta">
          <span class="article-card-source">${feed?.name || ''}</span>
          <span class="article-card-time"> ${article.time}</span>
        </div>
        <div class="article-card-title">${article.title}</div>
        ${article.summary ? `<div class="article-card-summary">${article.summary}</div>` : ''}
      </div>
    </div>`;

  const renderArticleMasonry = (article, feed) => `
    <div class="article-masonry ${article.unread ? 'unread' : ''}" data-id="${article.id}">
      ${article.image ? `<img class="article-masonry-image" src="${article.image}" onerror="this.style.display='none'">` : ''}
      <div class="article-masonry-body">
        <div class="article-masonry-meta">
          <span class="article-masonry-source">${feed?.name || ''}</span>
          <span class="article-masonry-time"> ${article.time}</span>
        </div>
        <div class="article-masonry-title">${article.title}</div>
        ${article.summary ? `<div class="article-masonry-summary">${article.summary}</div>` : ''}
      </div>
    </div>`;

  const renderArticleTable = (article, feed) => `
    <tr class="${article.unread ? 'unread' : ''}" data-id="${article.id}">
      <td class="table-title">${article.title}</td>
      <td class="table-source">${feed?.name || ''}</td>
      <td class="table-time">${article.time}</td>
      <td class="table-new">${article.unread ? 'NEW' : ''}</td>
    </tr>`;

  // Render episodes in different view modes
  const renderEpisodeCard = ep => {
    const show = state.feeds.find(f => f.id === ep.feedId);
    const imgSrc = ep.image || show?.image || placeholderImg;
    const pr = state.progress[ep.id] || 0;
    return `<div class="episode-card" data-ep="${ep.id}">
      <img class="episode-card-art" src="${imgSrc}" onerror="this.src='${placeholderImg}'">
      <div class="episode-card-body">
        <div class="episode-card-title">${ep.title}</div>
        <div class="episode-card-meta">
          <span>${fmt(ep.duration)}</span>
          ${pr > 0 ? `<span> ${Math.round((pr / ep.duration) * 100)}% played</span>` : ''}
        </div>
      </div>
    </div>`;
  };

  const renderEpisodeMasonry = ep => {
    const show = state.feeds.find(f => f.id === ep.feedId);
    const imgSrc = ep.image || show?.image || placeholderImg;
    return `<div class="episode-masonry" data-ep="${ep.id}">
      <img class="episode-masonry-art" src="${imgSrc}" onerror="this.src='${placeholderImg}'">
      <div class="episode-masonry-body">
        <div class="episode-masonry-title">${ep.title}</div>
        ${ep.desc ? `<div class="episode-masonry-desc">${ep.desc}</div>` : ''}
        <div class="episode-masonry-meta">${fmt(ep.duration)}  ${ep.date}</div>
      </div>
    </div>`;
  };

  const renderEpisodeTable = ep => {
    const show = state.feeds.find(f => f.id === ep.feedId);
    return `<tr data-ep="${ep.id}">
      <td class="table-play"><button class="table-play-btn" data-ep="${ep.id}"><svg width="10" height="10" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg></button></td>
      <td class="table-title">${ep.title}</td>
      <td class="table-duration">${fmt(ep.duration)}</td>
      <td class="table-date">${ep.date}</td>
    </tr>`;
  };

  // Render articles content based on view mode
  const renderArticlesContent = (articles, viewMode, sourceId) => {
    if (!articles.length) return '<div class="empty"><div class="empty-icon"><i class="ph ph-tray"></i></div><div class="empty-title">No articles found</div></div>';

    switch (viewMode) {
      case 'cards':
        return `<div class="articles-cards">${articles.map(a => renderArticleCard(a, state.feeds.find(f => f.id === a.feedId))).join('')}</div>`;
      case 'masonry':
        return `<div class="articles-masonry">${articles.map(a => renderArticleMasonry(a, state.feeds.find(f => f.id === a.feedId))).join('')}</div>`;
      case 'table':
        return `<table class="articles-table"><thead><tr><th>Title</th><th>Source</th><th>Time</th><th></th></tr></thead><tbody>${articles.map(a => renderArticleTable(a, state.feeds.find(f => f.id === a.feedId))).join('')}</tbody></table>`;
      default: // list
        return `<div class="news-list-view">${articles.map(a => {
          const feed = state.feeds.find(f => f.id === a.feedId);
          return `<div class="article ${a.unread ? 'unread' : ''}" data-id="${a.id}"><div class="article-icon">${feed?.image ? `<img src="${feed.image}">` : '<i class="ph ph-article"></i>'}</div><div class="article-body"><div class="article-meta"><span class="article-source">${feed?.name || ''}</span><span class="article-time"> ${a.time}</span>${a.unread ? '<span class="article-new">NEW</span>' : ''}</div><div class="article-title">${a.title}</div>${a.summary ? `<div class="article-summary">${a.summary}</div>` : ''}</div>${a.image ? `<img class="article-image" src="${a.image}">` : ''}</div>`;
        }).join('')}</div>`;
    }
  };

  // Render episodes content based on view mode
  const renderEpisodesContent = (episodes, viewMode) => {
    if (!episodes.length) return '<div class="empty"><div class="empty-icon"><i class="ph ph-headphones"></i></div><div class="empty-title">No episodes found</div></div>';

    switch (viewMode) {
      case 'cards':
        return `<div class="episodes-cards">${episodes.map(renderEpisodeCard).join('')}</div>`;
      case 'masonry':
        return `<div class="episodes-masonry">${episodes.map(renderEpisodeMasonry).join('')}</div>`;
      case 'table':
        return `<table class="episodes-table"><thead><tr><th class="table-play"></th><th>Title</th><th>Duration</th><th>Date</th></tr></thead><tbody>${episodes.map(renderEpisodeTable).join('')}</tbody></table>`;
      default: // list
        return `<div class="episode-list">${episodes.map(renderEpisode).join('')}</div>`;
    }
  };

  // Render source page for news feeds
  const renderSourcePage = id => {
    const source = state.feeds.find(f => f.id === id);
    if (!source) return;
    Mem.log('feed_opened', id);
    state.currentSourcePage = id;
    markFeedViewed(id); // Mark feed as viewed to clear new content indicator

    const articles = state.articles.filter(a => a.feedId === id);
    const viewMode = getViewPref('news_' + id, 'list');

    el.newsContent.style.display = 'none';
    el.sourcePage.classList.add('active');
    renderNewsSources(); // Update active state in sidebar
    el.sourcePage.innerHTML = `
      <div class="source-hero">
        <button class="back-btn" id="sourceBackBtn"><svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 18l-6-6 6-6"/></svg> Back</button>
      </div>
      <div class="source-hero" style="padding-top:0">
        <img class="source-hero-art" src="${source.image || placeholderImg}" onerror="this.src='${placeholderImg}'">
        <div class="source-hero-info">
          <div class="source-hero-type">News Feed</div>
          <div class="source-hero-title">${source.name}</div>
          <div class="source-hero-author">${source.author || source.category || ''}</div>
        </div>
      </div>
      <div class="source-actions">
        <span style="font-size:14px;color:var(--text2)">${articles.length} articles</span>
        ${renderViewOptions('news_' + id, viewMode)}
      </div>
      <div class="source-articles">
        <div class="source-articles-content">${renderArticlesContent(articles, viewMode, id)}</div>
      </div>`;
  };

  const closeSourcePage = () => {
    state.currentSourcePage = null;
    el.sourcePage.classList.remove('active');
    el.newsContent.style.display = 'flex';
    renderNewsSources(); // Update active state in sidebar
  };

  const renderShowPage = id => {
    const show = state.feeds.find(f => f.id === id);
    if (!show) return;
    Mem.log('feed_opened', id);
    state.currentShowPage = id;
    markFeedViewed(id); // Mark feed as viewed to clear new content indicator

    const eps = state.podcasts.filter(p => p.feedId === id);
    const viewMode = getViewPref('podcast_' + id, 'list');

    el.podcastInboxContent.style.display = 'none';
    el.showPage.classList.add('active');
    renderPodcastSources(); // Update active state in sidebar
    el.showPage.innerHTML = `
      <div class="show-hero">
        <button class="back-btn" id="showBackBtn"><svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 18l-6-6 6-6"/></svg> Back</button>
      </div>
      <div class="show-hero" style="padding-top:0">
        <img class="show-hero-art" src="${show.image || placeholderImg}" onerror="this.src='${placeholderImg}'">
        <div class="show-hero-info">
          <div class="show-hero-type">Podcast</div>
          <div class="show-hero-title">${show.name}</div>
          <div class="show-hero-author">${show.author || ''}</div>
        </div>
      </div>
      <div class="show-actions">
        <button class="show-play" data-show="${id}"><svg width="22" height="22" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg></button>
        ${renderViewOptions('podcast_' + id, viewMode)}
      </div>
      <div class="show-episodes">
        <div class="show-episodes-title">Episodes</div>
        <div class="show-episodes-content">${renderEpisodesContent(eps, viewMode)}</div>
      </div>`;
  };

  const closeShowPage = () => {
    state.currentShowPage = null;
    el.showPage.classList.remove('active');
    el.podcastInboxContent.style.display = 'flex';
    renderPodcastSources(); // Update active state in sidebar
  };

  // === RENDER ALL - Social Media Feed Style ===

  // Render a single feed post in social media style
  const renderFeedPost = (item, type) => {
    const feed = state.feeds.find(f => f.id === item.feedId);
    const feedName = feed?.name || 'Unknown Source';
    const feedImage = feed?.image;
    const summary = type === 'podcast' ? item.desc : item.summary;
    const image = item.image || feed?.image;
    const isUnread = type === 'news' && item.unread;
    const duration = type === 'podcast' && item.duration ? fmtLong(item.duration) : '';

    // Generate avatar
    const podcastIcon = '<i class="ph ph-headphones"></i>';
    const newsIcon = '<i class="ph ph-newspaper"></i>';
    const avatar = feedImage
      ? `<img src="${feedImage}" onerror="this.parentElement.innerHTML=\`${type === 'podcast' ? podcastIcon : newsIcon}\`">`
      : (type === 'podcast' ? podcastIcon : newsIcon);

    // Generate tags HTML
    const tagsHtml = item.tags && item.tags.length > 0
      ? `<div class="feed-post-tags">${item.tags.slice(0, 3).map(tag => {
          const tagInfo = getTagInfo(tag);
          return `<span class="feed-post-tag">#${tagInfo.label.toLowerCase().replace(/\s+/g, '')}</span>`;
        }).join('')}</div>`
      : '';

    // Podcast-specific elements
    const podcastMeta = type === 'podcast' ? `
      <div class="feed-post-duration">
        <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/></svg>
        ${duration}
      </div>
      <div class="feed-post-play" data-action="play">
        <svg fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
        Play Episode
      </div>
    ` : '';

    // Action buttons for news
    const newsActions = type === 'news' ? `
      <div class="feed-post-actions">
        <span class="feed-post-action" data-action="open" title="Open article">
          <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6M15 3h6v6M10 14L21 3"/></svg>
          Read
        </span>
      </div>
    ` : '';

    return `<article class="feed-post${isUnread ? ' unread' : ''}" data-type="${type}" data-id="${item.id}">
      <div class="feed-post-inner">
        <div class="feed-post-header">
          <div class="feed-post-avatar">${avatar}</div>
          <div class="feed-post-meta">
            <div class="feed-post-source">
              <span class="feed-post-source-name">${feedName}</span>
              <span class="feed-post-type-badge ${type}">${type === 'podcast' ? 'Podcast' : 'News'}</span>
            </div>
            <div class="feed-post-handle">
              <span>${feed?.author || ''}</span>
              <span class="feed-post-dot"></span>
              <span class="feed-post-time">${item.time || item.date}</span>
            </div>
          </div>
        </div>
        <div class="feed-post-body">
          <div class="feed-post-title">${item.title}</div>
          ${summary ? `<div class="feed-post-summary">${summary}</div>` : ''}
          ${image ? `<div class="feed-post-media"><img src="${image}" onerror="this.parentElement.style.display='none'" alt=""></div>` : ''}
          ${tagsHtml}
          ${podcastMeta}
          ${newsActions}
        </div>
      </div>
    </article>`;
  };

  // Update feed filter nav buttons
  const updateFeedNav = (newsCount, podcastCount) => {
    const totalCount = newsCount + podcastCount;
    el.feedCountAll.textContent = totalCount;
    el.feedCountNews.textContent = newsCount;
    el.feedCountPodcast.textContent = podcastCount;

    // Update active state
    el.feedNav.querySelectorAll('.feed-nav-btn').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.filter === state.feedFilter);
    });
  };

  const renderAll = () => {
    const articles = state.articles.map(a => ({ ...a, sortDate: new Date(a.pubDate), type: 'news' }));
    const episodes = state.podcasts.map(p => ({ ...p, sortDate: new Date(p.pubDate), type: 'podcast' }));

    // Count items for nav
    const newsCount = articles.length;
    const podcastCount = episodes.length;
    updateFeedNav(newsCount, podcastCount);

    // Combine and sort by date
    let allItems = [...articles, ...episodes].sort((a, b) => b.sortDate - a.sortDate);

    // Apply content type filter
    if (state.feedFilter === 'news') {
      allItems = allItems.filter(item => item.type === 'news');
    } else if (state.feedFilter === 'podcast') {
      allItems = allItems.filter(item => item.type === 'podcast');
    }

    // Apply search filter if present
    if (state.query) {
      allItems = fuzzy(state.query, allItems, ['title', 'summary', 'desc']);
    }

    if (!allItems.length) {
      const hasFeeds = state.feeds.length > 0;
      const filterLabel = state.feedFilter === 'news' ? 'news articles' :
                          state.feedFilter === 'podcast' ? 'podcasts' : 'content';
      const emptyIcon = state.feedFilter === 'podcast' ? '<i class="ph ph-headphones"></i>' : state.feedFilter === 'news' ? '<i class="ph ph-newspaper"></i>' : '<i class="ph ph-tray"></i>';
      el.feedScroll.innerHTML = hasFeeds
        ? `<div class="feed-empty">
            <div class="feed-empty-icon">${emptyIcon}</div>
            <div class="feed-empty-title">No ${filterLabel} found</div>
            <div class="feed-empty-desc">Try refreshing your feeds or changing the filter</div>
          </div>`
        : `<div class="feed-empty">
            <div class="feed-empty-icon"><i class="ph ph-broadcast"></i></div>
            <div class="feed-empty-title">No feeds yet</div>
            <div class="feed-empty-desc">Click + to add your first feed</div>
          </div>`;
      return;
    }

    // Render social media style feed
    el.feedScroll.innerHTML = allItems.slice(0, 100).map(item => renderFeedPost(item, item.type)).join('');
  };

  // Handle feed nav filter clicks
  el.feedNav.onclick = e => {
    const btn = e.target.closest('.feed-nav-btn');
    if (!btn) return;
    const filter = btn.dataset.filter;
    if (filter && filter !== state.feedFilter) {
      state.feedFilter = filter;
      Mem.log('feed_filter_changed', 'filter_' + filter);
      renderAll();
    }
  };

  // Handle clicks in feed scroll
  el.feedScroll.onclick = e => {
    const post = e.target.closest('.feed-post');
    if (!post) return;

    const type = post.dataset.type;
    const id = parseInt(post.dataset.id);

    // Check for specific action buttons
    const playBtn = e.target.closest('.feed-post-play');
    const openBtn = e.target.closest('.feed-post-action[data-action="open"]');

    if (type === 'podcast') {
      // For podcasts, always play
      playEp(id);
    } else if (type === 'news') {
      // For news, open the article
      const art = state.articles.find(a => a.id === id);
      if (art) {
        art.unread = false;
        save();
        Mem.log('article_opened', id, { source: art.feedId, link: art.link });
        openArticleLink(art.link);
        renderAll();
      }
    }
  };

  // === PLAYER ===
  const updatePlayer = () => {
    if (!state.currentEp) { el.player.classList.remove('active'); return; }
    const ep = state.currentEp, show = state.feeds.find(f => f.id === ep.feedId);
    const pr = state.progress[ep.id] || 0, pct = ep.duration ? (pr / ep.duration) * 100 : 0;
    el.player.classList.add('active');
    const artSrc = ep.image || show?.image || placeholderImg;
    el.playerArt.src = artSrc;
    el.playerArt.onerror = () => { el.playerArt.src = placeholderImg; };
    el.expArt.src = artSrc;
    el.expArt.onerror = () => { el.expArt.src = placeholderImg; };
    el.playerTitle.textContent = ep.title;
    el.playerShow.textContent = show?.name || '';
    el.expTitle.textContent = ep.title;
    el.expShow.textContent = show?.name || '';
    el.pCur.textContent = fmt(pr);
    el.pDur.textContent = fmt(ep.duration);
    el.expCur.textContent = fmt(pr);
    el.expDur.textContent = fmt(ep.duration);
    el.pFill.style.width = pct + '%';
    el.expFill.style.width = pct + '%';
    const icon = state.playing ? '<rect x="6" y="4" width="4" height="16" rx="1"/><rect x="14" y="4" width="4" height="16" rx="1"/>' : '<path d="M8 5v14l11-7z"/>';
    el.pPlayIcon.innerHTML = icon;
    el.expPlayIcon.innerHTML = icon;
    el.pSpeed.textContent = state.speed + 'x';
  };
  
  let progStart = 0;

  // Audio event handlers
  el.audio.addEventListener('timeupdate', () => {
    if (!state.currentEp) return;
    const cur = el.audio.currentTime;
    state.progress[state.currentEp.id] = cur;

    // Log progress every 30 seconds
    if (cur - progStart >= 30) {
      Mem.log('playback_progress', state.currentEp.id, { from: progStart, to: cur, audioUrl: state.currentEp.audioUrl });
      progStart = cur;
    }
    updatePlayer();
    updatePositionState();
    sleepTimer.checkEpisodeEnd();
  });

  el.audio.addEventListener('ended', () => {
    if (state.currentEp) {
      Mem.log('episode_completed', state.currentEp.id, { audioUrl: state.currentEp.audioUrl });
      state.progress[state.currentEp.id] = state.currentEp.duration;
    }
    state.playing = false;
    save();
    updatePlayer();
  });

  el.audio.addEventListener('pause', () => {
    state.playing = false;
    updatePlayer();
  });

  el.audio.addEventListener('play', () => {
    state.playing = true;
    updatePlayer();
  });

  el.audio.addEventListener('loadedmetadata', () => {
    if (state.currentEp) {
      // Update duration from audio if available
      if (el.audio.duration && !isNaN(el.audio.duration)) {
        state.currentEp.duration = el.audio.duration;
      }
      // Seek to saved position
      const savedPos = state.progress[state.currentEp.id] || 0;
      if (savedPos > 0 && savedPos < el.audio.duration) {
        el.audio.currentTime = savedPos;
      }
    }
    updatePlayer();
    updateMediaSession();
    renderBookmarkMarkers();
  });

  el.audio.addEventListener('error', (e) => {
    console.error('Audio error:', e);
    toast('Error loading audio. Try again.');
    state.playing = false;
    updatePlayer();
  });

  // Save progress periodically
  setInterval(() => {
    if (state.currentEp && state.playing) {
      save();
    }
  }, 10000);

  // Track current blob URL for cleanup
  let currentBlobUrl = null;

  const playEp = async id => {
    const ep = state.podcasts.find(p => p.id === id);
    if (!ep) return;
    if (!ep.audioUrl) {
      toast('No audio URL for this episode');
      return;
    }

    if (state.currentEp && state.currentEp.id !== id) {
      Mem.log('episode_exited', state.currentEp.id, { pos: state.progress[state.currentEp.id] || 0, audioUrl: state.currentEp.audioUrl });
    }

    state.currentEp = ep;
    const pr = state.progress[id] || 0;
    if (pr > 0) Mem.log('returned_to_episode', id, { prev_pos: pr, audioUrl: ep.audioUrl });
    Mem.log('play_pressed', id, { pos: pr, audioUrl: ep.audioUrl });

    progStart = pr;

    // Clean up previous blob URL
    if (currentBlobUrl) {
      URL.revokeObjectURL(currentBlobUrl);
      currentBlobUrl = null;
    }

    // Check if episode is downloaded and use local content
    let audioSrc = ep.audioUrl;
    if (ep.downloaded) {
      try {
        const downloaded = await DownloadDB.get(id);
        if (downloaded && downloaded.blob) {
          currentBlobUrl = URL.createObjectURL(downloaded.blob);
          audioSrc = currentBlobUrl;
          console.log('Playing from downloaded content');
        }
      } catch (e) {
        console.warn('Failed to load downloaded content, falling back to stream:', e);
      }
    }

    // Set audio source and play
    if (el.audio.src !== audioSrc) {
      el.audio.src = audioSrc;
      el.audio.load();
    }
    el.audio.playbackRate = state.speed;
    el.audio.play().catch(e => {
      console.error('Playback failed:', e);
      toast('Playback failed. Check audio source.');
    });

    state.playing = true;
    updatePlayer();
    updateMediaSession();
    renderBookmarkMarkers();
  };

  const togglePlay = () => {
    if (!state.currentEp) return;
    const pr = state.progress[state.currentEp.id] || 0;

    if (state.playing) {
      el.audio.pause();
      Mem.log('pause_pressed', state.currentEp.id, { pos: pr, audioUrl: state.currentEp.audioUrl });
    } else {
      el.audio.play().catch(e => {
        console.error('Playback failed:', e);
        toast('Playback failed');
      });
      Mem.log('play_pressed', state.currentEp.id, { pos: pr, audioUrl: state.currentEp.audioUrl });
    }
  };

  const seekTo = pos => {
    if (!state.currentEp) return;
    const prev = state.progress[state.currentEp.id] || 0;
    const duration = el.audio.duration || state.currentEp.duration;
    const p = Math.max(0, Math.min(duration, pos));
    Mem.log('seek', state.currentEp.id, { from: prev, to: p, audioUrl: state.currentEp.audioUrl });
    el.audio.currentTime = p;
    state.progress[state.currentEp.id] = p;
    save();
    updatePlayer();
  };

  const skip = s => {
    if (state.currentEp) {
      seekTo(el.audio.currentTime + s);
    }
  };

  const cycleSpeed = () => {
    const sp = [0.5, 0.75, 1, 1.25, 1.5, 1.75, 2];
    const i = sp.indexOf(state.speed);
    const prev = state.speed;
    state.speed = sp[(i + 1) % sp.length];
    el.audio.playbackRate = state.speed;
    Mem.log('speed_changed', 'settings', { speed: state.speed, prev });
    updatePlayer();
  };

  // === SWIPE SEEKING ===
  // Swipe on cover art to seek: right = rewind, left = forward
  // Short swipe = 5s, medium = 15s, long = 30s, very long = 60s
  const swipeState = {
    active: false,
    startX: 0,
    startY: 0,
    currentX: 0,
    seekAmount: 0
  };

  const getSeekAmount = (distance) => {
    const absDistance = Math.abs(distance);
    if (absDistance < 30) return 0;      // Dead zone
    if (absDistance < 80) return 5;      // Short swipe: 5s
    if (absDistance < 150) return 15;    // Medium swipe: 15s
    if (absDistance < 250) return 30;    // Long swipe: 30s
    return 60;                            // Very long swipe: 60s
  };

  const triggerHaptic = (intensity = 'light') => {
    if ('vibrate' in navigator) {
      const patterns = { light: 10, medium: 25, heavy: 50 };
      navigator.vibrate(patterns[intensity] || 10);
    }
  };

  const updateSwipeIndicator = (distance, seekAmount) => {
    if (!el.swipeIndicator) return;

    const isRewind = distance > 0;  // Right swipe = rewind

    el.swipeIndicator.classList.toggle('active', seekAmount > 0);
    el.swipeIndicator.classList.toggle('rewind', isRewind);
    el.swipeIndicator.classList.toggle('forward', !isRewind);

    if (seekAmount > 0) {
      el.swipeIcon.innerHTML = isRewind ? '<i class="ph ph-rewind"></i>' : '<i class="ph ph-fast-forward"></i>';
      el.swipeText.textContent = (isRewind ? '-' : '+') + seekAmount + 's';
      el.swipeLabel.textContent = isRewind ? 'Rewind' : 'Forward';
    }
  };

  const handleSwipeStart = (e) => {
    if (!state.currentEp) return;

    const touch = e.touches ? e.touches[0] : e;
    swipeState.active = true;
    swipeState.startX = touch.clientX;
    swipeState.startY = touch.clientY;
    swipeState.currentX = touch.clientX;
    swipeState.seekAmount = 0;
  };

  const handleSwipeMove = (e) => {
    if (!swipeState.active || !state.currentEp) return;

    const touch = e.touches ? e.touches[0] : e;
    const deltaX = touch.clientX - swipeState.startX;
    const deltaY = touch.clientY - swipeState.startY;

    // Ignore if vertical swipe is dominant (allow scrolling)
    if (Math.abs(deltaY) > Math.abs(deltaX) * 1.5) return;

    // Prevent default to stop scrolling during horizontal swipe
    if (Math.abs(deltaX) > 20) {
      e.preventDefault();
    }

    swipeState.currentX = touch.clientX;
    const newSeekAmount = getSeekAmount(deltaX);

    // Haptic feedback when crossing thresholds
    if (newSeekAmount !== swipeState.seekAmount && newSeekAmount > 0) {
      triggerHaptic(newSeekAmount >= 30 ? 'medium' : 'light');
    }

    swipeState.seekAmount = newSeekAmount;
    updateSwipeIndicator(deltaX, newSeekAmount);
  };

  const handleSwipeEnd = (e) => {
    if (!swipeState.active) return;

    const deltaX = swipeState.currentX - swipeState.startX;
    const seekAmount = swipeState.seekAmount;

    if (seekAmount > 0 && state.currentEp) {
      const direction = deltaX > 0 ? -1 : 1;  // Right = rewind (negative), Left = forward (positive)
      const seekSeconds = direction * seekAmount;

      skip(seekSeconds);
      triggerHaptic('medium');
      Mem.log('swipe_seek', state.currentEp.id, {
        direction: deltaX > 0 ? 'rewind' : 'forward',
        amount: seekAmount,
        swipeDistance: Math.abs(deltaX),
        audioUrl: state.currentEp.audioUrl
      });
    }

    // Reset state
    swipeState.active = false;
    swipeState.seekAmount = 0;
    updateSwipeIndicator(0, 0);
  };

  // Attach swipe handlers to the artwork container
  if (el.swipeContainer) {
    el.swipeContainer.addEventListener('touchstart', handleSwipeStart, { passive: true });
    el.swipeContainer.addEventListener('touchmove', handleSwipeMove, { passive: false });
    el.swipeContainer.addEventListener('touchend', handleSwipeEnd, { passive: true });
    el.swipeContainer.addEventListener('touchcancel', handleSwipeEnd, { passive: true });

    // Mouse support for desktop testing
    el.swipeContainer.addEventListener('mousedown', handleSwipeStart);
    el.swipeContainer.addEventListener('mousemove', (e) => {
      if (swipeState.active) handleSwipeMove(e);
    });
    el.swipeContainer.addEventListener('mouseup', handleSwipeEnd);
    el.swipeContainer.addEventListener('mouseleave', handleSwipeEnd);
  }

  // === SLEEP TIMER ===
  const sleepTimer = {
    endTime: null,
    intervalId: null,
    fadeIntervalId: null,
    endOfEpisode: false,

    start(minutes) {
      this.cancel();
      if (minutes === 'episode') {
        this.endOfEpisode = true;
        this.updateUI();
        toast('Sleep timer: end of episode');
        return;
      }
      this.endOfEpisode = false;
      this.endTime = Date.now() + minutes * 60 * 1000;
      this.intervalId = setInterval(() => this.tick(), 1000);
      this.updateUI();
      toast(`Sleep timer: ${minutes} minutes`);
    },

    tick() {
      const remaining = this.endTime - Date.now();
      if (remaining <= 0) {
        this.stop();
        return;
      }
      // Start fade out 15 seconds before end
      if (remaining <= 15000 && !this.fadeIntervalId) {
        this.startFade();
      }
      this.updateUI();
    },

    startFade() {
      const originalVolume = el.audio.volume;
      let fadeStep = originalVolume / 15;
      this.fadeIntervalId = setInterval(() => {
        if (el.audio.volume > fadeStep) {
          el.audio.volume = Math.max(0, el.audio.volume - fadeStep);
        }
      }, 1000);
    },

    stop() {
      el.audio.pause();
      el.audio.volume = 1;
      this.cancel();
      toast('Sleep timer: stopped playback');
    },

    cancel() {
      if (this.intervalId) clearInterval(this.intervalId);
      if (this.fadeIntervalId) clearInterval(this.fadeIntervalId);
      this.intervalId = null;
      this.fadeIntervalId = null;
      this.endTime = null;
      this.endOfEpisode = false;
      el.audio.volume = 1;
      this.updateUI();
    },

    updateUI() {
      const isActive = this.endTime || this.endOfEpisode;
      el.sleepTimerContent.style.display = isActive ? 'none' : 'block';
      el.sleepTimerActive.style.display = isActive ? 'flex' : 'none';
      el.sleepBadge.style.display = isActive ? 'block' : 'none';
      el.pSleep.classList.toggle('active', isActive);

      if (this.endOfEpisode) {
        el.sleepCountdown.textContent = 'End of Episode';
        el.sleepBadge.textContent = 'EP';
      } else if (this.endTime) {
        const remaining = Math.max(0, Math.floor((this.endTime - Date.now()) / 1000));
        el.sleepCountdown.textContent = fmtLong(remaining);
        el.sleepBadge.textContent = Math.ceil(remaining / 60);
      }
    },

    checkEpisodeEnd() {
      if (this.endOfEpisode && state.currentEp) {
        const current = el.audio.currentTime;
        const duration = el.audio.duration || state.currentEp.duration;
        if (duration - current <= 15 && !this.fadeIntervalId) {
          this.startFade();
        }
      }
    }
  };

  // === BOOKMARKS ===
  const addBookmark = () => {
    if (!state.currentEp) return;
    const time = el.audio.currentTime;
    const epId = state.currentEp.id;
    if (!state.bookmarks[epId]) state.bookmarks[epId] = [];
    state.bookmarks[epId].push({ time, note: 'Bookmark', created: Date.now() });
    state.bookmarks[epId].sort((a, b) => a.time - b.time);
    save();
    renderBookmarks();
    toast('Bookmark added at ' + fmt(time));
    Mem.log('bookmark_added', epId, { time, audioUrl: state.currentEp.audioUrl });
  };

  const deleteBookmark = (epId, index) => {
    if (state.bookmarks[epId]) {
      state.bookmarks[epId].splice(index, 1);
      if (state.bookmarks[epId].length === 0) delete state.bookmarks[epId];
      save();
      renderBookmarks();
    }
  };

  const jumpToBookmark = (time) => {
    seekTo(time);
    closeAllPanels();
  };

  const renderBookmarks = () => {
    if (!state.currentEp) {
      el.bookmarksList.innerHTML = '<div class="bookmarks-empty">No episode playing</div>';
      return;
    }
    const epId = state.currentEp.id;
    const bookmarks = state.bookmarks[epId] || [];
    if (bookmarks.length === 0) {
      el.bookmarksList.innerHTML = '<div class="bookmarks-empty">No bookmarks yet. Click + to add one.</div>';
      return;
    }
    el.bookmarksList.innerHTML = bookmarks.map((b, i) => `
      <div class="bookmark-item" data-time="${b.time}">
        <span class="bookmark-time">${fmt(b.time)}</span>
        <span class="bookmark-note">${b.note}</span>
        <button class="bookmark-delete" data-index="${i}"><svg width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 5L5 15M5 5l10 10"/></svg></button>
      </div>
    `).join('');
  };

  const renderBookmarkMarkers = () => {
    // Remove existing markers
    document.querySelectorAll('.bookmark-marker').forEach(m => m.remove());
    if (!state.currentEp) return;
    const epId = state.currentEp.id;
    const bookmarks = state.bookmarks[epId] || [];
    const duration = el.audio.duration || state.currentEp.duration;

    bookmarks.forEach(b => {
      const pct = (b.time / duration) * 100;
      const marker = document.createElement('div');
      marker.className = 'bookmark-marker';
      marker.style.left = pct + '%';
      marker.title = fmt(b.time);
      marker.onclick = (e) => { e.stopPropagation(); jumpToBookmark(b.time); };
      el.pBar.appendChild(marker);
    });
  };

  // === SPEED PANEL ===
  const setSpeed = (speed) => {
    const prev = state.speed;
    state.speed = Math.round(speed * 100) / 100;
    el.audio.playbackRate = state.speed;
    el.pSpeed.textContent = state.speed + 'x';
    el.speedValue.textContent = state.speed.toFixed(2) + 'x';
    el.speedSlider.value = state.speed;
    // Update preset buttons
    document.querySelectorAll('.speed-preset-btn').forEach(btn => {
      btn.classList.toggle('active', parseFloat(btn.dataset.speed) === state.speed);
    });
    if (prev !== state.speed) {
      Mem.log('speed_changed', 'settings', { speed: state.speed, prev });
    }
  };

  // === ADAPTIVE BACKGROUND ===
  const extractColor = (img) => {
    try {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = 50;
      canvas.height = 50;
      ctx.drawImage(img, 0, 0, 50, 50);
      const data = ctx.getImageData(0, 0, 50, 50).data;
      let r = 0, g = 0, b = 0, count = 0;
      for (let i = 0; i < data.length; i += 4) {
        r += data[i];
        g += data[i + 1];
        b += data[i + 2];
        count++;
      }
      r = Math.floor(r / count);
      g = Math.floor(g / count);
      b = Math.floor(b / count);
      // Make color darker for better contrast
      r = Math.floor(r * 0.4);
      g = Math.floor(g * 0.4);
      b = Math.floor(b * 0.4);
      return `rgb(${r}, ${g}, ${b})`;
    } catch (e) {
      return null;
    }
  };

  const updateAdaptiveBackground = () => {
    if (!el.expArt.complete || !el.expArt.src) return;
    // Use a separate image with CORS for color extraction
    // This way if CORS fails, the main image still displays
    const corsImg = new Image();
    corsImg.crossOrigin = 'anonymous';
    corsImg.onload = () => {
      const color = extractColor(corsImg);
      if (color) {
        el.expanded.style.setProperty('--adaptive-color', color);
        el.expanded.classList.add('adaptive-bg');
      }
    };
    corsImg.onerror = () => {
      // CORS failed, just skip adaptive background
      el.expanded.classList.remove('adaptive-bg');
    };
    corsImg.src = el.expArt.src;
  };

  el.expArt.onload = updateAdaptiveBackground;

  // === MEDIA SESSION API ===
  const updateMediaSession = () => {
    if (!('mediaSession' in navigator) || !state.currentEp) return;
    const show = state.feeds.find(f => f.id === state.currentEp.feedId);
    navigator.mediaSession.metadata = new MediaMetadata({
      title: state.currentEp.title,
      artist: show?.name || 'Unknown Show',
      album: show?.name || 'Podcast',
      artwork: [{ src: state.currentEp.image || show?.image || '', sizes: '512x512', type: 'image/jpeg' }]
    });
    navigator.mediaSession.setActionHandler('play', () => { el.audio.play(); });
    navigator.mediaSession.setActionHandler('pause', () => { el.audio.pause(); });
    navigator.mediaSession.setActionHandler('seekbackward', () => skip(-15));
    navigator.mediaSession.setActionHandler('seekforward', () => skip(30));
    navigator.mediaSession.setActionHandler('previoustrack', () => playPreviousEpisode());
    navigator.mediaSession.setActionHandler('nexttrack', () => playNextEpisode());
    navigator.mediaSession.setActionHandler('seekto', (e) => { if (e.seekTime != null) seekTo(e.seekTime); });
  };

  const updatePositionState = () => {
    if (!('mediaSession' in navigator) || !state.currentEp) return;
    try {
      navigator.mediaSession.setPositionState({
        duration: el.audio.duration || state.currentEp.duration,
        playbackRate: state.speed,
        position: el.audio.currentTime
      });
    } catch (e) {}
  };

  const playNextEpisode = () => {
    if (!state.currentEp) return;
    const eps = state.podcasts.filter(p => p.feedId === state.currentEp.feedId);
    const idx = eps.findIndex(p => p.id === state.currentEp.id);
    if (idx > 0) playEp(eps[idx - 1].id);
  };

  const playPreviousEpisode = () => {
    if (!state.currentEp) return;
    const eps = state.podcasts.filter(p => p.feedId === state.currentEp.feedId);
    const idx = eps.findIndex(p => p.id === state.currentEp.id);
    if (idx < eps.length - 1) playEp(eps[idx + 1].id);
  };

  // === DRAWER ===
  const openDrawer = () => {
    renderDrawerContent();
    el.drawer.classList.add('active');
    el.drawerOverlay.classList.add('active');
  };

  const closeDrawer = () => {
    el.drawer.classList.remove('active');
    el.drawerOverlay.classList.remove('active');
  };

  const renderDrawerContent = () => {
    const podcasts = state.feeds.filter(f => f.type === 'podcast');
    const news = state.feeds.filter(f => f.type === 'news');
    el.drawerContent.innerHTML = `
      ${podcasts.length ? `
        <div class="drawer-section">
          <div class="drawer-section-title">Podcasts</div>
          ${podcasts.map(f => `
            <div class="drawer-item" data-type="podcast" data-id="${f.id}">
              <div class="drawer-item-icon">${f.image ? `<img src="${f.image}">` : '<i class="ph ph-microphone-stage"></i>'}</div>
              <span class="drawer-item-name">${f.name}</span>
            </div>
          `).join('')}
        </div>
      ` : ''}
      ${news.length ? `
        <div class="drawer-section">
          <div class="drawer-section-title">News Sources</div>
          ${news.map(f => `
            <div class="drawer-item" data-type="news" data-id="${f.id}">
              <div class="drawer-item-icon">${f.image ? `<img src="${f.image}">` : '<i class="ph ph-newspaper"></i>'}</div>
              <span class="drawer-item-name">${f.name}</span>
              ${f.unread ? `<span class="drawer-item-badge">${f.unread}</span>` : ''}
            </div>
          `).join('')}
        </div>
      ` : ''}
      <div class="drawer-section">
        <div class="drawer-section-title">Quick Actions</div>
        <div class="drawer-item" id="drawerAddFeed">
          <div class="drawer-item-icon"><i class="ph ph-plus"></i></div>
          <span class="drawer-item-name">Add Feed</span>
        </div>
        <div class="drawer-item" id="drawerRefresh">
          <div class="drawer-item-icon"><i class="ph ph-arrows-clockwise"></i></div>
          <span class="drawer-item-name">Refresh All</span>
        </div>
        <div class="drawer-item" id="drawerHistory">
          <div class="drawer-item-icon"><i class="ph ph-clock-counter-clockwise"></i></div>
          <span class="drawer-item-name">History Snapshots</span>
        </div>
      </div>
    `;
  };

  // === PANEL MANAGEMENT ===
  const closeAllPanels = () => {
    el.speedPanel.classList.remove('active');
    el.bookmarksPanel.classList.remove('active');
    state.speedPanelOpen = false;
    state.bookmarksPanelOpen = false;
  };

  const toggleSpeedPanel = () => {
    const wasOpen = state.speedPanelOpen;
    closeAllPanels();
    if (!wasOpen) {
      el.speedPanel.classList.add('active');
      state.speedPanelOpen = true;
    }
  };

  const toggleBookmarksPanel = () => {
    const wasOpen = state.bookmarksPanelOpen;
    closeAllPanels();
    if (!wasOpen) {
      renderBookmarks();
      el.bookmarksPanel.classList.add('active');
      state.bookmarksPanelOpen = true;
    }
  };

  // Close panels when clicking outside
  document.addEventListener('click', (e) => {
    if (!e.target.closest('.player-right') && !e.target.closest('.speed-panel') && !e.target.closest('.bookmarks-panel')) {
      closeAllPanels();
    }
  });

  // === EVENTS ===
  document.querySelector('.main-toggle').onclick = e => {
    const btn = e.target.closest('.toggle-btn');
    if (!btn) return;
    document.querySelectorAll('.toggle-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    const prev = state.view;
    state.view = btn.dataset.view;
    Mem.log('view_changed', 'view_' + state.view, { prev });
    el.newsView.classList.toggle('active', state.view === 'news');
    el.podcastView.classList.toggle('active', state.view === 'podcasts');
    el.allView.classList.toggle('active', state.view === 'all');
    if (state.view === 'podcasts') renderPodcasts();
    if (state.view === 'all') renderAll();
    save();
  };
  
  el.newsSources.onclick = e => {
    const src = e.target.closest('.source-item');
    if (!src) return;
    const id = src.dataset.id;
    if (id === 'all') {
      state.selectedSource = null;
      el.newsTitle.textContent = 'All Articles';
      renderNewsSources(); renderNews();
    } else {
      // Open source page for individual sources
      renderSourcePage(parseInt(id));
    }
  };
  
  el.categoryChips.onclick = e => {
    const chip = e.target.closest('.chip');
    if (!chip) return;
    const prev = state.selectedCat;
    state.selectedCat = chip.dataset.cat;
    Mem.log('category_changed', 'cat_' + state.selectedCat, { prev });
    renderCategories(); renderNews();
  };

  // Tag filter click handler
  el.tagChips.onclick = e => {
    const chip = e.target.closest('.tag-chip');
    if (!chip) return;
    const prev = state.selectedTag;
    state.selectedTag = chip.dataset.tag;
    Mem.log('tag_filter_changed', 'tag_' + state.selectedTag, { prev });
    renderTagFilters();
    renderNews();
  };

  el.newsList.onclick = e => {
    // Source name click - navigate to source page
    const sourceEl = e.target.closest('.article-source');
    if (sourceEl) {
      const item = e.target.closest('.article');
      if (item) {
        const id = parseInt(item.dataset.id);
        const art = state.articles.find(a => a.id === id);
        if (art && art.feedId) {
          renderSourcePage(art.feedId);
          return;
        }
      }
    }

    const item = e.target.closest('.article');
    if (!item) return;
    const id = parseInt(item.dataset.id);
    const art = state.articles.find(a => a.id === id);
    if (art) {
      Mem.log('article_opened', id, { source: art.feedId, link: art.link });
      art.unread = false;
      save();
      openArticleLink(art.link);
      renderNews();
    }
  };

  // Source page event handlers
  el.sourcePage.onclick = e => {
    // Back button
    const backBtn = e.target.closest('#sourceBackBtn');
    if (backBtn) {
      closeSourcePage();
      return;
    }

    // View options
    const viewBtn = e.target.closest('.view-btn');
    if (viewBtn) {
      const sourceKey = viewBtn.closest('.view-options').dataset.source;
      const newView = viewBtn.dataset.view;
      setViewPref(sourceKey, newView);
      if (state.currentSourcePage) renderSourcePage(state.currentSourcePage);
      return;
    }

    // Article clicks (all view modes)
    const articleEl = e.target.closest('.article, .article-card, .article-masonry, [data-id]');
    if (articleEl && articleEl.dataset.id) {
      const id = parseInt(articleEl.dataset.id);
      const art = state.articles.find(a => a.id === id);
      if (art) {
        Mem.log('article_opened', id, { source: art.feedId, link: art.link });
        art.unread = false;
        save();
        openArticleLink(art.link);
        if (state.currentSourcePage) renderSourcePage(state.currentSourcePage);
      }
      return;
    }

    // Table row clicks
    const tableRow = e.target.closest('tr[data-id]');
    if (tableRow) {
      const id = parseInt(tableRow.dataset.id);
      const art = state.articles.find(a => a.id === id);
      if (art) {
        Mem.log('article_opened', id, { source: art.feedId, link: art.link });
        art.unread = false;
        save();
        openArticleLink(art.link);
        if (state.currentSourcePage) renderSourcePage(state.currentSourcePage);
      }
    }
  };

  // === PODCAST INBOX EVENT HANDLERS ===
  el.podcastSources.onclick = e => {
    const src = e.target.closest('.source-item');
    if (!src) return;
    const id = src.dataset.id;
    if (id === 'all') {
      state.selectedPodcastSource = null;
      el.podcastInboxTitle.textContent = 'All Episodes';
      renderPodcastSources();
      renderPodcastInbox();
    } else {
      // Open show page for individual sources
      renderShowPage(parseInt(id));
    }
  };

  el.podcastCategoryChips.onclick = e => {
    const chip = e.target.closest('.chip');
    if (!chip) return;
    const prev = state.selectedPodcastCat;
    state.selectedPodcastCat = chip.dataset.cat;
    Mem.log('podcast_category_changed', 'cat_' + state.selectedPodcastCat, { prev });
    renderPodcastCategories();
    renderPodcastInbox();
  };

  el.podcastTagChips.onclick = e => {
    const chip = e.target.closest('.tag-chip');
    if (!chip) return;
    const prev = state.selectedPodcastTag;
    state.selectedPodcastTag = chip.dataset.tag;
    Mem.log('podcast_tag_filter_changed', 'tag_' + state.selectedPodcastTag, { prev });
    renderPodcastTagFilters();
    renderPodcastInbox();
  };

  el.podcastInboxList.onclick = e => {
    // Show name click - navigate to show page
    const showEl = e.target.closest('.podcast-episode-show');
    if (showEl) {
      const showId = parseInt(showEl.dataset.show);
      if (showId) {
        renderShowPage(showId);
        return;
      }
    }

    // Play button click
    const playBtn = e.target.closest('.podcast-episode-play');
    if (playBtn) {
      const epId = parseInt(playBtn.dataset.ep);
      playEp(epId);
      return;
    }

    // Episode item click - play episode
    const item = e.target.closest('.podcast-episode-item');
    if (item) {
      const epId = parseInt(item.dataset.ep);
      playEp(epId);
    }
  };

  // Add podcast button in sidebar
  document.getElementById('addPodcastBtn').onclick = () => {
    document.getElementById('tPodcast').click();
    el.modal.classList.add('active');
  };

  // Legacy podcastContent handler for show page elements (still needed for show page)
  const podcastContentEl = document.getElementById('podcastContent');
  if (podcastContentEl) podcastContentEl.onclick = e => {
    // Show card click
    const card = e.target.closest('.show-card');
    if (card) { renderShowPage(parseInt(card.dataset.show)); return; }

    // Show name click in episode - navigate to show page
    const showNameEl = e.target.closest('.episode-show');
    if (showNameEl) {
      const epEl = e.target.closest('.episode, .episode-card, .episode-masonry, tr[data-ep]');
      if (epEl && epEl.dataset.ep) {
        const ep = state.podcasts.find(p => p.id === parseInt(epEl.dataset.ep));
        if (ep && ep.feedId) {
          renderShowPage(ep.feedId);
          return;
        }
      }
    }

    // Play button (list/table view)
    const playBtn = e.target.closest('.ep-play, .table-play-btn');
    if (playBtn) { playEp(parseInt(playBtn.dataset.ep)); return; }

    // Download button
    const dl = e.target.closest('.ep-dl');
    if (dl) {
      const id = parseInt(dl.dataset.dl);
      const p = state.podcasts.find(x => x.id === id);
      if (p) {
        if (p.downloaded) {
          removeDownload(id);
        } else {
          startDownload(id);
        }
      }
      return;
    }

    // Episode clicks (all view modes - list, card, masonry, table row)
    const epEl = e.target.closest('.episode, .episode-card, .episode-masonry, tr[data-ep]');
    if (epEl && epEl.dataset.ep) {
      playEp(parseInt(epEl.dataset.ep));
    }
  };
  
  el.showPage.onclick = e => {
    // Back button
    const backBtn = e.target.closest('#showBackBtn');
    if (backBtn) {
      closeShowPage();
      return;
    }

    // View options
    const viewBtn = e.target.closest('.view-btn');
    if (viewBtn) {
      const sourceKey = viewBtn.closest('.view-options').dataset.source;
      const newView = viewBtn.dataset.view;
      setViewPref(sourceKey, newView);
      if (state.currentShowPage) renderShowPage(state.currentShowPage);
      return;
    }

    // Play button (list view)
    const playBtn = e.target.closest('.ep-play, .table-play-btn');
    if (playBtn) { playEp(parseInt(playBtn.dataset.ep)); return; }

    // Show play button
    const showPlay = e.target.closest('.show-play');
    if (showPlay) { const eps = state.podcasts.filter(p => p.feedId === parseInt(showPlay.dataset.show)); if (eps.length) playEp(eps[0].id); return; }

    // Download button
    const dl = e.target.closest('.ep-dl');
    if (dl) {
      const id = parseInt(dl.dataset.dl);
      const p = state.podcasts.find(x => x.id === id);
      if (p) {
        if (p.downloaded) {
          removeDownload(id);
        } else {
          startDownload(id);
        }
      }
      return;
    }

    // Episode clicks (all view modes - list, card, masonry, table row)
    const epEl = e.target.closest('.episode, .episode-card, .episode-masonry, tr[data-ep]');
    if (epEl && epEl.dataset.ep) {
      playEp(parseInt(epEl.dataset.ep));
    }
  };
  
  el.pPlay.onclick = togglePlay;
  el.expPlay.onclick = togglePlay;
  el.pSpeed.onclick = cycleSpeed;
  $('pSkipBack').onclick = () => skip(-15);
  $('pSkipFwd').onclick = () => skip(30);
  $('expBack').onclick = () => skip(-15);
  $('expFwd').onclick = () => skip(30);
  el.pBar.onclick = e => { if (!state.currentEp) return; const r = el.pBar.getBoundingClientRect(); seekTo((e.clientX - r.left) / r.width * (el.audio.duration || state.currentEp.duration)); };
  el.pBar.onmousemove = e => {
    if (!state.currentEp) return;
    const r = el.pBar.getBoundingClientRect();
    const pct = Math.max(0, Math.min(1, (e.clientX - r.left) / r.width));
    const duration = el.audio.duration || state.currentEp.duration;
    const time = pct * duration;
    el.scrubTooltip.textContent = fmt(time);
    el.scrubTooltip.style.left = (pct * 100) + '%';
  };
  el.expBar.onclick = e => { if (!state.currentEp) return; const r = el.expBar.getBoundingClientRect(); seekTo((e.clientX - r.left) / r.width * state.currentEp.duration); };
  $('pExpand').onclick = () => el.expanded.classList.add('active');
  $('expClose').onclick = () => el.expanded.classList.remove('active');
  el.playerArt.onclick = () => el.expanded.classList.add('active');
  
  $('refreshBtn').onclick = () => refreshAllFeeds();
  $('addBtn').onclick = () => el.modal.classList.add('active');
  $('addNewsBtn').onclick = () => { $('tNews').click(); el.modal.classList.add('active'); };
  $('modalClose').onclick = () => el.modal.classList.remove('active');
  el.modal.onclick = e => { if (e.target === el.modal) el.modal.classList.remove('active'); };
  $('tNews').onclick = () => { state.feedType = 'news'; $('tNews').classList.add('active'); $('tPodcast').classList.remove('active'); };
  $('tPodcast').onclick = () => { state.feedType = 'podcast'; $('tPodcast').classList.add('active'); $('tNews').classList.remove('active'); };

  // Settings modal handlers
  el.settingsBtn.onclick = () => {
    el.openLinksToggle.checked = state.openLinksInNewTab;
    el.settingsModal.classList.add('active');
  };
  el.settingsClose.onclick = () => el.settingsModal.classList.remove('active');
  el.settingsModal.onclick = e => { if (e.target === el.settingsModal) el.settingsModal.classList.remove('active'); };
  el.openLinksToggle.onchange = () => {
    state.openLinksInNewTab = el.openLinksToggle.checked;
    save();
    toast(state.openLinksInNewTab ? 'Links will open in new tab' : 'Links will open in same tab');
  };

  // Form validation and state
  let metadataFetched = false;
  const validateForm = () => {
    const hasUrl = el.fUrl.value.trim().length > 0;
    el.fFetch.disabled = !hasUrl;
    el.fSubmit.disabled = !hasUrl;
  };

  const setFetchStatus = (message, type) => {
    el.fStatus.textContent = message;
    el.fStatus.className = 'fetch-status ' + (type || '');
  };

  const setFormDisabled = (disabled) => {
    el.fUrl.disabled = disabled;
    el.fName.disabled = disabled;
    el.fAuthor.disabled = disabled;
    el.fCat.disabled = disabled;
    el.fFetch.disabled = disabled;
  };

  // Fetch metadata when button is clicked
  el.fFetch.onclick = async () => {
    const url = el.fUrl.value.trim();
    if (!url) return;

    // Show loading state
    el.fFetch.disabled = true;
    el.fFetch.textContent = 'Fetching...';
    el.fFetch.classList.add('loading');
    setFetchStatus('Fetching feed metadata...', 'loading');

    const result = await fetchFeedMetadata(url);

    el.fFetch.textContent = 'Fetch';
    el.fFetch.classList.remove('loading');
    el.fFetch.disabled = false;

    if (result.success) {
      // Pre-populate form fields with fetched metadata
      if (result.title && !el.fName.value.trim()) {
        el.fName.value = result.title;
      }
      if (result.author && !el.fAuthor.value.trim()) {
        el.fAuthor.value = result.author;
      }

      // Auto-select feed type based on content
      if (result.suggestedType === 'podcast') {
        state.feedType = 'podcast';
        $('tPodcast').classList.add('active');
        $('tNews').classList.remove('active');
      } else {
        state.feedType = 'news';
        $('tNews').classList.add('active');
        $('tPodcast').classList.remove('active');
      }

      metadataFetched = true;
      // Show appropriate message based on what was found
      if (result.title || result.author) {
        setFetchStatus('Metadata loaded! You can edit the fields below.', 'success');
      } else {
        setFetchStatus('Feed found but no metadata detected. Please enter name manually.', 'success');
      }
    } else {
      setFetchStatus('Failed to fetch: ' + (result.error || 'Unknown error'), 'error');
    }
  };

  // Also fetch on URL blur if we haven't fetched yet
  el.fUrl.onblur = () => {
    const url = el.fUrl.value.trim();
    // Support http, https, podcast://, feed://, pcast://, podcasts:// schemes
    const validSchemes = ['http://', 'https://', 'podcast://', 'feed://', 'pcast://', 'podcasts://'];
    const hasValidScheme = validSchemes.some(s => url.toLowerCase().startsWith(s));
    if (url && !metadataFetched && hasValidScheme) {
      el.fFetch.click();
    }
  };

  el.fUrl.oninput = () => {
    metadataFetched = false; // Reset when URL changes
    setFetchStatus('', '');
    validateForm();
  };
  el.fName.oninput = validateForm;
  el.fAuthor.oninput = validateForm;

  el.fSubmit.onclick = async () => {
    const rawUrl = el.fUrl.value.trim();
    const url = normalizeFeedUrl(rawUrl); // Convert podcast://, feed://, etc. to https://
    const name = el.fName.value.trim();
    const author = el.fAuthor.value.trim();
    const cat = el.fCat.value.trim() || 'Uncategorized';
    if (!url) return;

    // Disable form while adding
    el.fSubmit.disabled = true;
    el.fSubmit.textContent = 'Adding...';
    setFormDisabled(true);

    await addFeed(url, name, state.feedType, cat, author);

    // Reset form
    el.fUrl.value = '';
    el.fName.value = '';
    el.fAuthor.value = '';
    el.fCat.value = '';
    el.fSubmit.textContent = 'Add Feed';
    el.fSubmit.disabled = true;
    setFormDisabled(false);
    setFetchStatus('', '');
    metadataFetched = false;
    el.modal.classList.remove('active');
  };
  
  let searchTO;
  el.searchInput.oninput = e => { clearTimeout(searchTO); searchTO = setTimeout(() => { state.query = e.target.value; if (state.view === 'news') renderNews(); if (state.view === 'all') renderAll(); }, 200); };
  
  // === KEYBOARD SHORTCUTS ===
  document.onkeydown = e => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

    // Basic playback
    if (e.code === 'Space') { e.preventDefault(); togglePlay(); return; }
    if (e.code === 'ArrowLeft') { skip(-15); return; }
    if (e.code === 'ArrowRight') { skip(30); return; }

    // Fullscreen toggle
    if (e.key === 'f' || e.key === 'F') {
      e.preventDefault();
      el.expanded.classList.toggle('active');
      return;
    }
    if (e.key === 'Escape') {
      el.expanded.classList.remove('active');
      el.sleepTimerModal.classList.remove('active');
      el.snapshotModal.classList.remove('active');
      closeAllPanels();
      closeDrawer();
      return;
    }

    // Bookmarks
    if (e.key === 'b' || e.key === 'B') {
      if (!e.shiftKey) { e.preventDefault(); addBookmark(); }
      return;
    }

    // Speed panel
    if (e.key === 's' || e.key === 'S') {
      if (!e.ctrlKey && !e.metaKey) { e.preventDefault(); toggleSpeedPanel(); }
      return;
    }

    // Sleep timer
    if (e.key === 'm' || e.key === 'M') {
      e.preventDefault();
      el.sleepTimerModal.classList.toggle('active');
      return;
    }

    // Speed adjust with brackets
    if (e.key === '[') { e.preventDefault(); setSpeed(Math.max(0.5, state.speed - 0.05)); return; }
    if (e.key === ']') { e.preventDefault(); setSpeed(Math.min(3, state.speed + 0.05)); return; }

    // Speed presets with Ctrl+1-5
    if (e.ctrlKey || e.metaKey) {
      const presets = { '1': 0.75, '2': 1, '3': 1.25, '4': 1.5, '5': 2 };
      if (presets[e.key]) { e.preventDefault(); setSpeed(presets[e.key]); return; }
    }

    // Next/Previous episode with Shift+N/P
    if (e.shiftKey) {
      if (e.key === 'N' || e.key === 'n') { e.preventDefault(); playNextEpisode(); return; }
      if (e.key === 'P' || e.key === 'p') { e.preventDefault(); playPreviousEpisode(); return; }
    }
  };

  // === NEW FEATURE EVENT HANDLERS ===

  // Hamburger & Drawer
  el.hamburgerBtn.onclick = openDrawer;
  el.drawerClose.onclick = closeDrawer;
  el.drawerOverlay.onclick = closeDrawer;
  el.drawerContent.onclick = e => {
    const item = e.target.closest('.drawer-item');
    if (!item) return;
    if (item.id === 'drawerAddFeed') {
      closeDrawer();
      el.modal.classList.add('active');
      return;
    }
    if (item.id === 'drawerRefresh') {
      closeDrawer();
      refreshAllFeeds();
      return;
    }
    if (item.id === 'drawerHistory') {
      closeDrawer();
      openSnapshotModal();
      return;
    }
    const type = item.dataset.type;
    const id = parseInt(item.dataset.id);
    closeDrawer();
    if (type === 'podcast') {
      document.querySelectorAll('.toggle-btn').forEach(b => b.classList.toggle('active', b.dataset.view === 'podcasts'));
      state.view = 'podcasts';
      el.newsView.classList.remove('active');
      el.podcastView.classList.add('active');
      el.allView.classList.remove('active');
      renderShowPage(id);
    } else if (type === 'news') {
      document.querySelectorAll('.toggle-btn').forEach(b => b.classList.toggle('active', b.dataset.view === 'news'));
      state.view = 'news';
      el.newsView.classList.add('active');
      el.podcastView.classList.remove('active');
      el.allView.classList.remove('active');
      renderSourcePage(id);
    }
  };

  // Sleep Timer
  el.pSleep.onclick = () => el.sleepTimerModal.classList.add('active');
  el.sleepTimerModal.onclick = e => { if (e.target === el.sleepTimerModal) el.sleepTimerModal.classList.remove('active'); };
  el.sleepPresets.onclick = e => {
    const btn = e.target.closest('.sleep-preset');
    if (!btn) return;
    const minutes = btn.dataset.minutes;
    sleepTimer.start(minutes === 'episode' ? 'episode' : parseInt(minutes));
    el.sleepTimerModal.classList.remove('active');
  };
  el.sleepCustomBtn.onclick = () => {
    const val = parseInt(el.sleepCustomInput.value);
    if (val > 0 && val <= 999) {
      sleepTimer.start(val);
      el.sleepCustomInput.value = '';
      el.sleepTimerModal.classList.remove('active');
    }
  };
  el.sleepCancelBtn.onclick = () => {
    sleepTimer.cancel();
    toast('Sleep timer cancelled');
  };

  // === SNAPSHOT MODAL ===
  const renderSnapshotList = async () => {
    try {
      const snapshots = await SnapshotDB.listSnapshots();
      if (!snapshots.length) {
        el.snapshotList.innerHTML = `
          <div class="snapshot-empty" style="text-align:center;padding:32px;color:var(--text2)">
            <i class="ph ph-clock-counter-clockwise" style="font-size:48px;opacity:0.3"></i>
            <p style="margin-top:12px">No snapshots yet</p>
            <p style="font-size:13px">Create a snapshot to save your current state</p>
          </div>`;
        return;
      }
      el.snapshotList.innerHTML = snapshots.map(snap => `
        <div class="snapshot-item" data-id="${snap.id}">
          <div class="snapshot-icon"><i class="ph ph-clock-counter-clockwise"></i></div>
          <div class="snapshot-info">
            <div class="snapshot-date">${snap.date}</div>
            <div class="snapshot-reason">${snap.reason.replace(/_/g, ' ')}</div>
            <div class="snapshot-stats">${snap.stats.feedCount} feeds, ${snap.stats.articleCount} articles, ${snap.stats.podcastCount} episodes</div>
          </div>
          <div class="snapshot-actions-row">
            <button class="snapshot-btn restore" data-action="restore" data-id="${snap.id}">Restore</button>
            <button class="snapshot-btn delete" data-action="delete" data-id="${snap.id}"><i class="ph ph-trash"></i></button>
          </div>
        </div>
      `).join('');
    } catch (e) {
      console.error('Failed to render snapshots:', e);
      el.snapshotList.innerHTML = '<div style="color:var(--text2);text-align:center;padding:20px">Failed to load snapshots</div>';
    }
  };

  const openSnapshotModal = async () => {
    el.snapshotModal.classList.add('active');
    await renderSnapshotList();
  };

  const closeSnapshotModal = () => {
    el.snapshotModal.classList.remove('active');
  };

  el.snapshotModalClose.onclick = closeSnapshotModal;
  el.snapshotModal.onclick = e => { if (e.target === el.snapshotModal) closeSnapshotModal(); };

  el.createSnapshotBtn.onclick = async () => {
    try {
      await SnapshotDB.createSnapshot('manual');
      toast('Snapshot created');
      await renderSnapshotList();
    } catch (e) {
      toast('Failed to create snapshot');
      console.error(e);
    }
  };

  el.snapshotList.onclick = async e => {
    const btn = e.target.closest('.snapshot-btn');
    if (!btn) return;

    const action = btn.dataset.action;
    const id = btn.dataset.id;

    if (action === 'restore') {
      if (!confirm('Restore this snapshot? Your current state will be saved first.')) return;
      try {
        const snap = await SnapshotDB.restoreSnapshot(id);
        toast(`Restored to ${new Date(snap.timestamp).toLocaleString()}`);
        closeSnapshotModal();
        // Re-render everything
        renderNewsSources();
        renderCategories();
        renderTagFilters();
        renderNews();
        renderPodcasts();
        renderAll();
      } catch (e) {
        toast('Failed to restore snapshot');
        console.error(e);
      }
    } else if (action === 'delete') {
      if (!confirm('Delete this snapshot?')) return;
      try {
        await SnapshotDB.deleteSnapshot(id);
        toast('Snapshot deleted');
        await renderSnapshotList();
      } catch (e) {
        toast('Failed to delete snapshot');
        console.error(e);
      }
    }
  };

  // Expose snapshot modal opener globally
  window.openSnapshotModal = openSnapshotModal;

  // Speed Panel
  el.pSpeed.onclick = (e) => { e.stopPropagation(); toggleSpeedPanel(); };
  el.speedSlider.oninput = () => setSpeed(parseFloat(el.speedSlider.value));
  el.speedPanel.onclick = e => {
    e.stopPropagation();
    const btn = e.target.closest('.speed-preset-btn');
    if (btn) setSpeed(parseFloat(btn.dataset.speed));
  };

  // Bookmarks Panel
  el.pBookmark.onclick = (e) => { e.stopPropagation(); toggleBookmarksPanel(); };
  el.addBookmarkBtn.onclick = (e) => { e.stopPropagation(); addBookmark(); };
  el.bookmarksList.onclick = e => {
    e.stopPropagation();
    const del = e.target.closest('.bookmark-delete');
    if (del) {
      const epId = state.currentEp?.id;
      const idx = parseInt(del.dataset.index);
      if (epId !== undefined) deleteBookmark(epId, idx);
      return;
    }
    const item = e.target.closest('.bookmark-item');
    if (item) {
      jumpToBookmark(parseFloat(item.dataset.time));
    }
  };

  // ==========================================
  // MOBILE TOUCH ENHANCEMENTS
  // ==========================================

  /**
   * Enhanced Touch Feedback System
   * Provides visual and haptic feedback for all interactions
   */
  const TouchFeedback = {
    /**
     * Haptic feedback wrapper with intensity levels
     * @param {string} intensity - 'light' | 'medium' | 'heavy' | 'success' | 'error'
     */
    haptic(intensity = 'light') {
      if (!('vibrate' in navigator)) return;

      const patterns = {
        light: 10,
        medium: 20,
        heavy: 40,
        success: [10, 50, 10],
        error: [20, 100, 20],
        selection: 5
      };

      navigator.vibrate(patterns[intensity] || patterns.light);
    },

    /**
     * Visual press feedback for elements
     * @param {HTMLElement} element - Element to apply feedback to
     */
    press(element) {
      if (!element) return;

      element.style.transform = 'scale(0.96)';
      element.style.opacity = '0.8';
      element.style.transition = 'transform 0.1s ease-out, opacity 0.1s ease-out';

      setTimeout(() => {
        element.style.transform = '';
        element.style.opacity = '';
      }, 100);
    },

    /**
     * Ripple effect on tap
     * @param {Event} e - Touch/click event
     */
    ripple(e) {
      const button = e.currentTarget;
      const ripple = document.createElement('span');
      const rect = button.getBoundingClientRect();
      const size = Math.max(rect.width, rect.height);
      const x = e.clientX - rect.left - size / 2;
      const y = e.clientY - rect.top - size / 2;

      ripple.style.cssText = `
        position: absolute;
        width: ${size}px;
        height: ${size}px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.3);
        left: ${x}px;
        top: ${y}px;
        transform: scale(0);
        pointer-events: none;
        animation: ripple 0.6s ease-out;
      `;

      button.style.position = 'relative';
      button.style.overflow = 'hidden';
      button.appendChild(ripple);

      setTimeout(() => ripple.remove(), 600);
    }
  };

  /**
   * Apply touch feedback to all interactive elements
   */
  const initTouchFeedback = () => {
    // Primary buttons get haptic + visual feedback
    const primaryButtons = document.querySelectorAll(`
      .toggle-btn,
      .ep-play,
      .player-play,
      .expanded-play,
      .show-play,
      .add-btn,
      .submit-btn
    `);

    primaryButtons.forEach(btn => {
      btn.addEventListener('touchstart', (e) => {
        TouchFeedback.haptic('medium');
        TouchFeedback.press(e.currentTarget);
      }, { passive: true });

      btn.addEventListener('click', (e) => {
        TouchFeedback.ripple(e);
      });
    });

    // Secondary buttons get lighter feedback
    const secondaryButtons = document.querySelectorAll(`
      .icon-btn,
      .chip,
      .tag-chip,
      .speed-btn,
      .player-btn,
      .back-btn
    `);

    secondaryButtons.forEach(btn => {
      btn.addEventListener('touchstart', () => {
        TouchFeedback.haptic('light');
      }, { passive: true });
    });

    // List items get selection feedback
    const listItems = document.querySelectorAll(`
      .article,
      .episode,
      .source-item,
      .show-card,
      .drawer-item
    `);

    listItems.forEach(item => {
      item.addEventListener('touchstart', () => {
        TouchFeedback.haptic('selection');
      }, { passive: true });
    });
  };

  /**
   * Pull-to-Refresh Implementation
   */
  const PullToRefresh = {
    enabled: false,
    pulling: false,
    startY: 0,
    currentY: 0,
    threshold: 100,
    maxPull: 150,
    indicator: null,

    init() {
      // Only enable on mobile
      if (window.innerWidth > 640) return;

      this.enabled = true;
      this.createIndicator();
      this.attachListeners();
    },

    createIndicator() {
      this.indicator = document.createElement('div');
      this.indicator.className = 'pull-to-refresh-indicator';
      this.indicator.innerHTML = `
        <div class="pull-spinner">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0118.8-4.3M22 12.5a10 10 0 01-18.8 4.2"/>
          </svg>
        </div>
        <div class="pull-text">Pull to refresh</div>
      `;

      document.body.appendChild(this.indicator);
    },

    attachListeners() {
      let scrollable;

      document.addEventListener('touchstart', (e) => {
        // Only activate at top of scroll
        scrollable = e.target.closest('.news-list, .podcast-content, .all-content, .feed-scroll');
        if (!scrollable || scrollable.scrollTop > 5) return;

        this.startY = e.touches[0].clientY;
        this.pulling = false;
      }, { passive: true });

      document.addEventListener('touchmove', (e) => {
        if (!scrollable || scrollable.scrollTop > 5) return;

        this.currentY = e.touches[0].clientY;
        const pullDistance = this.currentY - this.startY;

        if (pullDistance > 0 && this.indicator) {
          const pull = Math.min(pullDistance * 0.5, this.maxPull);
          this.indicator.style.transform = `translateY(${pull}px)`;

          if (pull >= this.threshold && !this.pulling) {
            this.pulling = true;
            this.indicator.querySelector('.pull-spinner').classList.add('ready');
            this.indicator.querySelector('.pull-text').textContent = 'Release to refresh';
            TouchFeedback.haptic('medium');
          } else if (pull < this.threshold && this.pulling) {
            this.pulling = false;
            this.indicator.querySelector('.pull-spinner').classList.remove('ready');
            this.indicator.querySelector('.pull-text').textContent = 'Pull to refresh';
          }
        }
      }, { passive: true });

      document.addEventListener('touchend', async () => {
        if (this.pulling && this.indicator) {
          TouchFeedback.haptic('success');
          this.indicator.querySelector('.pull-text').textContent = 'Refreshing...';

          // Perform refresh
          await refreshAllFeeds();

          // Reset
          setTimeout(() => {
            if (this.indicator) {
              this.indicator.style.transform = '';
              this.pulling = false;
              this.indicator.querySelector('.pull-spinner').classList.remove('ready');
              this.indicator.querySelector('.pull-text').textContent = 'Pull to refresh';
            }
          }, 300);
        } else if (this.indicator) {
          this.indicator.style.transform = '';
        }

        scrollable = null;
      }, { passive: true });
    }
  };

  /**
   * Bottom Sheet Panel Behavior
   * Makes speed panel and bookmarks panel slide up from bottom
   */
  const BottomSheet = {
    backdrop: null,

    init() {
      if (window.innerWidth > 640) return;

      // Add backdrop
      this.backdrop = document.createElement('div');
      this.backdrop.className = 'bottom-sheet-backdrop';
      document.body.appendChild(this.backdrop);

      // Override panel open/close
      const originalToggleSpeed = window.toggleSpeedPanel;
      if (originalToggleSpeed) {
        window.toggleSpeedPanel = () => {
          originalToggleSpeed();
          this.updateBackdrop(el.speedPanel?.classList.contains('active'));
        };
      }

      const originalToggleBookmarks = window.toggleBookmarksPanel;
      if (originalToggleBookmarks) {
        window.toggleBookmarksPanel = () => {
          originalToggleBookmarks();
          this.updateBackdrop(el.bookmarksPanel?.classList.contains('active'));
        };
      }

      // Close on swipe down
      [el.speedPanel, el.bookmarksPanel].forEach(panel => {
        if (!panel) return;

        let startY = 0;
        panel.addEventListener('touchstart', (e) => {
          if (panel.scrollTop === 0) {
            startY = e.touches[0].clientY;
          }
        }, { passive: true });

        panel.addEventListener('touchmove', (e) => {
          if (panel.scrollTop === 0) {
            const currentY = e.touches[0].clientY;
            const diff = currentY - startY;

            if (diff > 0) {
              panel.style.transform = `translateY(${diff}px)`;
            }
          }
        }, { passive: true });

        panel.addEventListener('touchend', (e) => {
          const currentY = e.changedTouches[0].clientY;
          const diff = currentY - startY;

          if (diff > 100) {
            closeAllPanels();
            this.updateBackdrop(false);
          }

          panel.style.transform = '';
        }, { passive: true });
      });
    },

    updateBackdrop(isOpen) {
      if (!this.backdrop) return;

      if (isOpen) {
        this.backdrop.style.opacity = '1';
        this.backdrop.style.pointerEvents = 'auto';
        this.backdrop.onclick = () => {
          closeAllPanels();
          this.updateBackdrop(false);
        };
      } else {
        this.backdrop.style.opacity = '0';
        this.backdrop.style.pointerEvents = 'none';
      }
    }
  };

  /**
   * Smart Scroll Behavior
   * Hide header on scroll down, show on scroll up
   */
  const SmartScroll = {
    lastScroll: 0,
    scrollThreshold: 10,

    init() {
      if (window.innerWidth > 640) return;

      let ticking = false;

      window.addEventListener('scroll', () => {
        if (!ticking) {
          window.requestAnimationFrame(() => {
            this.handleScroll();
            ticking = false;
          });
          ticking = true;
        }
      }, { passive: true });
    },

    handleScroll() {
      const currentScroll = window.pageYOffset;

      if (Math.abs(currentScroll - this.lastScroll) < this.scrollThreshold) {
        return;
      }

      const header = document.querySelector('.header');
      if (!header) return;

      if (currentScroll > this.lastScroll && currentScroll > 100) {
        // Scrolling down & past threshold
        header.style.transform = 'translateY(-100%)';
      } else {
        // Scrolling up or at top
        header.style.transform = 'translateY(0)';
      }

      this.lastScroll = currentScroll;
    }
  };

  /**
   * Viewport Height Fix for Mobile Browsers
   * Fixes vh units on mobile (address bar hiding)
   */
  const ViewportFix = {
    init() {
      const setVH = () => {
        const vh = window.innerHeight * 0.01;
        document.documentElement.style.setProperty('--vh', `${vh}px`);
      };

      setVH();
      window.addEventListener('resize', setVH);
      window.addEventListener('orientationchange', setVH);
    }
  };

  /**
   * Prevent Overscroll Bounce (iOS)
   */
  const PreventOverscroll = {
    init() {
      document.body.style.overscrollBehavior = 'none';

      // Allow scrolling only within designated scroll containers
      const scrollContainers = document.querySelectorAll(`
        .news-list,
        .podcast-content,
        .all-content,
        .speed-panel,
        .bookmarks-panel,
        .drawer-content,
        .feed-scroll
      `);

      scrollContainers.forEach(container => {
        container.style.overscrollBehavior = 'contain';
      });
    }
  };

  /**
   * iOS Input Focus Fix
   * Prevents page zoom on input focus
   */
  const IOSInputFix = {
    init() {
      const inputs = document.querySelectorAll('input, textarea');

      inputs.forEach(input => {
        // Ensure font-size is at least 16px to prevent zoom
        const fontSize = window.getComputedStyle(input).fontSize;
        if (parseInt(fontSize) < 16) {
          input.style.fontSize = '16px';
        }

        // Scroll into view on focus
        input.addEventListener('focus', (e) => {
          setTimeout(() => {
            e.target.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }, 300);
        });
      });
    }
  };

  /**
   * Enhanced Loading States
   */
  const LoadingStates = {
    createSkeleton(type) {
      const skeletons = {
        article: `
          <div class="article skeleton-wrapper" style="pointer-events:none">
            <div class="skeleton" style="width:48px;height:48px;border-radius:12px"></div>
            <div style="flex:1">
              <div class="skeleton" style="width:60%;height:14px;margin-bottom:8px"></div>
              <div class="skeleton" style="width:100%;height:18px;margin-bottom:6px"></div>
              <div class="skeleton" style="width:90%;height:14px"></div>
            </div>
          </div>
        `,
        episode: `
          <div class="episode skeleton-wrapper" style="pointer-events:none">
            <div class="skeleton" style="width:64px;height:64px;border-radius:12px"></div>
            <div style="flex:1">
              <div class="skeleton" style="width:40%;height:13px;margin-bottom:6px"></div>
              <div class="skeleton" style="width:80%;height:15px;margin-bottom:8px"></div>
              <div class="skeleton" style="width:100%;height:8px;border-radius:4px"></div>
            </div>
          </div>
        `,
        card: `
          <div class="article-card skeleton-wrapper" style="pointer-events:none">
            <div class="skeleton" style="width:100%;height:200px;border-radius:16px 16px 0 0"></div>
            <div style="padding:18px">
              <div class="skeleton" style="width:60%;height:13px;margin-bottom:10px"></div>
              <div class="skeleton" style="width:100%;height:16px;margin-bottom:6px"></div>
              <div class="skeleton" style="width:90%;height:14px"></div>
            </div>
          </div>
        `
      };

      return skeletons[type] || skeletons.article;
    },

    show(container, type, count = 5) {
      if (container) {
        container.innerHTML = Array(count).fill(this.createSkeleton(type)).join('');
      }
    }
  };

  /**
   * Initialize all mobile enhancements
   * Call this in the main init() function
   */
  const initMobileEnhancements = () => {
    // Check if mobile
    const isMobile = window.innerWidth <= 640;
    const isTablet = window.innerWidth > 640 && window.innerWidth <= 1024;

    if (isMobile) {
      console.log(' Initializing mobile enhancements...');

      ViewportFix.init();
      initTouchFeedback();
      PullToRefresh.init();
      BottomSheet.init();
      SmartScroll.init();
      PreventOverscroll.init();
      IOSInputFix.init();

      console.log(' Mobile enhancements initialized');
    } else if (isTablet) {
      console.log(' Initializing tablet enhancements...');

      ViewportFix.init();
      initTouchFeedback();
      PullToRefresh.init();

      console.log(' Tablet enhancements initialized');
    }

    // Re-initialize on resize
    let resizeTimer;
    let wasMobile = isMobile;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => {
        const nowMobile = window.innerWidth <= 640;
        if (nowMobile !== wasMobile) {
          // Significant layout change - reinitialize
          wasMobile = nowMobile;
          if (nowMobile) {
            ViewportFix.init();
            PreventOverscroll.init();
          }
        }
      }, 250);
    });
  };

  // === INIT ===
  const init = async () => {
    // Await load to ensure server state is fetched first for cross-device consistency
    await load();

    // Initialize download database
    try {
      await DownloadDB.init();
      console.log('Download database initialized');

      // Sync download state with actual IndexedDB content
      const downloadedIds = await DownloadDB.getAll();
      const downloadedSet = new Set(downloadedIds);

      // Update podcast downloaded flags based on what's actually in IndexedDB
      let syncNeeded = false;
      state.podcasts.forEach(p => {
        const actuallyDownloaded = downloadedSet.has(p.id);
        if (p.downloaded !== actuallyDownloaded) {
          p.downloaded = actuallyDownloaded;
          syncNeeded = true;
        }
      });
      if (syncNeeded) save();
    } catch (e) {
      console.error('Failed to initialize download database:', e);
    }

    // Initialize snapshot database for state history/restoration
    try {
      await SnapshotDB.init();
      console.log('Snapshot database initialized');
    } catch (e) {
      console.error('Failed to initialize snapshot database:', e);
    }

    // Apply saved view state
    const applyView = () => {
      // Update toggle buttons
      document.querySelectorAll('.toggle-btn').forEach(b => {
        b.classList.toggle('active', b.dataset.view === state.view);
      });
      // Update view visibility
      el.newsView.classList.toggle('active', state.view === 'news');
      el.podcastView.classList.toggle('active', state.view === 'podcasts');
      el.allView.classList.toggle('active', state.view === 'all');
    };

    applyView();

    // Show loading skeletons while rendering (mobile only)
    if (window.innerWidth <= 640) {
      if (state.view === 'news') {
        LoadingStates.show(el.newsList, 'article', 5);
      } else if (state.view === 'podcasts') {
        LoadingStates.show(el.podcastInboxList, 'episode', 5);
      }
    }

    renderNewsSources();
    renderCategories();
    renderTagFilters();
    renderNews();
    if (state.view === 'podcasts') renderPodcasts();
    if (state.view === 'all') renderAll();

    // Initialize mobile enhancements AFTER initial render
    initMobileEnhancements();

    // Initialize activity tracking (syncs to Xano)
    Mem.init();

    // Sync state to server when page is hidden or closed (cross-device consistency)
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden') {
        StateSync.flushSync();
      }
    });
    window.addEventListener('beforeunload', () => {
      StateSync.flushSync();
    });

    console.log('BURSST loaded');
    console.log('[StateSync] Cross-device sync enabled:', StateSync.endpoint);
    console.log('[Mobile] Mobile optimizations active:', window.innerWidth <= 640);
    console.log('[Activity] Syncing to Xano:', Mem.endpoint);
    console.log('[API] User Behavior API:');
    console.log('  Memory.getLocal() - Get all local behavior logs');
    console.log('  Memory.getStats() - Get aggregated behavior statistics');
    console.log('  Memory.exportForSync() - Export all data for API sync');
    console.log('  Memory.clear() - Clear local behavior logs');
    console.log('[Tags] Content Tags:', Object.keys(CONTENT_TAGS).length, 'categories available for auto-tagging');
    console.log('[Archive] Archived:', state.archivedArticles.length, 'articles,', state.archivedPodcasts.length, 'episodes preserved');

    // Auto-refresh feeds on startup if we have feeds but limited cached content
    const podcastFeeds = state.feeds.filter(f => f.type === 'podcast');
    const newsFeeds = state.feeds.filter(f => f.type !== 'podcast');
    const hasPodcastFeeds = podcastFeeds.length > 0;
    const hasNewsFeeds = newsFeeds.length > 0;
    const hasCachedPodcasts = state.podcasts.length > 0;
    const hasCachedArticles = state.articles.length > 0;

    // Show loading state if we have feeds but no cached content
    if (hasPodcastFeeds && !hasCachedPodcasts && state.view === 'podcasts') {
      LoadingStates.show(el.podcastInboxList, 'episode', 6);
    }
    if (hasNewsFeeds && !hasCachedArticles && state.view === 'news') {
      LoadingStates.show(el.newsList, 'article', 6);
    }

    // Auto-refresh if we have feeds - fetch new content in background
    if (state.feeds.length > 0) {
      console.log('[Init] Auto-refreshing', state.feeds.length, 'feeds...');
      refreshAllFeeds(true).catch(e => console.error('[Init] Background refresh failed:', e));
    }
  };

  init();
})();
</script>
</body>
</html>
